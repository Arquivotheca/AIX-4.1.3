 static char sccsid[] = "@(#)65       1.30  src/bos/kernext/trace/trcdd.c, systrace, bos41J, 9519A_all 5/4/95 09:19:03";
 /*
 * COMPONENT_NAME: SYSTRACE   /dev/systrace pseudo-device driver 
 * 
 * FUNCTIONS: trcconfig, trcopen, trcclose, trcread, trcwrite, trcioctl
 *	      trc_wakeup, trcsetfsm, trc_offlevel
 * 
 * ORIGINS: 27 83
 * 
 *  This module contains IBM CONFIDENTIAL code. -- (IBM
 *  Confidential Restricted when combined with the aggregated
 *  modules for this product)
 *                   SOURCE MATERIALS
 *  (C) COPYRIGHT International Business Machines Corp. 1985, 1994
 *  All Rights Reserved
 * 
 *  US Government Users Restricted Rights - Use, duplication or
 *  disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*
 *  LEVEL 1, 5 Years Bull Confidential Information  
 */
/*
 *
 * *** SYSTRACE: trcinit trcopen trcclose trcread trcwrite trcioctl ***
 * SYSTRACE: trcconfig trcopen trcclose trcread trcwrite trcioctl
 *
 * /dev/systrace device driver
 * Everything is pinned.
 * None of these routines run on a fixed stack.
 *
 * /dev/systrace is a exclusive use device.
 * Only the opening process and its children can have open this file.
 *
 * /dev/systrctl is not an exclusive use device.
 * This allows start/stop control of the previously initialized trace process.
 * (data collection and read from /dev/systrace)
 *
 * See the state diagram at the end of trchkutil.c for a description of
 * control flow.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sysmacros.h>
#include <sys/uio.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/lockl.h>
#include <sys/intr.h>
#include <sys/pri.h>
#include <sys/syspest.h>
#include <sys/sleep.h>
#include <sys/trcctl.h>
#include <sys/trchkid.h>
#include <sys/trchdr.h>
#include <sys/dump.h>
#include <sys/priv.h>
#include <sys/low.h>
#include <sys/user.h>
#include <sys/time.h>

#ifdef _POWER_MP
#include <sys/lockname.h> /* LOCK CLASS definition */
#include <sys/lock_def.h> /* atomic ops */
#include <sys/lock_alloc.h> /* lock allocation/deallocation ops */
#else
#include <sys/proc.h>
#endif

struct timestruc_t c_time;

#ifndef	DEBUG
#define		Jprintf		(void)sizeof
#define		jsnap		(void)sizeof
#define		jsnapinit()
#else
int jsnap();
#endif


/*
 * ALLOCSIZE adds memory beyond the end of the tracebuffer
 *   to allow trchk() to write then check for overflow. This
 *   lets the test be "inptr > end" instead of "inptr + size > end"
 * SERIALIZE   invokes lockl   with the lockword for this channel.
 * UNSERIALIZE invokes unlockl with the lockword for this channel.
 */
#define ALLOCSIZE(nwords) (nwords + TRC_OVF)


#ifdef _POWER_MP

/* We cannot use the routine disable_lock and unlock_enable. An error occurs
 * when the hook generated by these routines is the last of the buffer 
 */

#define LOCKSPIN(addr_lock_trc) while (!(test_and_set(addr_lock_trc,1<<29)));\
					mem_isync();
	
#define UNLOCKSPIN(addr_lock_trc)	mem_sync();\
					fetch_and_and(addr_lock_trc,0);

#define SERIAL_BLE(ch,myint) 	{ myint = i_disable(INTMAX); \
				LOCKSPIN(&(trc_lock[ch])) \
				}

#define UNSERIAL_BLE(ch,myint) 	{ UNLOCKSPIN(&(trc_lock[ch])) \
			       	 i_enable((myint)) ; \
				}
#define SER_1(l)    simple_lock((simple_lock_t)&(l->trclck_1))
#define UNSER_1(l)  simple_unlock((simple_lock_t)&(l->trclck_1))
#define SERIALIZE(tp)	simple_lock((simple_lock_t)&tp->trc_lockword)
#define UNSERIALIZE(tp) simple_unlock((simple_lock_t)&tp->trc_lockword)
#define INIT_TP(tp)  	 simple_lock_init((simple_lock_t)&((tp)->trc_lockword))
#define ALLOC_TP(tp,i) 	 lock_alloc(&((tp)->trc_lockword), LOCK_ALLOC_PIN, TRCDD_LOCK_CLASS, i);
#else
#define SERIAL_BLE(ch,myint)	INT_OFF()
#define UNSERIAL_BLE(ch,myint) INT_ONX(myint)
#define SER_1(l)    serialize(&(l->trclck_1))
#define UNSER_1(l)  unserialize(&(l->trclck_1))
#define SERIALIZE(tp)    serialize(&tp->trc_lockword)
#define UNSERIALIZE(tp)  unserialize(&tp->trc_lockword)
#define INIT_TP(tp)  	 {(tp)->trc_lockword = LOCK_AVAIL;}
#define ALLOC_TP(tp,i) 	 
#endif

#define SER_KL(l)    lockl(&l,LOCK_SHORT)
#define UNSER_KL(l)  unlockl(&l)

/* Used in function pointers */
#define BOUNDT		1
#define UNBOUNDT	0

#define ATE_BITS	8
#define T_SYSCTL	1
#define T_SYSTRA	0
#define T_SYSOTH	0
#define IN_USE		1
#define MYMASK		0xFFFF


/*
 * Bits ops
 */
#ifdef _POWER_MP
/* Set the corresponding bit (i.e channel) in a flag */
#define T_setbit(x,type,ch) \
	fetch_and_or(x,(1 <<((ATE_BITS*type) + ch)) & MYMASK);

/* Clear the corresponding bit (i.e channel) in a flag */
#define T_clrbit(x,type,ch) \
	fetch_and_and(x, (~(1 <<((ATE_BITS*type) + ch))) & MYMASK);
#else
#define T_setbit(x,type,ch) \
        (*x |=((1 <<((ATE_BITS*type) + ch)) & MYMASK))

#define T_clrbit(x,type,ch) \
        (*x &= (~(1 <<((ATE_BITS*type) + ch))) & MYMASK)
#endif


struct cdt_head *trccdtf();		/* dmp_do cdt structure routine */


#ifndef _POWER_MP 
static void unserialize(lock_t *lock);
static void serialize( lock_t *lock);
#endif

static int *jmalloc();			/* allocate integers */
static jfree();				/* free integers */
static struct trchdr *minortotp();	/* convert minor device to its trchdr */

int trc_privflg  = 1;			/* use privilege checking */
int trc_printflg = 1;			/* allow Jprintf to kernel printf */
/* Locks */
struct trclck {
	/* 
	 * trclck_1 type is int for compatibility with lock_t type or
	 * simple_lock_t type
	 */
	int trclck_1;			/* lock */
};
typedef	struct	trclck	trclck_t;

/*
 * Lock used to synchronize trcgen functions with
 * the unloading of the driver
 */

extern int initfp_lock;


/* For the multiprocessors, a new lock is necessary to lock the code.
 * i.e. we replace the disable, enable per disable_lock, unlock_enable.
*/
#ifdef _POWER_MP
int	trc_lock[TRC_NCHANNELS];
int     trc_assert_off[TRC_NCHANNELS];
int     trc_offlevel_lock ; /* to synchronize access to trcwakechan by processors */
#endif

static (*trc_icfunc)();			/* set by trc_icinit() */

static trc_syncword[TRC_NCHANNELS];	/* for trc_sync() */

#ifdef _POWER_MP
trclck_t tracelock;
#else
trclck_t tracelock={LOCK_AVAIL}; 	/* private trace lock */
#endif

int	config_count;
int	open_flag;
int	open_count;
int	open_count_null; /* for MDEV_SYSUTIL, MDEV_SYSMEM, MDEV_SYSNULL */

/* 152616 */
extern int trcgenasm_on();
/* end 152616 */
#ifdef _POWER_MP
extern uint trcwakechan;
#else
extern uchar trcwakechan;
#endif
extern uint trc_bussreg;
extern uint trc_busaddr;
extern uint kerntrc;

/* These pointers are invoked in assembler routines */
extern void trc_ptrdmy();
extern int trc_ptrdmy0();

extern int (*_trcbuffullfp)();
extern int trcbuffullgen();
extern void (*_trcgenfp)();
extern void (*_trcgentfp)();
extern void (*_trcgenkfp)();
extern void (*_trcgenktfp)();
extern int (*_trc_trcofffp)();
extern int (*_trc_trconfp)();
extern void (*Jprintf_fp)();
extern void (*jsnap_fp)();
extern struct trchdr *trchdr_ptr, fake_trchdr[]; 
extern char *trc_savefp;
extern char trc_save;

extern void trcgenG();
extern void trcgentG();
extern void trcgenkG();
extern void trcgenktG();

extern nulldev();
extern nodev();

int trc_trcon();
int trc_trcoff();
int trcconfig();
int trcopen();
int trcclose();
int trcread();
int trcwrite();
int trcioctl();
static trc_inithkfp();

struct	devsw	trcsw ={ 
		trcopen, trcclose, trcread, trcwrite, trcioctl, nodev, 
		0, nodev, trcconfig, nodev, nodev, nodev, 0, 0 , 0
		}; 


int	lockl_rc;		/* return code from lockl() */

/*
 * NAME:        trcconfig instead of trcinit
 * FUNCTION:    Called from user command sysconfig 
 * ENVIRONMENT: pinned and interrupts are assumed to be disabled.
 * INPUTS:      mmdev, cmd, uiop
 * RETURNS:     0 if OK
 *              if error, value set in the function
 */

int trcconfig(mmdev,cmd,uiop)
dev_t mmdev;
int cmd;
struct uio *uiop;
{
#define uiop_ubase	uiop->uiuovec->iov_base	

	int ret;
	int old_ints;
	register int i;
	register struct trchdr *tp;
	register trclck_t *ptlck;
	register struct devsw *mytrcsw;
	
	trc_debug("trcconfig(%x,%x,%x)\n",mmdev,cmd,uiop);
	ret = 0;

#ifdef _POWER_MP
	if (!config_count) {
 		lock_alloc(&(tracelock.trclck_1), LOCK_ALLOC_PIN, TRACE_LOCK_CLASS, 0);
		simple_lock_init((simple_lock_t)&(tracelock.trclck_1));
		lock_alloc(&(trc_offlevel_lock), LOCK_ALLOC_PIN, TRACE_LOCK_CLASS,  1);
		simple_lock_init((simple_lock_t)&(trc_offlevel_lock));
	}
#endif
	ptlck = &tracelock;
	mytrcsw = &trcsw;
	SER_1(ptlck);
	switch(cmd) {
		case CFG_INIT:
			++config_count;
			/* If it's a config. for the 1st time, then go on
			  otherwise get out of this way ! */

			if (config_count == 1) {
				if ((ret = pincode(trcconfig)) != 0) {
					/* return pin fails */
					goto raus;
				}

				tp = &trchdr[0];
				/* init trchdr */
				for(i = 0; i < TRC_NCHANNELS; i++) {	
					ALLOC_TP(tp+i,i);
					INIT_TP(tp+i);
					(tp+i)->trc_sleepword = EVENT_NULL;
				}

				trc_timeoutinit();
				dmp_add(trccdtf);
				jsnapinit();
		
				/* 
				 * Initialize function pointers
				 */
				trc_inithkfp(BOUNDT);
				fetch_and_and(&initfp_lock,0);
			
	
				/* Initialize wake channel status.
				 */
#ifdef _POWER_MP
				fetch_and_and((int *)&trcwakechan,0);
#else
				trcwakechan=0;
#endif
	
		/* Initialize bus segment register value and address for
		 * to-bus mode to be the address of the kernel trace/dump
		 * buffer so if bus mode is enabled and these values aren't
		 * changed then we just write to this buffer.
		 */
				trc_bussreg = 0;
				trc_busaddr = (uint)&kerntrc;
	
				/* Add entry points to devsw, 
				   if fails then return */
				if ((ret=devswadd(mmdev,mytrcsw)) != 0) 
					unpincode(trcconfig);
				mem_sync();
			} /* config_count == 1 */
			break;


		/* Terminate device driver associated with the specified
		   mmdev */
		case CFG_TERM:
			/* If all are down, open_flag should be = 0 */
			open_flag = open_count_null + open_count; 
			if (config_count == 1){
				fetch_and_or(&initfp_lock,(1<<29));
				mem_sync();
				if (!open_flag && (initfp_lock == (1<<29)) ) {
					trc_inithkfp(UNBOUNDT);
					mem_sync();
					dmp_del(trccdtf);
					/* Delete the switch table entry 
					   and unpin the code */
					SER_KL(kernel_lock);
					if ((ret = devswdel(mmdev)) != 0)
						printf("trcconfig: devswdel error\n");
					UNSER_KL(kernel_lock);
                                        --config_count;
					unpincode(trcconfig);
					/* goto raus; */
					UNSER_1(ptlck);
#ifdef _POWER_MP
					lock_free(&(tracelock.trclck_1));
#endif
					return(ret);
				}
				/* here the driver is busy */
				else {
					ret = EBUSY;
					Jprintf("Device busy ...\n");
					goto raus;
				} /* !open_flag */
			}
			else {
				--config_count;
				ret = 0;
			} /* config_count == 1 */

			break;

		case CFG_QVPD:
			break;

		default:
			ret = EINVAL ;

	}

raus:
	UNSER_1(ptlck);
	return(ret);

}

/*
 * NAME:        trc_inithkfp
 * FUNCTION:    set the _trcbuffullfp, _trcgenfp, _trcgentfp, trcgenkfp
 *	        _trc_trcofffp, _trc_trconfp, trchdr_ptr, _trcgenktfp
 *		jsnap_fp, Jprintf_fp
 *	        function pointers respectively to their effective
 *	        peer routines or reset to null function pointers/fake 
 *		structure
 * ENVIRONMENT: The routine is pinned and can be called anytime
 * INPUTS:      flag
 * RETURNS:     none
 */

static trc_inithkfp(flag)
int 	flag;
{
	trc_debug("trc_inithkfp(%x)\n",flag);
	if (flag) {
		_trcbuffullfp = trcbuffullgen;
		_trcgenfp = trcgenG;
		_trcgentfp= trcgentG;
		_trcgenkfp = trcgenkG;
		_trcgenktfp = trcgenktG;
		_trc_trcofffp = trc_trcoff;
		_trc_trconfp = trc_trcon;
		trchdr_ptr = &trchdr[0];
		trc_savefp = &trc_save;
#ifdef DEBUG
		jsnap_fp = (void *)jsnap;
		Jprintf_fp = (void *)Jprintf;
#endif
	}
	else {
		_trcbuffullfp = trc_ptrdmy0;
		_trcgenfp = trc_ptrdmy;
		_trcgentfp= trc_ptrdmy;
		_trcgenkfp = trc_ptrdmy;
		_trc_trcofffp = trc_ptrdmy0;
		_trc_trconfp = trc_ptrdmy0;
		_trcgenktfp = trc_ptrdmy;
		trchdr_ptr = &fake_trchdr[0];
#ifdef DEBUG
		jsnap_fp = (void *)trc_ptrdmy0;
		Jprintf_fp = (void *)trc_ptrdmy0;
#endif
	}
}


/*
 * NAME:        trc_icinit
 * FUNCTION:    set the trc_icfunc function pointer to allow the
 *              "initial conditions" device driver to trace initial
 *              conditions before trace hooks are turned on.
 * ENVIRONMENT: The routine is pinned and can be called anytime
 * INPUTS:      func    function pointer to call.
 * RETURNS:     none
 */
trc_icinit(func)
int (*func)();
{

	trc_icfunc = func;
}

/*
 * NAME:        trcopen
 * FUNCTION:    trcdd open routine called through devsw
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      mmdev    major/minor device number
 * RETURNS:     ENODEV   if minor number is not known
 *              EBUSY    if a "systraceX" device is already open
 */
trcopen(mmdev)
dev_t mmdev;		/* contains either MDEV_SYSTRACE or MDEV_SYSTRCTL */
{
	register struct trchdr *tp;
	int mdev;

	trc_debug("trcopen(%x)\n",mmdev); 
  	mdev = minortomdev(mmdev);
	switch(mdev) {
	case MDEV_SYSMEM:
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
		T_setbit(&open_count_null,T_SYSOTH,0); 
		return(0);
	}

	trc_debug("trcopen(%x)\n",mdev);
	tp = minortotp(mmdev);
	switch(mdev) {
	case MDEV_SYSTRACE:
		SERIALIZE(tp);
		if(tp->trc_state & ST_ISOPEN) {		/* Ensure exclusivity */
			UNSERIALIZE(tp);
			trc_debug("trcopen: EBUSY\n");
			return(EBUSY);
		}
		T_setbit(&open_count,T_SYSTRA,minortoarray(mmdev)); 
		tp->trc_state = ST_ISOPEN;
		UNSERIALIZE(tp);
		return(0);
	case MDEV_SYSTRCTL:
		T_setbit(&open_count,T_SYSCTL,minortoarray(mmdev));
		return(0);
	default:
		return(ENODEV);
	}
}

/*
 * NAME:        trcclose
 * FUNCTION:    trcdd close routine called through devsw
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      mmdev    major/minor device number
 * RETURNS:     ENODEV   if minor number is not known
 *                       This should not happen because the open routine
 *                       returns error in this case.
 *
 * When systrace is closed, tracing is turned off through trchk_init,
 * the internal state variables trc_mode, trc_state, and trc_fsm are 
 * cleared, and the trace buffers are freed.
 */
trcclose(mmdev)
dev_t mmdev;		/* contains either MDEV_SYSTRACE or MDEV_SYSTRCTL */
{
	int mdev;
	register struct trchdr *tp;
	int old_ints;

	trc_debug("trcclose(%x)\n",mmdev); 
  	mdev = minortomdev(mmdev);
	switch(mdev) {
	case MDEV_SYSMEM:
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
		T_clrbit(&open_count_null,T_SYSOTH,0);
		return(0);
	}
	trc_debug("trcclose(%x)\n",mdev);
	tp = minortotp(mmdev);
	switch(mdev) {
	case MDEV_SYSTRACE:
		SERIALIZE(tp);
		if(!(tp->trc_state & ST_ISOPEN)) {
			Jprintf("trcclose(%x) state=%x\n",tp->trc_state);
			T_clrbit(&open_count,T_SYSTRA,minortoarray(mmdev)); 
			UNSERIALIZE(tp);
			return(0);
		}
		SERIAL_BLE((tp - trchdr),old_ints); 
		trchk_init(tp,0);
		trc_syncchk(tp); /* wake up process (if any) waiting on close */
		tp->trc_mode  = 0;
		tp->trc_state = 0;
		trcsetfsm(tp,0);
		/*
		 * For the sake of the trcfree() below
		 */
		UNSERIAL_BLE((tp - trchdr),old_ints); 
		trcfree(tp);
		T_clrbit(&open_count,T_SYSTRA,minortoarray(mmdev)); 
		UNSERIALIZE(tp);
		return(0);
	case MDEV_SYSTRCTL:
		T_clrbit(&open_count,T_SYSCTL,minortoarray(mmdev)); 
		return(0);
	default:
		return(ENODEV);
	}
}

/*
 * Read the kernel trace buffers (ktb) into a user buffer.
 * Depending upon the trace mode, there are either one or two trace buffers.
 * read(fd,buf,count) to /dev/systrace copy up to 'count' bytes
 *  from the front ktb to the user buffer 'buf'.
 * If the size of the ktb is less than count, only that many will be copied.
 * The return value will be this number actually copied.
 * The user program must call trcread twice to empty the ktb.
 *  (circular and alternate)
 * Apart from the need to do two reads, the buffer management is transparent
 *  to the caller. Data is read out in fifo fashion.
 *
 * trcread will return (the read is satisfied) when:
 *  In circular mode, on a TRCOFF ioctl call.
 *  After this, read will return with the number of bytes transfered.
 *   Both ktb's empty will return EOF.
 *   A TRCON ioctl call will reset the ktb and cause read to block until
 *   the ktb becomes full.
 *
 *  In alternate mode, on a TRCOFF ioctl call.
 *  After this, read will return with the number of bytes transfered.
**   Both ktb's empty will block.
**   A TRCON ioctl call will reset the ktb.
 *  In alternate mode, when one of the ktb's becomes full.
 *  After this, read will return with the number of bytes transfered.
 *   An empty ktb will block until the other ktb becomes full.
 *
 *  In single mode, when the ktb becomes full.
 *  After this, read will return with the number of bytes transfered.
 *   An empty ktb will return EOF.
 *   A TRCON ioctl call will reset the ktb and cause read to block until
 *   the ktb becomes full.
 *
 *  In bus mode, always return EOF.
**  If the TRCSTOP ioctl call has been issued, return EOF.
 */

/*
 * NAME:        trcread
 * FUNCTION:    trcdd read routine called through devsw
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      mmdev    major/minor device number
 * RETURNS:     ENODEV   if minor number is not known
 *
 * The trcread is a null function. The trace io operation is handled
 * by the TRCIOC_LOGIO ioctl.
 */
trcread(mmdev,uiop)
dev_t mmdev;		/* contains either MDEV_SYSTRACE or MDEV_SYSTRCTL */
struct uio *uiop;
{
	int mdev;

	trc_debug("trcread(%x,%x)\n",mmdev,uiop); 
  	mdev = minortomdev(mmdev);

	switch(mdev) {
	case MDEV_SYSMEM:
#ifdef DEBUG
		return(uiomove((off_t)uiop->uio_offset, uiop->uio_resid,
							UIO_READ, uiop));
#endif
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
		return(0);
	case MDEV_SYSTRACE:
	case MDEV_SYSTRCTL:
		return(ENODEV);
	default:
		return(ENODEV);
	}
}

#define ISEMPTY_FI(qp) ((qp)->q_inptr == (qp)->q_start)

/* This state has been added for single mode, in case of  buffer full
 * buffer is flushed and current pointer is set at the beginning of buffer A.
 *		see scheme in trchkutil.c
 */
#define EMPTYCHK_A_START(tp,fsm) \
        trc_debug("EMPTYCHK_A_START:\n"); \
        if(ISEMPTY_FI(&tp->trc_Aq)) { \
                trc_debug("EMPTYCHK_A_START: empty\n"); \
                trcsetfsm(tp,fsm); \
                (&tp->trc_currq)->q_inptr = (&tp->trc_Aq)->q_start; \
                goto loop; \
        } \
        if(rv_error = trclogio2(tp,&tp->trc_Aq,&old_ints)) \
                goto ret; \
        goto loop;

#define EMPTYCHK_A(tp,fsm) \
	trc_debug("EMPTYCHK_A:\n"); \
	if(ISEMPTY_FI(&tp->trc_Aq)) { \
		trc_debug("EMPTYCHK_A: empty\n"); \
		trcsetfsm(tp,fsm); \
		goto loop; \
	} \
	if(rv_error = trclogio2(tp,&tp->trc_Aq,&old_ints)) \
		goto ret; \
	goto loop;

#define EMPTYCHK_B(tp,fsm) \
	trc_debug("EMPTYCHK_B:\n"); \
	if(ISEMPTY_FI(&tp->trc_Bq)) { \
		trc_debug("EMPTYCHK_B: empty\n"); \
		trcsetfsm(tp,fsm); \
		goto loop; \
	} \
	if(rv_error = trclogio2(tp,&tp->trc_Bq,&old_ints)) \
		goto ret; \
	goto loop;

#define EOFCHK(tp) \
	trc_debug("EOFCHK\n"); \
	if(tp->trc_state & ST_TRCSTOP) { \
		trcsetfsm(tp,FSM_SPILL_EOF); \
		goto loop; \
	} \
	trclogio_sleep(tp, &old_ints); \
	goto loop;

/*
 * like EMPTYCHK_A, but unspills trace if empty
 */
#define EMPTYCHK_A_ON(tp,fsm) \
	trc_debug("EMPTYCHK_A_ON:\n"); \
	if(ISEMPTY_FI(&tp->trc_Aq)) { \
		trc_debug("EMPTYCHK_A: empty\n"); \
		tp->trc_currq = tp->trc_Aq; \
		trcsetfsm(tp,fsm); \
		if ( Trconflag[tp-trchdr] ) \
			trchk_init(tp,modetotmode(tp->trc_mode)); \
		goto loop; \
	} \
	if(rv_error = trclogio2(tp,&tp->trc_Aq,&old_ints)) \
		goto ret; \
	goto loop;

#define EMPTYCHK_B_ON(tp,fsm) \
	trc_debug("EMPTYCHK_B_ON:\n"); \
	if(ISEMPTY_FI(&tp->trc_Bq)) { \
		trc_debug("EMPTYCHK_B: empty\n"); \
		tp->trc_currq = tp->trc_Bq; \
		trcsetfsm(tp,fsm); \
		if ( Trconflag[tp-trchdr] ) \
			trchk_init(tp,modetotmode(tp->trc_mode)); \
		goto loop; \
	} \
	if(rv_error = trclogio2(tp,&tp->trc_Bq,&old_ints)) \
		goto ret; \
	goto loop;

/*
 * NAME:        trclogio
 * FUNCTION:    trace buffer to logfile io routine through the fp_write
 *              kernel service.
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 *              Interrupts are disabled when accessing the trchdr (tp)
 *              structure, and reenabled when calling fp_write.
 * INPUTS:      tp         pointer to trchdr structure for this channel
 * RETURNS:     ENOTREADY  trace has not been properly initialized by
 *                         the CFGMTRX and TRCIOC_LOGIO ioctl.
 *
 * trclogio runs in the context of the trace demon. The routine does not
 * return to user mode until tracing is stopped. This allows the trace
 * demon to write the tracebuffer directly to the trace logfile, without
 * the intervening copyout/copyin.
 */
static trclogio(tp)
struct trchdr *tp;
{
	int rv_error;
	int old_ints;

	trc_debug("trclogio(%x)\n",tp); 
	SERIALIZE(tp);
	SERIAL_BLE((tp - trchdr),old_ints); 
	rv_error = 0;
loop:
	if(tp->trc_fsm == 0 || tp->trc_lp == 0) {
		rv_error = ENOTREADY;
		goto ret;
	}
	trc_debug("trclogio: fsm=%d\n",tp->trc_fsm);
	switch(tp->trc_mode) {
	case MD_CIRCULAR:
	case MD_CIRCULAR_COND:
		switch(tp->trc_fsm) {
		case FSM_SPILL_EOF:    goto ret;	/* return EOF */
		case FSM_A_BLOCK:      trclogio_sleep(tp,&old_ints); goto loop;
		case FSM_B_BLOCK:      trclogio_sleep(tp,&old_ints); goto loop;
		case FSM_SPILL_BLOCK:  EOFCHK(tp);
		case FSM_SPILL_B_OFF:  EMPTYCHK_B(tp,FSM_SPILL_A_OFF);
		case FSM_SPILL_A_OFF:  EMPTYCHK_A(tp,FSM_SPILL_BLOCK);
		case FSM_SPILL_A_OFF2: EMPTYCHK_A(tp,FSM_SPILL_B_OFF2);
		case FSM_SPILL_B_OFF2: EMPTYCHK_B(tp,FSM_SPILL_BLOCK);
		}
		assert(0 == MD_CIRCULAR);
	case MD_ALTERNATE:
	case MD_ALTERNATE_COND:
		switch(tp->trc_fsm) {
		case FSM_SPILL_EOF:    goto ret;	/* return EOF */
		case FSM_A_BLOCK:      trclogio_sleep(tp,&old_ints); goto loop;
		case FSM_B_BLOCK:      trclogio_sleep(tp,&old_ints); goto loop;
		case FSM_SPILL_BLOCK:  EOFCHK(tp);
		case FSM_SPILL_B_OFF:  EMPTYCHK_B(tp,FSM_SPILL_A_OFF);
		case FSM_SPILL_A_OFF:  EMPTYCHK_A(tp,FSM_SPILL_BLOCK);
		case FSM_SPILL_A_OFF2: EMPTYCHK_A(tp,FSM_SPILL_B_OFF2);
		case FSM_SPILL_B_OFF2: EMPTYCHK_B(tp,FSM_SPILL_BLOCK);
		case FSM_A_B:          EMPTYCHK_B(tp,FSM_A_BLOCK);
		case FSM_B_A:          EMPTYCHK_A(tp,FSM_B_BLOCK);
		case FSM_SPILL_B:      EMPTYCHK_B_ON(tp,FSM_B_A);
		case FSM_SPILL_A:      EMPTYCHK_A_ON(tp,FSM_A_B);
		}
		assert(0 == MD_ALTERNATE);
	case MD_SINGLE:
	case MD_SINGLE_COND:
	switch(tp->trc_fsm) {
		case FSM_SPILL_EOF:    goto ret;	/* return EOF */
		case FSM_A_BLOCK:      trclogio_sleep(tp,&old_ints); goto loop;
		case FSM_SPILL_A_OFF:  EMPTYCHK_A(tp,FSM_SPILL_EOF);
		case FSM_SPILL_A:      EMPTYCHK_A_START(tp ,FSM_A_BLOCK);
		}
		assert(0 == MD_SINGLE);
	case MD_BUS:
	case MD_BUS_COND:
	default:
		rv_error = EINVAL;
		goto ret;
	}
ret:
	UNSERIAL_BLE((tp - trchdr),old_ints); 
	UNSERIALIZE(tp);
	trc_debug("return from trclogio(%x) error=%d\n",tp,rv_error);
	return(rv_error);
}

/*
 * NAME:        trclogio2
 * FUNCTION:    extension of trclogio to update the logfile from the
 *              trace buffer and the trc_lp structure.
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      tp         pointer to trchdr structure for this channel
 *              qp         pointer to trchdr fifo structure (A or B)
 *		old_ints   pointer to previous interrupt priorities.
 * RETURNS:     EIO        trace buffer pointers are not right.
 *              other      error from fp_write
 */
static trclogio2(tp,qp,old_ints)
register struct trchdr *tp;
register struct trc_q *qp;
int *old_ints;
{
	int rv_error;
	int count;
	register struct trc_log *lp;
	register struct trc_log_entry *lep;
	struct {
		unsigned wraphook;
		unsigned data;
		int w_tid; /* add the tid */
	} w;


	rv_error = 0;
	count = (char *)qp->q_inptr - (char *)qp->q_start;
	qp->q_inptr = qp->q_start;
	trc_debug("trclogio2: count=%x\n",count);
	if(count <= 0) {
		if(count == 0)
			return(0);
		return(EIO);
	}
	UNSERIAL_BLE((tp - trchdr),*old_ints); 
	lp = tp->trc_lp;
	if(lp == 0)
		return(EIO);
	if(lp->l_mode & MDL_NOWRAP) {
		rv_error = p_write(lp->l_fp,qp->q_start,-1,count);
		goto ret;
	}
	lep = &lp->l_data[lp->l_currentry];
	/* VA  added line - check for > protects contents of log  */
	if(lp->l_mode & MDL_STOPONWRAP && lp->l_currentry+1 > lp->l_nentries) {
		goto ret;
	}
	rv_error = p_write(lp->l_fp,qp->q_start,lep->le_offset,count);
	if(rv_error)
		goto ret;
	lep->le_size = count;
	mem_sync();
	/* VA modified - change check from >= to = only */
	if(lp->l_mode & MDL_STOPONWRAP && lp->l_currentry+1 == lp->l_nentries) {
		/* VA  added line - increment currentry to flag that last entry was written  */
		lp->l_currentry++;
		trcstop(tp);
		rv_error = p_write(lp->l_fp,lp,0,TRC_LSIZE(&lp->l_h));
		goto ret;
	}
	lp->l_currentry++;
	if(lp->l_currentry >= lp->l_nentries) {
		trc_debug("log wrap\n");
		lp->l_currentry = 0;
		lp->l_wrapcount++;
		w.wraphook = HKWD_TRACE_LWRAP | HKTY_L | (lp->l_wrapcount & 0xFFFF);
		w.data     = time;
		w.w_tid    = thread_self();
		rv_error = p_write(lp->l_fp,&w,lep->le_offset+count,sizeof(w));
		if(rv_error)
			goto ret;
		lep->le_size += sizeof(w);
	}
	rv_error = p_write(lp->l_fp,lp,0,TRC_LSIZE(&lp->l_h));
ret:
	SERIAL_BLE((tp - trchdr),*old_ints); 
	return(rv_error);
}

/*
 * NAME:        p_write
 * FUNCTION:    extension of trclogio2 to fp_seek and fp_write
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      fp         file pointer from trace demon open system call
 *              buf        buffer to write to fp
 *              offset     offset in file to write to
 *              count      size of buffer in bytes
 * RETURNS:     errno 	   if error occurred in fp_write
 */
static p_write(fp,buf,offset,count)
struct file *fp;
char *buf;
{
	int rv,rv_count;

	trc_debug("p_write(%x,%x,%x,%x)\n",fp,buf,offset,count);
	if(offset != -1) { /* don't seek if offset = -1. (NOWRAP mode) */
		rv = fp_lseek(fp,offset,0);
		if(rv == -1)
			return(-1);
	}
	rv = fp_write(fp,buf,count,0,UIO_SYSSPACE,&rv_count);
	if(rv || rv_count != count) {
		Jprintf("trcdd: err=%d count=%d\n",rv,rv_count);
		return(rv);
	}
	return(0);
}

/*
 * NAME:        trclogio_sleep
 * FUNCTION:    interface to e_sleep
 * ENVIRONMENT: pinned and interrupts are assumed to be disabled.
 * INPUTS:      tp         trchdr for this channel
 *		old_ints   pointer to old interrupt priorities.
 * RETURNS:     none
 */
static trclogio_sleep(tp,old_ints)
struct trchdr *tp;
int *old_ints;
{

	trc_debug("trclogio_sleep(%x)\n",tp); 
	tp->trc_sleepword = EVENT_NULL;

#ifdef _POWER_MP
		fetch_and_and (&trc_assert_off[tp-trchdr],0);
		UNLOCKSPIN(&(trc_lock[tp-trchdr]))
		e_assert_wait(&tp->trc_sleepword,!INTERRUPTIBLE);
		if ( trc_assert_off[tp-trchdr] ==  1 ) { /* wakeup was called */
			UNSERIALIZE(tp);
			e_clear_wait(thread_self(),0);
		}
		else {
			UNSERIALIZE(tp);
			e_block_thread();
		}
#else
	UNSERIALIZE(tp);
	e_sleep(&tp->trc_sleepword,EVENT_SHORT);
#endif
	trc_debug("return from trclogio_sleep\n");
	i_enable (*old_ints);
	SERIALIZE(tp);
	SERIAL_BLE((tp - trchdr),*old_ints); 
}

/*
 * NAME:        trc_offlevel
 * FUNCTION:    off-level handler for handling wakeup function
 * ENVIRONMENT: pinned
 * INPUTS:      handler        handler structure
 * RETURNS:     none
 */
int 
trc_offlevel(handler)
struct intr *handler;
{
	int i, oldpri;
	register struct trchdr *tp; /* BULL */

	/* Find a bit set in trcwakechan to determine which
	 * channel to wake up for then reset the bit.
	 * Multiple bits may be set (when wakeups have been scheduled
	 * for multiple channels) but we only need to handle one
	 * since each one schedules a call to this routine.
	 * This must be serialized with the setting of trcwakechan
	 * so it must be done at INTMAX.
	 */
	tp = &trchdr[0]; /* BULL */

#ifdef _POWER_MP
	oldpri = disable_lock(INTMAX,(simple_lock_t)&(trc_offlevel_lock)) ;
#else
	oldpri = i_disable(INTMAX);
#endif
	for (i=0; i<=TRC_NCHANNELS; i++)
#ifdef _POWER_MP
		if (trcwakechan & (1 << (i+24)))
		{
			fetch_and_and((int *)&trcwakechan,  ~ (1 << (i+24)));
#else
		if (trcwakechan & (1 << i))
		{
			trcwakechan &= ~ (1 << i);
#endif
			break;
		}
#ifdef _POWER_MP
	unlock_enable(oldpri,(simple_lock_t)&(trc_offlevel_lock)) ;
#else
	i_enable(oldpri);
#endif
	
	if (i < TRC_NCHANNELS)
		trc_wakeup(tp+i); /* BULL */
}

/*
 * NAME:        trc_wakeup
 * FUNCTION:    interface to e_wakeup
 * ENVIRONMENT: pinned
 * INPUTS:      tp         trchdr for this channel
 * RETURNS:     none
 */
trc_wakeup(tp)
struct trchdr *tp;
{

	#ifdef _POWER_MP
		fetch_and_or (&trc_assert_off[tp-trchdr],1);
	#endif
	e_wakeup(&tp->trc_sleepword);
}

/*
 * NAME:        trcwrite
 * FUNCTION:    trcdd write routine called through devsw
 * ENVIRONMENT: pinned and interrupts are assumed to be enabled.
 * INPUTS:      mmdev    major/minor device number
 * RETURNS:     ENODEV   if minor number is not known
 *
 * The trcwrite is a null function.
 */
trcwrite(mmdev,uiop)
dev_t mmdev;		/* contains either MDEV_SYSTRACE or MDEV_SYSTRCTL */
struct uio *uiop;
{
	int mdev;

	trc_debug("trcwrite(%x,%x)\n",mmdev,uiop); 

	mdev = minortomdev(mmdev);
	switch(mdev) {
	case MDEV_SYSMEM:
#ifdef DEBUG
	    return(uiomove((off_t)uiop->uio_offset,
				uiop->uio_resid,UIO_WRITE,uiop));
#endif
	case MDEV_SYSUTIL:
		return(0);
	default:
		return(ENODEV);
	}
}

trcioctl(mmdev,cmd,arg)
dev_t mmdev;		/* contains either MDEV_SYSTRACE or MDEV_SYSTRCTL */
int cmd;			/* ioctl command */
int arg;			/* sometimes-used additional argument */
{
	int mdev;
	struct trchdr *tp;

	trc_debug("trcioctl(%x,%x,%x)\n",mmdev,cmd,arg); 

 	if((mdev = minortomdev(mmdev)) < 0)
 		return(ENODEV);
	switch(mdev) {
	case MDEV_SYSMEM:
	case MDEV_SYSNULL:
		return(0);
	case MDEV_SYSUTIL:
		return(ioctl_util(cmd,arg));
	}
	tp = minortotp(mmdev);
	switch(mdev) {
	case MDEV_SYSTRACE:
		return(ioctl_systrace(tp,cmd,arg));
	case MDEV_SYSTRCTL:
		return(ioctl_systrctl(tp,cmd,arg));
	default:
		return(EINVAL);
	}
}

static ioctl_systrace(tp,cmd,arg)
register struct trchdr *tp;
int cmd;		/* ioctl command */
int arg;		/* sometimes-used additional argument */
{
	struct tr_struct tr;
	int i;
	int isize;		/* size of collection buffers in bytes */
	int condflg;
	int rv_error;

	trc_debug("ioctl_systrace(%x,%x,%x)\n",tp,cmd,arg); 

	rv_error = 0;
	condflg = 0;
	SERIALIZE(tp);
	switch(cmd) {	/* check for valid command */
	case CFGMTRL:
	case CFGMTRA:
	case CFGMTRF:
		if(tp->trc_mode != MD_OFF) {	/* can configure only once */
			rv_error = EBUSY;
			goto ret;
		}
		if(copyin(arg,&tr,sizeof(tr)) != 0) {
			rv_error = EINVAL;
			goto ret;
		}
		break;
	case CFGBTR:
		if(tp->trc_mode != MD_OFF) {	/* can configure only once */
			rv_error = EBUSY;
			goto ret;
		}
		break;
	case TRC_LOADER:
		rv_error = trc_loader(arg);
		goto ret;
	case TRCIOC_LOGIO:
		UNSERIALIZE(tp);
		return(trclogio(tp));
	case TRCIOC_LOGCFG:
	  {
		int size;
		struct trc_log_hdr log_hdr;
		struct trc_log *lp;

		if(copyin(arg,&log_hdr,sizeof(log_hdr))) {
			rv_error = EFAULT;
			goto ret;
		}
		size = TRC_LSIZE(&log_hdr);
		if((lp = (struct trc_log *)xmalloc(size,2,kernel_heap)) == 0) {
			rv_error = ENOMEM;
			goto ret;
		}
		tp->trc_lp = lp;
		if(copyin(arg,lp,size)) {
			rv_error = EFAULT;
			goto ret;
		}
		if(getfx(lp->l_fd,&lp->l_fp) || lp->l_fp == 0) {
			rv_error = EBADF;
			goto ret;
		}
        /* Decrement the file descriptor use count */
                ufdrele(lp->l_fd);
		goto ret;
	  }
	default:
		rv_error = EINVAL;
		goto ret;
	}
	for(i = 0; i < sizeof(tr.tr_events); i++) {
		if(tr.tr_events[i] != 0xFF) {
			condflg++;
			break;
		}
	}
	bcopy(tr.tr_events,tp->trc_events,sizeof(tp->trc_events));
	if(tr.tr_tbufsize > TRC_TBUFUMAX && ras_privchk() < 0) {
		rv_error = EPERM;
		goto ret;
	}
	if(tr.tr_tbufsize < 8192) {
		rv_error = EINVAL;
		goto ret;
	}
	isize = tr.tr_tbufsize >> 2; /* div by 4 <bui> */	/* words */
	switch(cmd) {
	case CFGMTRL:					/* CIRC */
		if(rv_error = trcalloc(tp,isize,isize))
			goto ret;
		tp->trc_mode = condflg ? MD_CIRCULAR_COND : MD_CIRCULAR;
		trcsetfsm(tp,FSM_A_BLOCK);
		tp->trc_currq = tp->trc_Aq;
		break;
	case CFGMTRA:					/* ALT */
		if(rv_error = trcalloc(tp,isize,isize))
			goto ret;
		tp->trc_mode = condflg ? MD_ALTERNATE_COND : MD_ALTERNATE;
		trcsetfsm(tp,FSM_A_BLOCK);
		tp->trc_currq = tp->trc_Aq;
		break;
	case CFGMTRF:					/* SING */
		if(rv_error = trcalloc(tp,isize,0))
			goto ret;
		tp->trc_mode = condflg ? MD_SINGLE_COND : MD_SINGLE;
		trcsetfsm(tp,FSM_A_BLOCK);
		tp->trc_currq = tp->trc_Aq;
		break;
	case CFGBTR:
		if(rv_error = trcalloc(tp,0,0))
			goto ret;
		tp->trc_state |= ST_BUS;	/* for trcgen */
		break;
	}
	if(condflg)
		tp->trc_state |= ST_COND;	/* for trcgen */
	tp->trc_channel = tp - trchdr;
	tp->trc_trconcount = 0;
	tp->trc_wrapcount = 0;
	tp->trc_ovfcount  = 0;
ret:
	UNSERIALIZE(tp);
	trc_debug("return from ioctl_systrace(%x,%x) error=%d\n",cmd,arg,rv_error);
	return(rv_error);
}
/* 152616 */
static int buffer_trchook[4];
static int trchkgt_on(int hw /*HKWD_TRACE_TRCON*/,int  a /*getpid()*/,int b /*c_time.tv_sec*/)
{
int i;

	if(trchdr[0].trc_state & ST_COND && !ISEVENT((&trchdr[0]),hw))
                return;

	buffer_trchook[0] = b;
	for ( i = 1 ; i <= 3 ; i++) buffer_trchook[i] = i;
	trcgenasm_on(_TRCTMASK(hw)|HKTY_GT,a,(char *)buffer_trchook,4,&trchdr[0],0);

}
static int trchklt_on(int hw /*HKWD_TRACE_TRCOFF*/,int a /*c_time.tv_sec*/)
{

	if(trchdr[0].trc_state & ST_COND && !ISEVENT((&trchdr[0]),hw))
                return;
	trcgenasm_on(_TRCTMASK(hw)|HKTY_LT,a,(char *)buffer_trchook,0,&trchdr[0],0);
}
/* end  152616 */

static ioctl_systrctl(tp,cmd,arg)
register struct trchdr *tp;
int cmd;			/* ioctl command */
int arg;			/* sometimes-used additional argument */
{
	struct tr_stat tr_stat;
	int rv_error;
	int old_ints;

	trc_debug("ioctl_systrctl(%x,%x,%x)\n",tp,cmd,arg); 

	rv_error = 0;
/* add if a lot of event, the system loop because trclogio doesn't stop */
	if ( cmd == TRCOFF ) {
		SERIAL_BLE((tp - trchdr),old_ints); 
		if(!(tp->trc_state & ST_ISOPEN)) {
			rv_error = ENODEV;
			UNSERIAL_BLE((tp - trchdr),old_ints); 
			goto retsimple;
		}
		if(tp->trc_state & ST_TRCON) {
			curtime(&c_time);
/* 152616 */
/* the routine trchklt_on() allways write the event in the buffer */
			if ( (Trconflag[tp-trchdr] == 1) || (Trconflag[tp-trchdr] == 2) ) {
				trchk_init(tp,0);
				UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchklt_on could call trcbuffullgen */
				trchklt_on(HKWD_TRACE_TRCOFF,c_time.tv_sec);
				LOCKSPIN(&(trc_lock[(tp - trchdr)]));
			}
			else {
				trchklt(HKWD_TRACE_TRCOFF,c_time.tv_sec);
				trchk_init(tp,0);
			}
		}
		else {
			trchk_init(tp,0);
		}
/*  end 152616 */
		UNSERIAL_BLE((tp - trchdr),old_ints); 
	}
	if (cmd == TRCSTAT ) {
		if(!(tp->trc_state & ST_ISOPEN)) {
			rv_error = ENODEV;
			goto retsimple;
		}
		trc_debug("trcioctl: TRCSTAT\n"); 
		tr_stat.trst_mode = tp->trc_mode;
		tr_stat.trst_cmd  = tp->trc_state & ST_TRCON ? TRCON : TRCOFF;
		tr_stat.trst_iactive = tp->trc_state&ST_IACTIVE ? TRUE:FALSE;
		tr_stat.trst_ovfcount = 0;
		if(copyout(&tr_stat,arg,sizeof(struct tr_stat)) == -1)
			rv_error = EINVAL;
		goto retsimple;
	}
	SERIALIZE(tp);
	if(!(tp->trc_state & ST_ISOPEN)) {
		rv_error = ENODEV;
		goto ret;
	}

	switch(cmd) {

	case TRCIOC_CLOSE:
		if((tp->trc_state & (ST_ISOPEN|ST_TRCSTOP)) == (ST_ISOPEN|ST_TRCSTOP)){
			UNSERIALIZE(tp);
			trcclose(channeltomdev(tp-trchdr));
			goto retsimple;
		}
		goto ret;
	case TRCON:
		trc_debug("trcioctl: TRCON state=%x mode=%x\n",
			tp->trc_state,tp->trc_mode);
		switch(tp->trc_mode) {
		case MD_SINGLE:
		case MD_SINGLE_COND:
		case MD_ALTERNATE:
		case MD_ALTERNATE_COND:
		case MD_CIRCULAR:
		case MD_CIRCULAR_COND:
			trcon(tp);
			goto ret;
		case MD_BUS:
			/* initialize trc_bussreg, trc_busaddr */
			/* write start command Dekko card */
			goto ret;
		default:
			rv_error = EINVAL;
			goto ret;
		}
	case TRCOFF:
		trc_debug("trcioctl: TRCOFF\n"); 
		switch(tp->trc_mode) {
		case MD_SINGLE:
		case MD_SINGLE_COND:
		case MD_ALTERNATE:
		case MD_ALTERNATE_COND:
		case MD_CIRCULAR:
		case MD_CIRCULAR_COND:
			trcoff(tp);
			goto ret;
		case MD_BUS:
			trcoff(tp);
			/* write stop command Dekko card */
			goto ret;
		default:
			rv_error = EINVAL;
			goto ret;
		}
	case TRCSTOP:
		trc_debug("trcioctl: TRCSTOP\n"); 
		switch(tp->trc_mode) {
		case MD_SINGLE:
		case MD_SINGLE_COND:
		case MD_ALTERNATE:
		case MD_ALTERNATE_COND:
		case MD_CIRCULAR:
		case MD_CIRCULAR_COND:
			trcstop(tp);
			goto ret;
		case MD_BUS:
			trcstop(tp);
			/* write stop command Dekko card */
			goto ret;
		default:
			rv_error = EINVAL;
			goto ret;
		}
	case TRCSYNC:
		trc_debug("trcioctl: TRCSYNC\n"); 
		UNSERIALIZE(tp);
		trc_sync(tp);
		goto retsimple;
	case UTRCHDR:
		trc_debug("trcioctl: UTRCHDR\n"); 
		rv_error = ioctl_util(cmd,arg);
		goto ret;
	case TRCIACTIVE:
		trc_debug("trcioctl: TRCIACTIVE\n"); 
		tp->trc_state |= ST_IACTIVE;	/* interactive mode */
		goto ret;
#define _CAL5 \
	UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchkgt could call trcbuffullgen */ \
	trchkgt(HKWD_TRACE_CALIB,0x11111111,0x22222222, \
			0x33333333,0x44444444,0x55555555);\
	LOCKSPIN(&(trc_lock[(tp - trchdr)]))

#define _CAL1 \
	UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchklt could call trcbuffullgen */\
	trchklt(HKWD_TRACE_CALIB,0);\
	LOCKSPIN(&(trc_lock[(tp - trchdr)]))
#define _CAL0 \
	UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchkt could call trcbuffullgen */\
	trchkt(HKWD_TRACE_CALIB);\
	LOCKSPIN(&(trc_lock[(tp - trchdr)]))
	case 999:
	  {
		int i;

		trc_debug("trcioctl: 999\n"); 
		SERIAL_BLE((tp - trchdr),i ); 
		for (i = 0; i < 17000; i++)
			_CAL0;
		UNSERIAL_BLE((tp - trchdr),INTBASE); 
		goto ret;
	  }
	case UTRCCALIB:
	  {
		int i;
		trc_debug("trcioctl: UTRCCALIB\n"); 
		SERIAL_BLE((tp - trchdr),i); 
		_CAL1; _CAL1; _CAL1; _CAL1; _CAL1; _CAL1; _CAL1; _CAL1;
		_CAL0; _CAL0; _CAL0; _CAL0; _CAL0; _CAL0; _CAL0; _CAL0;
		_CAL5; _CAL5; _CAL5; _CAL5; _CAL5; _CAL5; _CAL5; _CAL5;
	_CAL0;
	UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchkt could call trcbuffullgen */
	trchkt(0x01000000);
	trchkt(0x01100000);
	trchkt(0x01200000);
	trchkt(0x01300000);
	trchkt(0x01400000);
	trchkt(0x01500000);
	trchkt(0x01600000);
	trchkt(0x01700000);
	trchkt(0x11000000);
	trchkt(0x21100000);
	trchkt(0x31200000);
	trchkt(0x41300000);
	trchkt(0x51400000);
	trchkt(0x61500000);
	trchkt(0x71600000);
	trchkt(0x81700000);
	LOCKSPIN(&(trc_lock[(tp - trchdr)]));
	_CAL0;
		UNSERIAL_BLE((tp - trchdr),INTBASE); 
		goto ret;
	  }
	default:
		rv_error = EINVAL;
		goto ret;
	} /* switch(cmd) */
ret:
	UNSERIALIZE(tp);
retsimple:
	trc_debug("return from ioctl_systrctl(%x,%x) error=%d\n",cmd,arg,rv_error);
	return(rv_error);
}

/*
 * Free the previous trace buffers.
 */
static trcfree(tp)
register struct trchdr *tp;
{

	if(tp->trc_startA)
		jfree(tp->trc_startA);
	if(tp->trc_startB)
		jfree(tp->trc_startB);
	if(tp->trc_lp) {
		xmfree(tp->trc_lp,kernel_heap);
		tp->trc_lp = 0;
	}
	bzero(&tp->trc_Aq,sizeof(tp->trc_Aq));
	bzero(&tp->trc_Bq,sizeof(tp->trc_Bq));
}

/*
 * Allocate pinned new trace buffers of sizes sizeA and sizeB.
 * In practive, sizeB will be equal to sizeA or 0.
 * Note that there is a little "slop" added to the end of the trace buffer
 *  (ALLOCSIZE()) so that a trace event will not have to be divided.
 * Remember to not free a buffer if it is the spill buffer.
 * Also set size=0 buffers to point to the spill buffer.
 */
static trcalloc(tp,isizeA,isizeB)
register struct trchdr *tp;
{
	int *baseA,*baseB;

	trc_debug("trcalloc(%x,%x,%x)\n",tp,isizeA,isizeB); 
	assert(tp->trc_startA == 0);
	assert(tp->trc_startB == 0);
	baseA = 0;
	baseB = 0;
	if(isizeA > 0 && (baseA = jmalloc(ALLOCSIZE(isizeA))) == NULL)
		return(ENOMEM);
	if(isizeB > 0 && (baseB = jmalloc(ALLOCSIZE(isizeB))) == NULL) {
		if(isizeA > 0)
			jfree(baseA);
		return(ENOMEM);
	}
	tp->trc_startA  = baseA;
	tp->trc_endA    = baseA + isizeA;      /* note: (int *), not (char *) */
	tp->trc_inptrA  = tp->trc_startA;
	tp->trc_sizeA   = ALLOCSIZE(isizeA) * sizeof(*tp->trc_inptrA);
	trc_debug("trcalloc: startA=%x endA=%x\n",tp->trc_startA,tp->trc_endA);
	tp->trc_startB  = baseB;
	tp->trc_endB    = baseB + isizeB;      /* note: (int *), not (char *) */
	tp->trc_inptrB  = tp->trc_startB;
	tp->trc_sizeB   = ALLOCSIZE(isizeB) * sizeof(*tp->trc_inptrB);
	tp->trc_currq  = tp->trc_Aq; /* initialize currptr */
	return(0);
}

static trcon(tp)
register struct trchdr *tp;
{
	int oldpri;

	if( (tp->trc_state & ST_TRCSTOP) ||
	    (tp->trc_startA == 0) ||
	   !(tp->trc_state & ST_ISOPEN) )
		return;
	SERIAL_BLE((tp - trchdr),oldpri);  
	trc_debug("trcon: fsm=%d state=%x\n",tp->trc_fsm, tp->trc_state);
/* 152616
	trchk_init(tp,modetotmode(tp->trc_mode));
*/
	if(tp == trchdr && tp->trc_trconcount == 0 && trc_icfunc)
		(*trc_icfunc)();
	tp->trc_trconcount++;
	if(!(tp->trc_state & ST_TRCON)) {
		curtime(&c_time);
/* 152616 */
/* the routine trchkgt_on() allways write the event in the buffer */
		if ( (modetotmode(tp->trc_mode)) == 1 || (modetotmode(tp->trc_mode)== 2) ) {
			UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchkgt_on could call trcbuffullgen */
			trchkgt_on(HKWD_TRACE_TRCON, getpid(),c_time.tv_sec/*,1,2,3*/);
			LOCKSPIN(&(trc_lock[(tp - trchdr)]));
			trchk_init(tp,modetotmode(tp->trc_mode));
		} 
		else {
			trchk_init(tp,modetotmode(tp->trc_mode));
                	trchkgt(HKWD_TRACE_TRCON, getpid(),c_time.tv_sec,1,2,3);
		}
/* end 152616 */

#define HKWD_TRACE_UTIL_TIME		0x00A00020

		UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* TRCHKGT could call trcbuffullgen */
                TRCHKGT(HKWD_TRACE_UTIL_TIME, NULL, NULL, NULL, NULL, NULL);
                TRCHKGT(HKWD_TRACE_UTIL_TIME, NULL, NULL, NULL, NULL, NULL);
                TRCHKGT(HKWD_TRACE_UTIL_TIME, NULL, NULL, NULL, NULL, NULL);
		LOCKSPIN(&(trc_lock[(tp - trchdr)]));
	}
/* 152616 */
	else {
		trchk_init(tp,modetotmode(tp->trc_mode));
	}
/* end 152616 */
	trc_timeout(0); 
	tp->trc_state |= ST_TRCON;
	UNSERIAL_BLE((tp - trchdr),oldpri);  
}

static trcoff(tp)
register struct trchdr *tp;
{
	int oldpri;

	SERIAL_BLE((tp - trchdr),oldpri); 
	trc_debug("trcoff: fsm=%d state=%x\n",tp->trc_fsm, tp->trc_state);
	if(tp->trc_state & ST_TRCON) {
		curtime(&c_time);
/* 152616 */
/* the routine trchklt_on() allways write the event in the buffer */
		if ( (Trconflag[tp-trchdr] == 1) || (Trconflag[tp-trchdr] == 2) ) {
			trchk_init(tp,0);
			UNLOCKSPIN(&(trc_lock[(tp - trchdr)])); /* trchklt_on could call trcbuffullgen */
			trchklt_on(HKWD_TRACE_TRCOFF,c_time.tv_sec);
			LOCKSPIN(&(trc_lock[(tp - trchdr)]));
		}
		else {
			trchklt(HKWD_TRACE_TRCOFF,c_time.tv_sec);
			trchk_init(tp,0);
		}
	}
	else {
		trchk_init(tp,0);
	}
/*  end 152616 */
	tp->trc_state &= ~ST_TRCON;
	UNSERIAL_BLE((tp - trchdr),oldpri); 
}

static trcstop(tp)
register struct trchdr *tp;
{
	int rv_error;
	int oldpri;

	trc_debug("trcstop: fsm=%d state=%x\n",tp->trc_fsm, tp->trc_state);
	rv_error = 0;
	SERIAL_BLE((tp - trchdr),oldpri); 
	switch(tp->trc_mode) {
	case MD_CIRCULAR:
	case MD_CIRCULAR_COND:
		switch(tp->trc_fsm) {
		case FSM_A_BLOCK: trcstop2(tp,&tp->trc_Aq,FSM_SPILL_B_OFF, 1,&oldpri); break;
		case FSM_B_BLOCK: trcstop2(tp,&tp->trc_Bq,FSM_SPILL_A_OFF2,1,&oldpri); break;
		}
		goto ret;
	case MD_ALTERNATE:
	case MD_ALTERNATE_COND:
		switch(tp->trc_fsm) {
		case FSM_A_B:     trcstop2(tp,&tp->trc_Aq,FSM_SPILL_B_OFF, 0,&oldpri); break;
		case FSM_SPILL_B: trcstop2(tp,0,          FSM_SPILL_B_OFF, 0,&oldpri); break;
		case FSM_B_A:     trcstop2(tp,&tp->trc_Bq,FSM_SPILL_A_OFF2,0,&oldpri); break;
		case FSM_SPILL_A: trcstop2(tp,0,          FSM_SPILL_A_OFF2,0,&oldpri); break;
		case FSM_B_BLOCK: trcstop2(tp,&tp->trc_Bq,FSM_SPILL_B_OFF2,1,&oldpri); break;
		case FSM_A_BLOCK: trcstop2(tp,&tp->trc_Aq,FSM_SPILL_A_OFF, 1,&oldpri); break;
		}
		goto ret;
	case MD_SINGLE:
	case MD_SINGLE_COND:
		switch(tp->trc_fsm) {
		case FSM_A_BLOCK: trcstop2(tp,&tp->trc_Aq,FSM_SPILL_A_OFF,1,&oldpri);   break;
		}
		goto ret;
	case MD_BUS:
	case MD_BUS_COND:
		goto ret;
	default:
		rv_error = EINVAL;
		goto ret;
	}
ret:
	if(rv_error == 0) {
		tp->trc_state |= ST_TRCSTOP;
		switch(tp->trc_fsm) {
		case FSM_SPILL_BLOCK:
			trcsetfsm(tp,FSM_SPILL_EOF);
			trc_wakeup(tp);
		}
	}
	UNSERIAL_BLE((tp - trchdr),oldpri); 
	return(rv_error);
}

static trcstop2(tp,qp,fsm,wakeupflg,oldpri)
register struct trchdr *tp;
struct trc_q *qp;
int *oldpri;
{

	UNSERIAL_BLE((tp - trchdr),*oldpri); 
	trcoff(tp);
	SERIAL_BLE((tp - trchdr),*oldpri); 
	trcsetfsm(tp,fsm);
	if(qp)
		qp->q_inptr = tp->trc_inptr;
	if(wakeupflg)
		trc_wakeup(tp);
}

static modetotmode(mode)
{
	int m;

	switch(mode) {
	case MD_OFF:
		m = 0; break;
	case MD_BUS:
		m = 3; break;
	case MD_CIRCULAR:
	case MD_ALTERNATE:
	case MD_SINGLE:
		m = 1; break;
	case MD_CIRCULAR_COND:
	case MD_ALTERNATE_COND:
	case MD_SINGLE_COND:
		m = 2; break;
	default:
		m = 0; break;
	}
	return(m);
}

static minortomdev(mmdev)
{
	int mdev;
	int n;

	mdev = minor(mmdev);
	switch(mdev) {
	case MDEV_SYSTRACE:
	case MDEV_SYSTRACE1:
	case MDEV_SYSTRACE2:
	case MDEV_SYSTRACE3:
	case MDEV_SYSTRACE4:
	case MDEV_SYSTRACE5:
	case MDEV_SYSTRACE6:
	case MDEV_SYSTRACE7:
		n = MDEV_SYSTRACE; break;
	case MDEV_SYSTRCTL:
	case MDEV_SYSTRCTL1:
	case MDEV_SYSTRCTL2:
	case MDEV_SYSTRCTL3:
	case MDEV_SYSTRCTL4:
	case MDEV_SYSTRCTL5:
	case MDEV_SYSTRCTL6:
	case MDEV_SYSTRCTL7:
		n = MDEV_SYSTRCTL; break;
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
	case MDEV_SYSMEM:
		n = mdev; break;
	default:
		Jprintf("minortomdev: unknown minor device %d\n",mdev);
		return(-1);
	}
	return(n);
}

/* Calculate the in-use channel */
static channeltomdev(chan)
{

	switch(chan) {
	case 0: return(MDEV_SYSTRACE);
	case 1: return(MDEV_SYSTRACE1);
	case 2: return(MDEV_SYSTRACE2);
	case 3: return(MDEV_SYSTRACE3);
	case 4: return(MDEV_SYSTRACE4);
	case 5: return(MDEV_SYSTRACE5);
	case 6: return(MDEV_SYSTRACE6);
	case 7: return(MDEV_SYSTRACE7);
	}
	return(MDEV_SYSTRACE);
}

/* Calculate open_count index corresponding to the in-use channel */
static minortoarray(mmdev)
{
	int mdev;
	int n;

	mdev = minor(mmdev);
	switch(mdev) {
	case MDEV_SYSTRCTL:
	case MDEV_SYSTRACE:
		n = 0; break;
	case MDEV_SYSTRCTL1:
	case MDEV_SYSTRACE1:
		n = 1; break;
	case MDEV_SYSTRCTL2:
	case MDEV_SYSTRACE2:
		n = 2; break;
	case MDEV_SYSTRCTL3:
	case MDEV_SYSTRACE3:
		n = 3; break;
	case MDEV_SYSTRCTL4:
	case MDEV_SYSTRACE4:
		n = 4; break;
	case MDEV_SYSTRCTL5:
	case MDEV_SYSTRACE5:
		n = 5; break;
	case MDEV_SYSTRCTL6:
	case MDEV_SYSTRACE6:
		n = 6; break;
	case MDEV_SYSTRCTL7:
	case MDEV_SYSTRACE7:
		n = 7; break;
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
	case MDEV_SYSMEM:
		n = 0; break;
	default:
		Jprintf("minortoarray: unknown minor device %d\n",mdev);
		return(-1);
	}
	return(n);
}

/* Calculate trchdr corresponding to the in-use channel */
static struct trchdr *minortotp(mmdev)
{
	int mdev;
	int n;

	mdev = minor(mmdev);
	switch(mdev) {
	case MDEV_SYSTRCTL:
	case MDEV_SYSTRACE:
		n = 0; break;
	case MDEV_SYSTRCTL1:
	case MDEV_SYSTRACE1:
		n = 1; break;
	case MDEV_SYSTRCTL2:
	case MDEV_SYSTRACE2:
		n = 2; break;
	case MDEV_SYSTRCTL3:
	case MDEV_SYSTRACE3:
		n = 3; break;
	case MDEV_SYSTRCTL4:
	case MDEV_SYSTRACE4:
		n = 4; break;
	case MDEV_SYSTRCTL5:
	case MDEV_SYSTRACE5:
		n = 5; break;
	case MDEV_SYSTRCTL6:
	case MDEV_SYSTRACE6:
		n = 6; break;
	case MDEV_SYSTRCTL7:
	case MDEV_SYSTRACE7:
		n = 7; break;
	case MDEV_SYSNULL:
	case MDEV_SYSUTIL:
	case MDEV_SYSMEM:
		n = 0; break;
	default:
		Jprintf("minortotp: unknown minor device %d\n",mdev);
		return(0);
	}
	return(&trchdr[n]);
}

/*
 * jmalloc() returns an integer pointer to 'size words'
 * jfree()   frees the area that was allocated by jmalloc().
 */

static int *jmalloc(isize)
{
	int *ptr;
	int bsize;

	bsize = isize * sizeof(int);
	ptr = (int *)xmalloc(bsize,2,pinned_heap);
	return(ptr);
}

static jfree(ptr)
int *ptr;
{

	xmfree(ptr,pinned_heap);
}

struct snapdata {
	char *sn_base;
	int sn_bsize;
	int sn_idx;
	int sn_wrapcount;
};
/*static*/ struct snapdata jsnapdata;
/*static*/ char jsnapflg = 0;
/*static*/ char jprintflg = 0;

#ifdef DEBUG
/*
 * Jprintf is a conditional call to printf or jsnap
 * jsnap is an sprintf to a revolving buffer.
 *    It is more effective when you can dump memory contents to a floppy
 *    after a crash.
 */

Jprintf(s,a,b,c,d,e,f,g)
{

#ifdef DEBUG
	if(trc_printflg)
		printf(s,a,b,c,d,e,f,g);
#endif
		printf(s,a,b,c,d,e,f,g);
	jsnap(s,a,b,c,d,e,f,g);
}

/*VARARGS*/
jsnap(fmt,a,b,c,d,e,f,g)
{
	static sncount;
	int s;

	if(!jsnapflg)
		return;
	if(jsnapdata.sn_bsize == 0)
		return;
	s = INT_OFF();
	sncount++;
	jsnap2("%d: ",sncount);
	jsnap2(fmt,a,b,c,d,e,f,g);
	if(jprintflg)
		printf(fmt,a,b,c,d,e,f,g);
	INT_ONX(s);
}

/*VARARGS*/
static jsnap2(fmt,a)
{
	int count;

#ifdef DEBUG
	count = jdoprnt(&jsnapdata.sn_base[jsnapdata.sn_idx],fmt,&a);
	jsnapdata.sn_idx += count;
	jsnapdata.sn_base[jsnapdata.sn_idx] = 0xF1;
	if(jsnapdata.sn_idx > jsnapdata.sn_bsize) {
		jsnapdata.sn_wrapcount++;
		jsnapdata.sn_idx = 0;
		jsnap("WRAPAROUND %d\n",jsnapdata.sn_wrapcount);
	}
#endif
}

#define JSNAPISIZE 8000
int jsnapisize = JSNAPISIZE;

static jsnapinit()
{
	char *snapbuf;
	int isize;

	isize = ALLOCSIZE(jsnapisize);
	if(jsnapdata.sn_bsize > 0)
		return;
	if((snapbuf = (char *)jmalloc(isize)) == 0)
		return;
	jsnapdata.sn_bsize = jsnapisize * sizeof(int);
	jsnapdata.sn_idx   = 0;
	jsnapdata.sn_base  = snapbuf;
}

static qtrace(qp,str)
register struct trc_q *qp;
{

	trc_debug("%s: %x\n",str,qp);
	trc_debug("  start=%x end=%x i=%x\n",qp->q_start,qp->q_end,qp->q_inptr);
}


#endif	/* DEBUG */
/*
 * utilities that initiate special kernel functions
 */
static ioctl_util(cmd,arg)
{
	char buf[128];

	trc_debug("ioctl_util(%x,%x)\n",cmd,arg); 
	switch(cmd) {
#ifdef DEBUG
	case UTRCSNAPCTL:
 		if(ras_privchk() < 0)
 			return(EACCES);
		switch(arg) {
		case 0:
			jsnapflg = 0;
			break;
		case 1:
			if(jsnapflg) {
				int jsnapflgsv;

				jsnapflgsv = jsnapflg;
				jsnapflg = 0;
				Jprintf("Snap is now %x\n",jsnapflg+1);
				jsnapflg = jsnapflgsv + 1;
			} else {
				if(jsnapdata.sn_base) {
					bzero(jsnapdata.sn_base,jsnapdata.sn_bsize);
					jsnapdata.sn_idx = 0;
					jsnapdata.sn_wrapcount = 0;
				}
				jsnapflg = 1;
			}
			break;
		case 2:
			jsnapdata.sn_idx = 0;
			break;
		}
		return(0);
	case UTRCSNAPINFO:
		if(copyout(&jsnapdata,arg,sizeof(jsnapdata)) != 0)
			return(EFAULT);
		return(0);
#ifdef DEBUG
	case UTRCPANIC:
 		if(ras_privchk() < 0)
 			return(EACCES);
		panic("forced panic");
#endif
	case UTRCPRINT:
 		if(ras_privchk() < 0)
 			return(EACCES);
		if(copyin(arg,buf,sizeof(buf)) != 0)
			return(EFAULT);
		buf[sizeof(buf)-1] = '\0';
		Jprintf("%s\n",buf);
		return(0);
	case UTRCHDR:
		if(arg && copyout(&trchdr[0],arg,sizeof(trchdr[0])))
			return(EFAULT);
		return(0);
#endif	/* DEBUG */
	default:
		return(EINVAL);
	}
}

#ifndef DEBUG

trcsetfsm(tp,fsm)
register struct trchdr *tp;
{

	trc_debug("trcsetfsm: from %d to %d\n", tp->trc_fsm,fsm);
	tp->trc_fsm = fsm;
	mem_sync();
}

#else

trcsetfsm(tp,fsm)
register struct trchdr *tp;
{

	trc_debug("trcsetfsm: from %d to %d\n", tp->trc_fsm,fsm);
	jf_check(tp,fsm);
	tp->trc_fsm = fsm;
	mem_sync();
}

struct fc {
	int jf_curr;
	int jf_next;
};

static struct fc fc_circ[] = {
	{ 0                 ,     FSM_SPILL_BLOCK },
	{ 0                 ,     FSM_A_BLOCK },
	{ FSM_A_BLOCK       ,     FSM_B_BLOCK },
	{ FSM_A_BLOCK       ,     FSM_SPILL_B_OFF },
	{ FSM_B_BLOCK       ,     FSM_A_BLOCK },
	{ FSM_B_BLOCK       ,     FSM_SPILL_A_OFF2 },
	{ FSM_SPILL_B_OFF   ,     FSM_SPILL_A_OFF },
	{ FSM_SPILL_A_OFF2  ,     FSM_SPILL_B_OFF2 },
	{ FSM_SPILL_A_OFF   ,     FSM_SPILL_BLOCK },
	{ FSM_SPILL_B_OFF2  ,     FSM_SPILL_BLOCK },
	{ FSM_SPILL_BLOCK   ,     FSM_A_BLOCK },
	{ FSM_SPILL_BLOCK   ,     FSM_SPILL_EOF },
	{-1 -1}
};

static struct fc fc_sing[] = {
	{ 0                 ,     FSM_SPILL_BLOCK },
	{ 0                 ,     FSM_A_BLOCK },
	{ FSM_A_BLOCK       ,     FSM_SPILL_A },
	{ FSM_A_BLOCK       ,     FSM_SPILL_A_OFF },
	{ FSM_SPILL_A       ,     FSM_SPILL_EOF },
	{ FSM_SPILL_A_OFF   ,     FSM_SPILL_BLOCK },
	{ FSM_SPILL_BLOCK   ,     FSM_A_BLOCK },
	{ FSM_SPILL_BLOCK   ,     FSM_SPILL_EOF },
	{-1 -1}
};

static struct fc fc_alt[] = {
	{ 0                 ,     FSM_SPILL_BLOCK },
	{ 0                 ,     FSM_A_BLOCK },
	{ FSM_A_B           ,     FSM_A_BLOCK },
	{ FSM_A_B           ,     FSM_SPILL_B },
	{ FSM_A_B           ,     FSM_SPILL_B_OFF },
	{ FSM_A_BLOCK       ,     FSM_B_A },
	{ FSM_A_BLOCK       ,     FSM_SPILL_A_OFF },
	{ FSM_SPILL_B       ,     FSM_B_A },
	{ FSM_SPILL_B       ,     FSM_SPILL_B_OFF },
	{ FSM_B_A           ,     FSM_B_BLOCK },
	{ FSM_B_A           ,     FSM_SPILL_A },
	{ FSM_B_A           ,     FSM_SPILL_A_OFF2 },
	{ FSM_B_BLOCK       ,     FSM_A_B },
	{ FSM_B_BLOCK       ,     FSM_SPILL_B_OFF2 },
	{ FSM_SPILL_A       ,     FSM_A_B },
	{ FSM_SPILL_A       ,     FSM_SPILL_A_OFF2 },
	{ FSM_SPILL_B_OFF   ,     FSM_A_B },
	{ FSM_SPILL_B_OFF   ,     FSM_SPILL_A_OFF },
	{ FSM_SPILL_A_OFF   ,     FSM_B_A },
	{ FSM_SPILL_A_OFF   ,     FSM_SPILL_BLOCK },
	{ FSM_SPILL_A_OFF2  ,     FSM_B_A },
	{ FSM_SPILL_A_OFF2  ,     FSM_SPILL_B_OFF2 },
	{ FSM_SPILL_B_OFF2  ,     FSM_A_B },
	{ FSM_SPILL_B_OFF2  ,     FSM_SPILL_BLOCK },
	{ FSM_SPILL_BLOCK   ,     FSM_A_B },
	{ FSM_SPILL_BLOCK   ,     FSM_SPILL_EOF },
	{-1,-1}
};

static jf_check(tp,fsm)
struct trchdr *tp;
{

	if(fsm == 0)
		return;
	switch(tp->trc_mode) {
	case MD_CIRCULAR:
	case MD_CIRCULAR_COND:
		jf_check2(fc_circ,tp->trc_fsm,fsm);
		return;
	case MD_ALTERNATE:
	case MD_ALTERNATE_COND:
		jf_check2(fc_alt,tp->trc_fsm,fsm);
		return;
	case MD_SINGLE:
	case MD_SINGLE_COND:
		jf_check2(fc_sing,tp->trc_fsm,fsm);
		return;
	}
	return;
}

static jf_check2(fp,currfsm,nextfsm)
struct fc *fp;
{

	while(fp->jf_curr != -1) {
		if(fp->jf_curr == currfsm && fp->jf_next == nextfsm)
			return;
		fp++;
	}
	Jprintf("jf_check2: %d %d\n",currfsm,nextfsm);
	assert(fp == 0);
}
#endif

/*
 * trccdtf()
 * Called by dmp_do at dump time.
 * Return a pointer to a component dump table (cdt).
 * The cdt for trace is
 *   trchdr0
 *   tracebuffer0A
 *   tracebuffer0B
 *     ...
 *   trchdr7
 *   tracebuffer7A
 *   tracebuffer7B
 * If trace is not on for the channel, it is not dumped.
 */

static struct {
	struct cdt_head  _cdt_head;
	struct cdt_entry  cdt_entry[4*TRC_NCHANNELS];	/* trchdr + buffer */
} trccdt;

static struct trctyp trctyp[TRC_NCHANNELS];

#define VCPY(s1,s2) strncpy(s1,s2,sizeof(s1))

struct cdt_head *trccdtf()
{
	register i;
	register struct trchdr *tp;
	register struct cdt_entry *cep;

	trc_debug("trcdtf\n"); 
	bzero(trctyp,sizeof(trctyp));
	/*
	 * fill in cdt header (_cdt_head)
	 */
	trccdt.cdt_magic = DMP_MAGIC;
	VCPY(trccdt.cdt_name,"trace");

	/*
	 * fill in cdt entries
	 */
	cep = &trccdt.cdt_entry[0];
	for(i = 0; i < TRC_NCHANNELS; i++) {
		tp = &trchdr[i];
		if(tp->trc_mode == 0)
			continue;
		if(tp->trc_endA == tp->trc_end) {
			tp->trc_inptrA == tp->trc_inptr;
			trctyp[i].t_type = TRCT_A;
		}
		if(tp->trc_endB == tp->trc_end) {
			tp->trc_inptrB == tp->trc_inptr;
			trctyp[i].t_type = TRCT_B;
		}
		VCPY(cep->d_name,"trchdr_");
		cep->d_name[7] = '0' + i;
		cep->d_ptr = (char *)tp;
		cep->d_len = sizeof(*tp);
		cep++;
		VCPY(cep->d_name,"trctyp_");
		cep->d_name[7] = '0' + i;
		cep->d_ptr = (char *)&trctyp[i];
		cep->d_len = sizeof(trctyp[i]);
		cep++;
		if(tp->trc_startA) {
			VCPY(cep->d_name,"bufferA");
			cep->d_name[7] = '0' + i;
			cep->d_ptr = (char *)tp->trc_startA;
			cep->d_len = trctyp[i].t_type == TRCT_A ?
				(char *)tp->trc_inptr  - (char *)tp->trc_start :
				(char *)tp->trc_inptrA - (char *)tp->trc_startA;
			cep++;
		}
		if(tp->trc_startB) {
			VCPY(cep->d_name,"bufferB");
			cep->d_name[7] = '0' + i;
			cep->d_ptr = (char *)tp->trc_startB;
			cep->d_len = trctyp[i].t_type == TRCT_B ?
				(char *)tp->trc_inptr  - (char *)tp->trc_start :
				(char *)tp->trc_inptrB - (char *)tp->trc_startB;
			cep++;
		}
	}
	trccdt.cdt_len = sizeof(struct cdt_head) +
		(cep-&trccdt.cdt_entry[0]) * sizeof(struct cdt_entry);
	return((struct cdt_head *)&trccdt);
}

#include <sys/xcoff.h>
#include <sys/ldr/ld_data.h>

/*
 * Make sure this not be merged in next freeze; this struct is declared in
 * in trchdr.h
 */

static trc_loader(arg)
struct wtrc_lv *arg; 
{
	int count;
	struct loader_entry *ep;
	struct wtrc_lv lv; 
	char *fname, *froot = NULL;

	trc_debug("trc_loader(%x)\n",arg); 
	count = 0;
	SER_KL(kernel_anchor.la_lock);
	for(ep = kernel_anchor.la_loadlist; ep; ep = ep->le_next) {
		if((ep->le_filesize == 0) && (ep->le_flags == 0))
			continue;
		froot = NULL;
		lv.lv_start   = ep->le_file;
		lv.lv_size    = ep->le_filesize;
		lv.lv_flags   = ep->le_flags; 
		bcopy(ep->le_filename, lv.lv_fullname, sizeof(lv.lv_fullname)); 
		lv.lv_name[0] = '\0';
 		if(ep->le_filename){
		    fname = (*ep).le_filename;
		    do {
			if (*fname == '/')
			    froot = fname + 1;
		    } while (*++fname);
		    if (NULL == froot)
			bcopy(ep->le_filename, lv.lv_name, sizeof(lv.lv_name));
		    else
			bcopy(froot, lv.lv_name, sizeof(lv.lv_name));
 		}
		if (!lv.lv_fullname[0] && !lv.lv_name[0] ) {
			bcopy("/unix", lv.lv_fullname, sizeof(lv.lv_fullname));
			bcopy("unix", lv.lv_name, sizeof(lv.lv_name));
		}
 
		if(copyout(&lv,arg,sizeof(lv))) {
			UNSER_KL(kernel_anchor.la_lock);
			return(EINVAL);
			}
		arg++;
		if(++count >= TRC_NLV)
			break;
	}
	UNSER_KL(kernel_anchor.la_lock);

	return(0);
}

static ras_privchk()
{

	if(trc_privflg == 0 || privcheck(RAS_CONFIG) == 0)
		return(0);
	return(-1);
}

trc_trcoff()
{
	int rv;
	register struct trchdr *tp=&trchdr[0];

	rv = tp->trc_state & ST_TRCON;
	trcoff(tp);

	return(rv);
}

trc_trcon()
{
	register struct trchdr *tp=&trchdr[0];

	trcon(tp);

}

#ifdef DEBUG

static char *jdonum();
static char *jdostring();

static jdoprnt(buf,fmt,vargp)
char *buf;
char *fmt;
int *vargp;
{
	register char *bufp;
	register c;
	register int *vp;
	register char *cp;

	bufp = buf;
	cp = fmt;
	vp = vargp;
	for(;;) {
		c = *cp++;
		switch(c) {
		case '\0':
			break;
		case '%':
			c = *cp++;
			switch(c) {
			case 's': bufp = jdostring(bufp,*vp++); break;
			case 'x': bufp = jdonum(bufp,*vp++,1);  break;
			case 'd': bufp = jdonum(bufp,*vp++,0);  break;
			default:  *bufp++ = c;                  break;
			}
			continue;
		default:
			*bufp++ = c;
			continue;
		}
		break;
	}
	*bufp = '\0';
	return(bufp-buf);
}

#define HTOA(c) ( (c) >= 0x0a ? (c) - 0x0a + 'a' : (c) + '0' )

static char *jdonum(buf,n,hexflg)
unsigned n;
char *buf;
{
	int i;
	int zflg;
	int negflg;
	int dig;
	int ndig;
	int base;
	unsigned int mask;
	char *bufp;

	bufp = buf;
	zflg = 0;
	negflg = 0;
	ndig = hexflg ?  8 : 10;
	base = hexflg ? 16 : 10;
	mask = hexflg ? 0x10000000 : 1000000000;
	if(!hexflg && n >= 0x80000000) {
		n = (unsigned) (-((int)n));
		negflg++;
	}
		
	if(n == 0) {
		*bufp++ = HTOA(0);
	} else {
		for(i = 0; i < ndig; i++) {
			dig = n / mask % base;
			mask /= base;
			if(dig || zflg) {
				if(zflg == 0 && negflg)
					*bufp++ = '-';
				*bufp++ = HTOA(dig);
			}
			if(dig)
				zflg++;
		}
	}
	*bufp = '\0';
	return(bufp);
}

static char *jdostring(buf,str)
char *buf;
char *str;
{
	char *bufp;

	bufp = buf;
	while(*bufp = *str++)
		bufp++;
	*bufp = '\0';
	return(bufp);
}

#endif

static trc_sync(tp)
struct trchdr *tp;
{
	int pri;

	SERIAL_BLE((tp - trchdr),pri); 
	trc_debug("trc_sync(%x)\n",tp); 
	if((tp->trc_state & (ST_ISOPEN|ST_SYNC)) == ST_ISOPEN) {
		jsnap("trc_sync(%x) %x\n",tp,&trc_syncword[tp->trc_channel]);
		tp->trc_state |= ST_SYNC;
		trc_syncword[tp->trc_channel] = EVENT_NULL;
#ifdef _POWER_MP
		e_assert_wait(&trc_syncword[tp->trc_channel],INTERRUPTIBLE);
		UNLOCKSPIN(&(trc_lock[tp-trchdr]))
		e_block_thread();
		i_enable(pri);
#else
		e_sleep(&trc_syncword[tp->trc_channel],EVENT_SIGRET);
		UNSERIAL_BLE((tp - trchdr),pri); 
#endif
		jsnap("return from trc_sync\n");
	}
	else 
		UNSERIAL_BLE((tp - trchdr),pri); 
}

static trc_syncchk(tp)
struct trchdr *tp;
{

	jsnap("trc_syncchk(%x)\n",tp);
	if(tp->trc_state & ST_SYNC) {
		tp->trc_state &= ~ST_SYNC;
		jsnap("trc_syncchk: wakeup %x\n",&trc_syncword[tp->trc_channel]);
		e_wakeup(&trc_syncword[tp->trc_channel]);
	}
}

#ifndef _POWER_MP 
static void
serialize(lock_t *lock)
{
	lockl_rc = lockl(lock,LOCK_SHORT);
}
static void
unserialize(lock_t *lock)
{
	if (lockl_rc != LOCK_FAIL)
		unlockl(lock);
}
#endif 
