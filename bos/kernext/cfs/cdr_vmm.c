static char sccsid[] = "@(#)08	1.15  src/bos/kernext/cfs/cdr_vmm.c, sysxcfs, bos411, 9428A410j 5/6/94 12:14:18";
/*
 * COMPONENT_NAME: (SYSXCFS) CDROM File System
 *
 * FUNCTIONS: CDRFS pager 
 *
 * ORIGINS: 27
 *
 * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 * combined with the aggregated modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp. 1989
 * All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

#include <sys/types.h>
#include <sys/errno.h>
#include <sys/user.h>
#include <sys/uio.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/sleep.h>
#include <sys/param.h>
#include <sys/syspest.h>
#include <sys/m_except.h>
#include <sys/lock_def.h>
#include <sys/lock_alloc.h>
#include <sys/lockname.h>

/* CD-ROM file system includes */
#include "cdr_xcdr.h"
#include "cdr_rrg.h"
#include "cdr_cdrfs.h"
#include "cdr_cdrnode.h"

#define	DELAYTIME	HZ	/* one second delay */

/* buf_list is the list of buffers generated by page faults.
 * cdr_strategy() places the buffers on the list and the kernel process
 * running cdr_pager() removes them from the list, translates them and
 * hands them to the device driver strategy routine.
 */
struct buf *	buf_list = NULL;

/* sleep_list is the list for the kernel process to sleep on, waiting
 * for access to the list of page fault buffers	
 */
int 		sleep_list = EVENT_NULL;

/* The cdrpager_lock is used for strategy routine/pager serialization.
 * The strategy routine is called at interrupt level, and the pager
 * must disable and enable in addition to locking.
 */
Simple_lock	cdrpager_lock;

/* forward references */
static void process_buflist (struct buf **	bp);
void cdrfs_iodone(struct buf *bp);

/*
 *	cdr_strategy
 *
 * called by page fault handler as device strategy routine
 */
int
cdr_strategy (struct buf *	bufp)
{
	int			rc;
	int			ipri;

	ASSERT(bufp->av_forw == NULL || bufp->av_forw->b_vp != NULL);

	/* start critical section */
	ipri = disable_lock(INTPAGER, &cdrpager_lock);
			
	bufp->av_back = buf_list;
	buf_list = bufp;

	/* end critical section */
	unlock_enable(ipri, &cdrpager_lock);

	e_wakeup(&sleep_list);

	return 0;
}

/*
 *	cdr_pager
 *
 * CDRFS pager daemon
 */
void
cdr_pager (void)
{
	struct buf *	bp;
	int		ipri;
	int		rc;

	/* Make cdr pager kproc a child of the INIT process.
	 */
	setpinit();

	/* Allocate and initialize the strategy/pager lock */
	lock_alloc(&cdrpager_lock,LOCK_ALLOC_PIN,CDRPAGER_LOCK_CLASS,-1);
	simple_lock_init(&cdrpager_lock);

	/* Start the critical section.  There are two critical sections
	 * in this code.  The buffers must be removed from the list
	 * atomically because they are being added by cdr_strategy, disabled
	 * to INT_PAGER.  Also, the check for an empty list and the sleep
	 * of the kproc must be done atomically so that wakeup is not
	 * called after we have made the decision to sleep but before we
	 * are actually asleep.
	 */
	ipri = disable_lock(INTPAGER, &cdrpager_lock);
			
	while (TRUE)
	{
		/* check buffer list for termination.
		 */
		if (buf_list == -1)
			break;

		while (buf_list != NULL)
		{
			/* get buf from buffer list */
			bp = buf_list;
			buf_list = bp->av_back;

			/*
		 	 * start un-critical section
			 */
			unlock_enable(ipri, &cdrpager_lock);

			process_buflist(&bp);

			devstrat(bp);

			/*
			 * end un-critical section
			 */
			ipri = disable_lock(INTPAGER, &cdrpager_lock);
		}
		e_sleep_thread(&sleep_list, &cdrpager_lock, LOCK_HANDLER);
	}

	/* end critical section */
	unlock_enable(ipri, &cdrpager_lock);
}

/*
 *	process_buflist()
 *
 * page fault handler initialization of struct buf for pagein of a
 * client segment (paging device type = D_REMOTE):
 *  b_iodone = v_pfend
 *  b_vp = pointer to vnode of the object
 *  b_blkno = (PAGESIZE/512) * page number of the page fault,
 *	      i.e., object physical block number (of pblksize = 512),
 *	      at the PAGESIZE boundary
 *  b_bcount = PAGESIZE
 *  b_xmemd.subspace_id = SR value of sid of the object
 *  b_baddr = b_un.b_addr = page offset
 *
 * b_blkno and b_bcount are converted into disk block number and
 * actual number of physical blocks to read for a page.
 *
 * only non-last extent size of multiple of page size are supported
 * for multi-extent file.
 *
 * N.B. b_vp field is pirated to intercept cdrdd exception
 *
 * serialization: This function called by the pager is serialized by
 * 		  the cdrpager_lock.
 *
 */
static
void
process_buflist(struct buf **	bpp)
{
	int			rc;		/* return code		*/
	struct cdrfsmount	*cdrfsp; /* mounted file system data */
	struct cdrnode *	cdrp;		/* cdrnode for file	*/
	struct buf *		tbufp;		/* temp buf ptr in list	*/
	daddr_t			blkoffset;	/* off to blk in file	*/
	daddr_t			blkend;		/* off to blk in extent	*/
	daddr_t			pblkno;		/* disk physical blkno	*/
	int			bcount;		/* disk physical blkcnt */
	int			extno;		/* file extent number	*/
	struct cdrxd		*xdp;		/* extend descriptor	*/
	caddr_t			block;		/* address of page data	*/
	struct buf *		backbp;		/* back ptr in buf list	*/
	struct buf *		delbufp;	/* buffer to delete	*/
	struct buf *		badbufp;	/* buffer to error on	*/
	int			lblkmask;	/* logical block mask */
	void 			cdrfs_iodone();	/* cdrfs iodone() */

	backbp = NULL;
	for (tbufp = *bpp; tbufp != NULL; ) {
		ASSERT(tbufp->b_vp != NULL);

		/* get relevant fields from tbufp struct */
		cdrp = GTOCDRP((struct gnode *)tbufp->b_vp);
		cdrfsp = cdrp->cn_cdrfs;

		/* check for read from forced unmounted filesystem */
		if (cdrp->cn_dev == 0xdeadbeef) {
			tbufp->b_resid = tbufp->b_bcount;
			tbufp->b_error = ESTALE;
			tbufp->b_flags |= B_ERROR;

			/* remove buffer from list, advance tbuf to
			 * next buffer
			 */
			if (backbp) {
				backbp->av_forw = tbufp->av_forw;
				badbufp = tbufp;
				tbufp = backbp->av_forw;
			} else {
				*bpp = tbufp->av_forw;
				badbufp = tbufp;
				tbufp = *bpp;
			}

			iodone(badbufp);

			continue;	/* get next buffer request */
		}

		/* object physical block number of page to read */
		blkoffset = tbufp->b_blkno;

		/* check for beyond EOF read:
		 * call iodone() for block without pagein
		 */
		if (blkoffset > PBLKNO(cdrp->cn_size - 1)) {
			/* if the VMM is asking about end of file under 
			 * mmap(), mark buffer for SIGBUS signal
		 	 */
			if (tbufp->b_flags & B_PFEOF) {
				tbufp->b_error = EXCEPT_EOF;
				tbufp->b_flags |= B_ERROR;
			} else {
				/* zero out the page */
				block = vm_att(tbufp->b_xmemd.subspace_id,
					       tbufp->b_baddr);
				bzero(block, tbufp->b_bcount);
				(void)vm_det(block);
			}

			/* remove buffer from list, advance tbuf to next buffer
			 */
			if (backbp) {
				backbp->av_forw = tbufp->av_forw;
				delbufp = tbufp;
				tbufp = backbp->av_forw;
			} else {
				*bpp = tbufp->av_forw;
				delbufp = tbufp;
				tbufp = *bpp;
			}

			iodone(delbufp);

			continue;	/* get next buffer request */
		}
		
		/* scan the extent descriptor list to find the extent 
		 * containing the block
		 */
		extno = 0;
		xdp = &cdrp->cn_xd[0];
		while (TRUE) {
			ASSERT(xdp != NULL);

			/* test whether the extent contains the block */
			if (xdp->cx_data_len > 0 &&
			    (blkend = PBLKNO(xdp->cx_data_len - 1)) >= blkoffset) {
				/* compute disk physical block number from
				 * object physical block number for the page.
				 */
				pblkno = LTOPBLK(cdrfsp, xdp->cx_locdata) +
					 blkoffset;

				/* compute byte count to read for the page 
			 	 * from the extent
				 */
				bcount = (blkend - blkoffset + 1) << CDR_PBLKSHIFT; 
				if (bcount >= CDR_PAGESIZE)
					bcount = CDR_PAGESIZE;
				else 
				{	/* zero out partial page filler for mmap():
					 * roundup byte count to logical block boundary
					 * (for CD-ROM XA, device driver/drive
					 *  supports only logical block size = logical
					 *  sector size = 2 Kbyte)
					 */
					if ((cdrp->cn_mode & IFMT) == IFREG)
					{
						lblkmask = cdrfsp->fs_lblksize - 1;
						bcount = (bcount + lblkmask) & ~lblkmask;
						block = vm_att(tbufp->b_xmemd.subspace_id,
				       		       tbufp->b_baddr);
						bzero(block + bcount, CDR_PAGESIZE - bcount);
						(void)vm_det(block);
					}
				}

				break;
			}
			
			/* only non-last extent size of multiple of page size
			 * are supported for multi-extent file
			 */
			ASSERT(PBLKOFF(xdp->cx_data_len) == 0);
			
			/* subtract out blocks from this extent */
			blkoffset -= PBLKNO(xdp->cx_data_len);
			
			/* get next extent descriptor */
			if (++extno < CDR_NXD)
				xdp = &cdrp->cn_xd[extno];
			else if (extno == CDR_NXD)
				xdp = cdrp->cn_xdlist;
			else
				xdp = xdp->cx_next;
		} /* end while */
	
		/* fill in buffer header to fake out device driver */
		tbufp->b_blkno = pblkno;
		tbufp->b_bcount = bcount;
		tbufp->b_dev = cdrp->cn_dev;

		/* insert CDRFS iodone():
		 * save VMM iodone() entry point, 
		 * set CDRFS iodone() entry point
		 */
		tbufp->b_vp = (void *)(tbufp->b_iodone);
		tbufp->b_iodone = cdrfs_iodone;

		/* advance to next buffer header */
		backbp = tbufp;
		tbufp = tbufp->av_forw;
	} /* end for */
}

/*
 *	cdrfs_iodone
 *
 * function: intercept device driver exception
 *
 * N.B. b_vp field is pirated to intercept cdrdd exception
 *
 */
void
cdrfs_iodone(bp)
struct buf	*bp;	/* pointer to buf struct */
{
	/* reset device driver iodone() */
	bp->b_flags &= ~B_DONE;

	/* filter device driver error */
	if (bp->b_flags & B_ERROR) {
		switch (bp->b_error) {
		case EIO:
		case ESTALE:
		case ENOTREADY:
		case EMEDIA:
			break;
		default:
			bp->b_error = EIO;
		}
	}

	/* restore VMM iodone() */
	bp->b_iodone = (void *)(bp->b_vp);
	iodone(bp);
}

/*
 *	cdr_term
 */
void
cdr_term(void)
{
	extern pid_t	pager_pid;	/* process id of cdr page kproc */

	/* set kproc termination and wakeup kproc.
	 */
	buf_list = -1;
	e_wakeup(&sleep_list);

	/* wait for kproc to exit.
	 */
	while(kgetpgrp(pager_pid) >= 0)
	{
		delay(DELAYTIME);
	}
}
