static char sccsid[] = "@(#)07	1.9.1.7  src/bos/kernext/disp/ped/ddf/mid_gettextfontindex.c, peddd, bos411, 9428A410j 4/28/94 13:45:52";
/*
 *   COMPONENT_NAME: PEDDD
 *
 *   FUNCTIONS: mid_gettextfontindex
 *		
 *
 *   ORIGINS: 27
 *
 *   IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 *   combined with the aggregated modules for this product)
 *                    SOURCE MATERIALS
 *
 *   (C) COPYRIGHT International Business Machines Corp. 1992,1994
 *   All Rights Reserved
 *   US Government Users Restricted Rights - Use, duplication or
 *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */


#define Bool unsigned
#include <sys/types.h>          /* added for i_disable / i_enable       */
#include <sys/xmem.h>
#include <sys/rcm_win.h>
#include <sys/aixgsc.h>
#include <sys/rcm.h>
#include <sys/syspest.h>
#include <sys/errno.h>          /* added for i_disable / i_enable       */
#include <sys/intr.h>           /* added for i_disable / i_enable       */
#include <sys/sleep.h>          /* added to support e_sleep             */
#include <sys/malloc.h> 
#include "hw_dd_model.h"
#include "hw_regs_u.h"
#include "hw_typdefs.h"
#include "hw_regs_k.h"
#include "hw_macros.h"
#include "hw_ind_mac.h"         /* macros and defines used to access adapter */
#include "hw_FIFrms.h"
#include "midddf.h"
#include "mid.h"
#include "midhwa.h"             /* BUS access definitions in here            */
#include "rcm_mac.h"            /* rcm-related macros.  Using FIND_GP        */
#include "midRC.h"
#include "mid_rcm_mac.h"	/* for Ped GUARD and UNGUARD */
#include "mid_dd_trace.h"       /* for system and memory trace.              */

MID_MODULE ( midgetfontindex ); /* defines trace variable                    */
BUGXDEF(dbg_middd);

#define SEARCHING 1		/* Values assigned to seek_status when       */
#define FOUND     0     	/* searching for a free structure element.   */



/*-----------------------------------------------------------------------------
  ATTENTION / NOTE:   Disable this define before releasing this code.
-----------------------------------------------------------------------------*/
/*
#define WATCHDOG_TEST
*/



/*-----------------------------------------------------------------------------
Define interrupt disable/enable value.  This value defined in middef.c   
-----------------------------------------------------------------------------*/

#define PDEV_PRIORITY (pdev->devHead.display->interrupt_data.intr.priority-1)




/*-----------------------------------------------------------------------------

		    M I D _ G E T T E X T F O N T I N D E X

Get 3DM1 Text Font Index (mid_gettextfontindex)


DESCRIPTION

Returns the current 3DM1 Text Font Index from the 3DM1 status block on the
adapter.


INPUT PARAMETERS:

ddf		Pointer to  "midddf_t"  structure.  This structure is part of
		the physical displays structure but is used only by the DDF
		functions.  The  "midddf_t"  structure holds pointers and data
		specific to each of the DDF functions and is used to 
		communicate this information from caller to interrupt handler 
		and back.

correlator      A 16-bit value used to identify a particular call to this
                function.  This value is passed in by  "mid_ddf()"  and was
                generated by a call to "mid_get_correlator()".



RETURN VALUES:

argp            Pointer to structure specific to this function.  This
                structure is of type  "mid_gettextfontindex_t"  (defined in 
		mid.h) and will hold the current text font index value to be 
		returned to the caller.


PSEUDOCODE:

	make_cur_and_guard_dom()

	Enable bus

	Read Text Font Index value and correlator off of adapter.

	Disable bus

	If ( correlator.adapter == correlator.caller)
	{
		Assign current text font into user structure

		unguard_domain()

		Return (TextFontIndex)
	}
	else
	{

		Disable CPU interrupts

	        Secure DDF data structure

	        Assign caller's data into ddf structure

		Enable bus

		Enable CPU interrupts

		Send Synchronization to adapter

		Disable CPU interrupts

		Disable bus

		unguard_domain()

		Start watchdog timer

		e_sleep()  (if necessary)
		
		Stop watchdog timer

		Enable CPU interrupts

		Copy data to application

		Disable CPU interrupts

		Clean up data structures

		Enable CPU interrupts

		Return (TextFontIndex)

-----------------------------------------------------------------------------*/


long mid_gettextfontindex(pdev, argp, correlator)
gscDev                  *pdev;          /* device structure pointer        */
mid_gettextfontindex_t  *argp; 		/* getcon struct. defined in mid.h */
ushort                  correlator;	/* uniquely identifies this call...*/
{

        /*-------------------------------------------------------------------
        Set up the  "ddf"  pointer to point to the  "free_area"  within
        the physical displays structure (phys_displays).

        Support of multiple displays requires that each display keep
        its own copy of the  "phys_displays"  structure.  The free area
        pointer within this structure will point to the  "midddf_t"
        structure for each display.  This structure allows DDF functions
        and their corresponding interrupt handlers to communicate.

        ddf must be pre-defined since it is used in HWPDDFSetup
        -------------------------------------------------------------------*/

        midddf_t                *ddf =
                                (midddf_t *) pdev->devHead.display->free_area;

        /*------------------------------------------------------------------
        If ddf_data_getcpos_t structure ever overflows, more space must be
        allocated on the pinned heap.  more_space_ptr points to this new space.
        ------------------------------------------------------------------*/

        ddf_data_gettextfontindex_t *more_space_ptr;


        /*------------------------------------------------------------------
        Used as temp variable to find last structure being used in linked list.
        ------------------------------------------------------------------*/

        ddf_data_gettextfontindex_t *last_structure_ptr;



        /*------------------------------------------------------------------
        Pointer to structure which is being used for this particular DDF call.
        ------------------------------------------------------------------*/ 

	ddf_data_gettextfontindex_t     *current_ptr; 

	int             old_interrupt_priority;	/*save old priority for enable*/
        short           i, j;
        short           seek_status;    /* used when looking for free struct */
        long            flush = 0x40000;/* value to send FIFO to flush       */
	rcmProc		*pproc;		/* ptr to "current" context          */
        rcx 		*pRCX ; 
	ushort		SB_correlator;  /* correlator from M1 Status Block   */
	ulong		SB_textfontindex;/* textfontindex from M1 Status Block*/
        int             rc = 0;         /* Use for e_sleep                   */


        HWPDDFSetup;                    /* gain access to hardware pointer   */

        MID_DD_ENTRY_TRACE ( midgetfontindex, 1, TEXT_FONT_INDEX, ddf,
                0,
                correlator,
                argp->correlator,
                0 );


	BUGLPR(dbg_midgetfontindex, 1, ("Entering mid_gettextfontindex()\n"));
        BUGLPR(dbg_midgetfontindex, 2, ("correlator=0x%x\n",correlator));


        /*-------------------------------------------------------------------
	Use FIND_GP macro to get process pointer of current process, ie, 
	process which called us.  Then use this pointer to point to this
	process's current context.
        -------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 3, 
		("Calling FIND_GP pdev=0x%x  pproc=0x%x\n", pdev, pproc));

	FIND_GP(pdev, pproc);



	/*--------------------------------------------------------------------
	Call the RCM function,  "make_cur_and_guard_dom()"  to signal to 	
	the RCM that we must not have a context switch on this context until  
	"unguard_domain()" is called to release it.  This is done to 
	guarantee that when we send a structure element to the adapter via a 
	hardware macro call, that we send it into the FIFO of the correct 
	context.  If we did not secure the context, then a context switch 
	could occur after the macro call was started and before the structure 
	element has made it into the correct FIFO.
	--------------------------------------------------------------------*/

	pRCX = pproc->pDomainCur[0] ;
        if ( pRCX->flags & RCX_NULL )
        { 
    	    BUGLPR(dbg_midgetfontindex, 1,
				("Exit mid_getfontindex, NULL context\n\n"));
    	    MID_DD_EXIT_TRACE (midgetfontindex, 2, TEXT_FONT_INDEX, ddf,
							pproc, pRCX, 0, 0);
    	    return (MID_RC_OK) ;
        }

        BUGLPR(dbg_midgetfontindex, 3, ("Calling make_cur_and_guard_dom.\n"));

	MID_GUARD_AND_MAKE_CUR (pdev, pRCX) ; 

        BUGLPR(dbg_midgetfontindex, 3, 
		("Returned from make_cur_and_guard_dom call.\n"));





        /*-------------------------------------------------------------------
	SCENERIO 1  --  correlators do match.
        -------------------------------------------------------------------*/


        /*------------------
            enable bus
        ------------------*/

        PIO_EXC_ON();



        /*-------------------------------------------------------------------
	Read current Text Font Index and text font correlator off of 
	the adapter.  This correlator was passed in by the caller (MOD1)
	and is used by the device driver to determine if the MOD1 text font
	index on the adapter is current.  This is done by comparing the 
	correlator off the adapter with the one passed in by the caller.
	The DSP corerlator is a separate correlator and is used by the device
	driver in the event that we need to wait for the text font index to 
	be updated, and therefore go through the interrupt handler.
        -------------------------------------------------------------------*/

        MID_RD_M1SB_VALUE( MID_M1SB_TEXT_FONT_CORRELATOR, SB_correlator);
        MID_RD_M1SB_VALUE( MID_M1SB_TEXT_FONT, SB_textfontindex);

        BUGLPR(dbg_midgetfontindex, 3, ("Passed in   : \n"));
        BUGLPR(dbg_midgetfontindex, 3, 
		("   argp->correlator=0x%x \n",argp->correlator));
        BUGLPR(dbg_midgetfontindex, 3, ("   argp->textfontindex=0x%x \n",
		argp->textfontindex));
        BUGLPR(dbg_midgetfontindex, 3, ("From adapter: \n"));
        BUGLPR(dbg_midgetfontindex, 3, 
		("      SB_correlator=0x%x \n",SB_correlator));
        BUGLPR(dbg_midgetfontindex, 3, ("      SB_textfontindex=0x%x \n",
		SB_textfontindex));



        /*------------------
           disable bus
        ------------------*/

        PIO_EXC_OFF();


        MID_DD_TRACE_PARMS ( midgetfontindex, 1, TEXT_FONT_INDEX_PARMS, ddf,
                0,
                0x1,
                SB_textfontindex,
                SB_correlator );



        /*-------------------------------------------------------------------	
	Compare correlators.  If equal, then return Text Font Index.
	If not equal, then continue...

	Interrupts need to be enabled here since we are writing to a 
	structure in user space.  If this structure is paged out, an 
	interrupt must occur to page it back in, but if interrupts are
	disabled, then we can't page it in.
        -------------------------------------------------------------------*/
	
	if (SB_correlator == argp->correlator)
	{
		argp->textfontindex = SB_textfontindex;

        	BUGLPR(dbg_midgetfontindex, 3, 
			("Correlators match -- returning: \n"));
        	BUGLPR(dbg_midgetfontindex, 3, 
			("  argp->correlator    = 0x%x \n", argp->correlator ));
        	BUGLPR(dbg_midgetfontindex, 3, 
			("  argp->textfontindex = 0x%x \n",
			argp->textfontindex ));


		/*------------------------------------------------------------
		Call  "unguard_domain()".  This indicates to the RCM that this 
		context is now candidate for a context switch.
		------------------------------------------------------------*/

        	BUGLPR(dbg_midgetfontindex, 3, ("Calling unguard_domain.\n"));

		MID_UNGUARD_DOMAIN (pdev, pRCX) ; 

        	BUGLPR(dbg_midgetfontindex, 3,
			("Returned from unguard_domain call.\n"));



                MID_DD_TRACE_PARMS ( midgetfontindex, 1, TEXT_FONT_INDEX_PARMS,
                        ddf, 0,
                        0x2,
                        SB_textfontindex,
                        SB_correlator );

		return(0); 
	}



        /*-------------------------------------------------------------------	
	SCENERIO 2  --  correlators do NOT match.

	Since the adapter's Text Font correlator does not match the caller's
	correlator, we must flush the FIFO, go to sleep, and wait for the
	interrupt handler to wake us up.
        -------------------------------------------------------------------*/



	/*--------------------------------------------------------------------
	Disable CPU interrupts to guarantee integrity of our linked list 
	structure.  If an interrupt were to occur while building this 
	structure, then part of the data for the first interrupt may be lost.
	--------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 5, ("Disabling CPU interrupts - start.\n"));

        old_interrupt_priority = i_disable(PDEV_PRIORITY);

        BUGLPR(dbg_midgetfontindex, 5, ("Disabling CPU interrupts - done.\n"));




        /*-------------------------------------------------------------------	
        Determine if there is a free element in the"ddf_data_gettextfontindex_t"
        structure by checking for NULL in the data field.  This structure is
        defined with an initial array size of ARY_SIZE in the  "midddf_t"
        structure.  If all elements are in use, this means we have ARY_SIZE  
	"mid_gettextfontindex"  type interrupts pending and we malloc ARY_SIZE 
	more of these structures in the pinned heap.  This should cut down on 
	the number of malloc calls made without wasting much space.  Four will 
	be picked as an initial malloc size since there should rarely be more 
	than four interrupts of any given type pending at the same time.  When 
	the count of "mid_gettextfontindex()"  calls pending gets to one, then 
	free any groups of four structures that have been allocated over and 
	above the original four.
        -------------------------------------------------------------------*/



        i = 0;
        last_structure_ptr = &ddf->ddf_data_gettextfontindex[0];
        seek_status = SEARCHING;

        BUGLPR(dbg_midgetfontindex, 5, ("SEARCHING for free structure.\n"));



        /*------------------------------------------------------------------
        Find first available slot in array and set current_ptr to
        point to it.
        ------------------------------------------------------------------*/

        while (seek_status == SEARCHING)
        {

                if (last_structure_ptr->correlator != NULL)
                /*-------------------------------------------------------------
                If true, then structure element is occupied. Is it the last?
                -------------------------------------------------------------*/
                {

                        i++;

                        BUGLPR(dbg_midgetfontindex, 5,
                        ("Found occupied structure, still looking...i=0x%x \n",
                                i ));


                        if (last_structure_ptr->next == NULL)
                        /*----------------------------------------------------
                        If true, we have found the last linked list element
                        and must allocate more.
                        ----------------------------------------------------*/
                        {

                          BUGLPR(dbg_midgetfontindex, 1,
                            ("About to malloc more space for structs.\n"));

        		  i_enable(old_interrupt_priority);

                          more_space_ptr = (ddf_data_gettextfontindex_t *)
                          xmalloc(ARY_SIZE*sizeof(ddf_data_gettextfontindex_t),
	                          3, pinned_heap);

        		  old_interrupt_priority = i_disable(PDEV_PRIORITY);


                          if (more_space_ptr == NULL) /* malloc failed */
                          {
                                 BUGLPR(dbg_midgetfontindex, 0,
                                 ("xmalloc failed !!!!!!!!!\n"));
                          }



                          /*--------------------------------------------
                          Initialize "next" and "correlator" fields in
                          new structures to NULL.
                          --------------------------------------------*/

                          last_structure_ptr->next = more_space_ptr;

                          for (j=0; j<=ARY_SIZE-2; j++)
                          {
                                  (more_space_ptr+j)->next =
                                          more_space_ptr+(j+1);

                                  (more_space_ptr+j)->correlator = NULL;
                          }



                          /*-------------------------------------------
                          Initialize last "next" and "correlator" to NULL.
                          -------------------------------------------*/

                          (more_space_ptr+(ARY_SIZE-1))->next = NULL;
                          (more_space_ptr+(ARY_SIZE-1))->correlator =NULL;



                          /*---------------------------------------------
                          point to 1st free space
                          ---------------------------------------------*/

                          current_ptr = last_structure_ptr->next;


                          /*---------------------------------------------
                          Break out of "while" loop - we now have struct
                          ---------------------------------------------*/

                          seek_status = FOUND;
                          break;

                        }

                        last_structure_ptr = last_structure_ptr->next;


                }


                else    /*  found a free structure */
                {

                        seek_status = FOUND;


        		/*--------------------------------------------------
			Set current_ptr to point to last array element 
			checked.  This array element is the first one
			to be found unoccupied.
        		--------------------------------------------------*/

			current_ptr = last_structure_ptr;
                        
                        BUGLPR(dbg_midgetfontindex, 5,
                            ("Found a free structure. current_ptr=0x%x i=%d\n",
                              current_ptr,i));

                }

        }


	/*--------------------------------------------------------------------
	When we have made sure that there is an unused  
	"ddf_data_gettextfontindex"  structure available to us and that 
	interrupts are disabled, then fill in this available structure by 
	doing the following:

        - Insert correlator value passed in by  "mid_ddf()"  into  "correlator"
          field of this structure.

	- Place pointer to function-specific data structure,  of type 
	  "mid_gettextfontindex"  in this case, into data field of the  
	  "ddf_data_gettextfontindex_t"  structure.  Since the  
	  "ddf_data_gettextfontindex_t" is part of the "midddf_t" structure, 
	  it will be available to the interrupt handler.  Therefore, the user
	  data will be available to the interrupt handler.
	--------------------------------------------------------------------*/

        current_ptr->correlator   = correlator;
        current_ptr->user_data    = argp;
	current_ptr->int_rcvd     = 0;
        current_ptr->sleep_flg    = 0;


        BUGLPR(dbg_midgetfontindex, 3,("Initialized structure to:\n"));
        BUGLPR(dbg_midgetfontindex, 3,
		("Is current_ptr->correlator=0x%x == 0x%x?\n",
	  	current_ptr->correlator, 
	  	ddf->ddf_data_gettextfontindex[i].correlator));
        BUGLPR(dbg_midgetfontindex, 3,("Is current_ptr->next=0x%x == 0x%x?\n",
          	current_ptr->next, ddf->ddf_data_gettextfontindex[i].next));
        BUGLPR(dbg_midgetfontindex, 3,
		("Is current_ptr.user_data=0x%x == 0x%x\n",
          	current_ptr->user_data, 
		ddf->ddf_data_gettextfontindex[i].user_data));



        /*------------------
            enable bus
        ------------------*/

        PIO_EXC_ON();



#ifndef  WATCHDOG_TEST   /* If testing watchdog timer, don't send call
                            to adapter.  This will force the timer to pop   */

	/*--------------------------------------------------------------------
	Make a MID_Synchronization call.  This will cause an interrupt when
	received and thus guarantee that the Text Font Index on the adapter 
	gets updated.  In the NOWAIT case, the Text Font Index is not 
	guaranteed to be up to date.
        -------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 5, 
		("Making MID_Synchronization call:  correlator=0x%x\n",
		correlator ));

        MID_DD_TRACE_PARMS ( midgetfontindex, 1, TEXT_FONT_INDEX_PARMS,
                ddf, 0,
                0x3,
                correlator,
                i );


        /* ----------------
           Enable interrupts before write to FIFO to avoid deadlock if FIFO
           is full.   Interrupts are disabled after the write
        -----------------*/

        i_enable(old_interrupt_priority);

	MID_Synchronization( correlator );

        old_interrupt_priority = i_disable(PDEV_PRIORITY);

#endif
	


        /*------------------
           disable bus
        ------------------*/

        PIO_EXC_OFF();



	/*--------------------------------------------------------------------
	Call  "unguard_domain()".  This indicates to the RCM that this 
	context is now candidate for a context switch.
	--------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 3, ("Calling unguard_domain.\n"));

	MID_UNGUARD_DOMAIN (pdev, pRCX) ; 

        BUGLPR(dbg_midgetfontindex, 3,("Returned from unguard_domain call.\n"));




	/*-------------------------------------------------------------------
	Start up the watchdog timer so that if the interrupt never 
	comes back (because of broken hardware for example), then we have a
	way of returning control to the caller and cleaning up.  The watchdog
	handler function is specified in mid_initialize_DDF().

	Assign wakeup address for this timer to be the same for the e_sleep()
	which follows since we wish to resume control immediately following
	the sleep in the event that the timer pops.
	-------------------------------------------------------------------*/


        BUGLPR(dbg_midgetfontindex, 3,
                ("calling w_start with:  0x%x \n",
                (&current_ptr->watchdog_data.dog ) ));

        BUGLPR(dbg_midgetfontindex, 5,
                ("     watchdog restart period = 0x%x seconds. \n",
                (current_ptr->watchdog_data.dog.restart ) ));

        BUGLPR(dbg_midgetfontindex, 5,
                ("     watchdog prev field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.prev ) ));

        BUGLPR(dbg_midgetfontindex, 5,
                ("     watchdog next field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.next ) ));

        BUGLPR(dbg_midgetfontindex, 5,
                ("     watchdog count field    = 0x%x. \n",
                (current_ptr->watchdog_data.dog.count ) ));

        BUGLPR(dbg_midgetfontindex, 5,
                ("     watchdog func field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.func ) ));




        BUGLPR(dbg_midgetfontindex, 5, ("Starting watchdog timer.\n"));

	current_ptr->watchdog_data.sleep_addr = &current_ptr->wakeup_address;


#ifdef  ENABLE_WATCHDOGS  /* Disable the watchdog timers.  They can cause   */
                          /* problems when the adapter is legitimately      */
                          /* taking more time than the watchdog is set for. */

	w_start( &(current_ptr->watchdog_data.dog ) );
#endif



	current_ptr->wakeup_address = EVENT_NULL;  /* NOTE: tmp-put in middef*/ 

        BUGLPR(dbg_midgetfontindex, 2, ("wakeup_address=0x%x  i=%d\n",
                current_ptr->wakeup_address, i));
        BUGLPR(dbg_midgetfontindex, 2,
                ("&current_ptr.wakeup_address=0x%x\n ",
                &current_ptr->wakeup_address));
        BUGLPR(dbg_midgetfontindex, 2, ("SLEEPING...\n"));

        /* -----------------------------------------------------------------
           Since interrupts were enabled before the write to FIFO, we may have
           received the interrupt already.  If this is true, int_rcvd set,
           do not sleep.  If not set, set sleep_flg and then sleep.  The
           int_rcvd flag is set in the interrupt handler and the sleep_flg is
           tested there.
        -------------------------------------------------------------------*/

        if( !current_ptr->int_rcvd)
        {

		/*-----------------------------------------------------------
		Put this process to sleep and wait to be awakened by this 
		function's interrupt handler, "mid_intr_gettextfontindex".
		-----------------------------------------------------------*/

                current_ptr->sleep_flg++;


                /*------------------------------------------------------------
                  This "while" loop is simply to ensure that we actually sleep
                  at this point.  There have been occaissions where sleep has
                  not worked, so this forces "e_sleep" calls until the flag is
                  cleared in the interrupt handler.
                ------------------------------------------------------------*/

                while (current_ptr->sleep_flg != 0x10)
                {

                	e_sleep( &current_ptr->wakeup_address, EVENT_SHORT );

                    	if(current_ptr->sleep_flg != 0x10)
                    	{
                        	BUGLPR(dbg_midgetfontindex, 1, 
					("Did not sleep\n"));
                    	}

                }



                BUGLPR(dbg_midgetfontindex, 2, ("AWAKE!!!!\n"));
        }



#ifdef  ENABLE_WATCHDOGS  /* Disable the watchdog timers.  They can cause   */
                          /* problems when the adapter is legitimately      */
                          /* taking more time than the watchdog is set for. */

	/*---------------------------------------
	We made it back successfully from the 
	adapter so turn off watchdog timer.
	---------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 5, ("Stoping watchdog timer.\n"));

	w_stop( &(current_ptr->watchdog_data.dog ) );
#endif



	/*-------------------------------------------------------------------
	Enable interrupts.  We must do this here to guarantee the integrity of 
	the user data structure.  If we were to page fault (because the user 
	data structure is on another page of virtual memory), then we would 
	panic or hang the system since there is no way to page in that 
	structure without interrupts enabled.  Another solution would be to 
	pin the user data structure and then write to it, but pinning is very 
	expensive.
	-------------------------------------------------------------------*/

        i_enable(old_interrupt_priority);


	/*-------------------------------------------------------------------
	When re-awakened, assign the two pieces of data retrieved from the 
	interrupt handler into the caller's data structure, ie, place status 
	word and caller's correlator value into the  "mid_gettextfontindex_t"  
	structure.
	-------------------------------------------------------------------*/

	argp->correlator    = current_ptr->ddf_gettextfontindex.correlator;
	argp->textfontindex = current_ptr->ddf_gettextfontindex.textfontindex;

	BUGLPR(dbg_midgetfontindex, 2, 
		("Assigning values:  correlator=0x%x  index=0x%x \n", 
		argp->correlator, argp->textfontindex ) );




	/*-------------------------------------------------------------------
	Disable interrupts.  Interrupts must be disabled before we clean up 
	the DDF data structures.  If an interrupt were to occur while changing 
	one of these structures, then another process could write to or read 
	from it, thereby corrupting the structure for one or both processes.
	-------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 4, ("Disable interrupts.\n"));
        old_interrupt_priority = i_disable(PDEV_PRIORITY);




	/*-------------------------------------------------------------------
	Clean up any data structures used to make them 
	available for another gettextfontindex call.
	-------------------------------------------------------------------*/

        BUGLPR(dbg_midgetfontindex, 4, ("Cleaning up structure.\n"));

	current_ptr->correlator     = NULL;
	current_ptr->wakeup_address = EVENT_NULL;
	current_ptr->user_data      = NULL;




	/*-------------------------------------------------------------------
	Enable CPU interrupts.  Must re-enable interrupts before 
	returning to caller.
	-------------------------------------------------------------------*/

        i_enable(old_interrupt_priority);

	BUGLPR(dbg_midgetfontindex, 1, ("Leaving mid_gettextfontindex()\n"));

        MID_DD_EXIT_TRACE ( midgetfontindex, 1, TEXT_FONT_INDEX, ddf,
                0,
                argp->correlator,
                argp->textfontindex,
                0 );

        return(0);

}
