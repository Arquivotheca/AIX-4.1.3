static char sccsid[] = "@(#)08	1.9.1.7  src/bos/kernext/disp/ped/ddf/mid_getcondition.c, peddd, bos411, 9428A410j 4/28/94 13:45:44";
/*
 *   COMPONENT_NAME: PEDDD
 *
 *   FUNCTIONS: mid_getcondition
 *		
 *
 *   ORIGINS: 27
 *
 *   IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 *   combined with the aggregated modules for this product)
 *                    SOURCE MATERIALS
 *
 *   (C) COPYRIGHT International Business Machines Corp. 1992,1994
 *   All Rights Reserved
 *   US Government Users Restricted Rights - Use, duplication or
 *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */


#define Bool unsigned
#include <sys/types.h>          /* added for i_disable / i_enable       */
#include <sys/xmem.h>
#include <sys/rcm_win.h>
#include <sys/aixgsc.h>
#include <sys/rcm.h>
#include <sys/syspest.h>
#include <sys/errno.h>          /* added for i_disable / i_enable       */
#include <sys/intr.h>           /* added for i_disable / i_enable       */
#include <sys/sleep.h>          /* added to support e_sleep             */
#include <sys/malloc.h> 	/* need */
#include "hw_dd_model.h"
#include "hw_regs_u.h"
#include "hw_regs_k.h"
#include "hw_typdefs.h"
#include "hw_macros.h"
#include "hw_FIFrms.h"
#include "hw_ind_mac.h"         /* macros and defines used to access adapter */
#include "midhwa.h"             /* BUS access definitions in here            */
#include "midddf.h"
#include "mid.h"
#include "rcm_mac.h"            /* rcm-related macros.  Using FIND_GP        */
#include "midRC.h"

#include "mid_rcm_mac.h"        /* for Ped GUARD and UNGUARD  */
#include "mid_dd_trace.h"       /* for system and memory trace.              */
MID_MODULE ( midgetcondition ); /* defines trace variable                    */
BUGXDEF(dbg_middd);

#define SEARCHING 1		/* Values assigned to seek_status when       */
#define FOUND     0     	/* searching for a free structure element.   */


/*-----------------------------------------------------------------------------
  ATTENTION / NOTE:   Disable this define before releasing this code.
-----------------------------------------------------------------------------*/
/*
#define WATCHDOG_TEST
*/



/*----------------------------------------------------------------------------
Define interrupt disable/enable value.  This value defined in middef.c   
----------------------------------------------------------------------------*/

#define PDEV_PRIORITY (pdev->devHead.display->interrupt_data.intr.priority-1)




/*----------------------------------------------------------------------------

			M I D _ G E T C O N D I T I O N 

Get 3DM1 status word (mid_getcondition)


DESCRIPTION

Returns the 3DM1 status word from the Pedernales adapter.  This 32-bit value
contains status on up to 32 GraPHIGS-related events and values, including
culling and pruning.


INPUT PARAMETERS:

ddf		Pointer to  "midddf_t"  structure.  This structure is part of
		the physical displays structure but is used only by the DDF
		functions.  The  "midddf_t"  structure holds pointers and data
		specific to each of the DDF functions and is used to 
		communicate this information from caller to interrupt handler 
		and back.

argp		(see description of  "wait"  flag below.)

correlator      A 16-bit value used to identify a particular call to this
                function.  This value is passed in by  "mid_ddf()"  and was
                generated by a call to "mid_get_correlator()".



RETURN VALUES:

argp		Pointer to structure specific to this function.  This structure 
		is of type  "mid_getcondition_t"  (defined in mid.h) and will 
		hold the following input and output values:

			- a caller-provided correlator value (which is to be
			  associated with status data from the hardware).  This
			  is only an output value.  We read this off the
			  adapter and pass it back to the caller.  This value
			  was originally passed to the adapter in a 
			  "set_condition()"  call.

			- flag indicating if the caller wishes to wait for the
			  "current" value of the status word.  If not, then the
			  Device Driver will simply fetch the value directly
			  without waiting for the next refresh.  This is only 
			  an input value.

			- current value of the 3DM1 status word.  This is only
			  an output value.


PSEUDOCODE:

	make_cur_and_guard_domain()

	if (NOWAIT)               -- scenario 1 -- 
	{
		Enable bus

		Get condition word from 3DM1 status block on adapter
		
		Disable bus

		unguard_domain()

		Return
	}
	else                      -- scenario 2 --
	{

		Disable CPU interrupts

	        Secure DDF data structure

	        Assign caller's data into ddf structure

		Enable bus

	        Enable CPU interrupts

		Send synchronization to adapter

		Disable CPU interrupts

		Disable bus

		unguard_domain()

		Start watchdog timer

		e_sleep()   (if necessary)
	
		Stop watchdog timer

		Enable CPU interrupts

		Copy data to application data structure

		Disable CPU interrupts

		Clean up data structures

		Enable CPU interrupts

		Return

----------------------------------------------------------------------------*/



long mid_getcondition(pdev, argp, correlator)
gscDev                  *pdev;          /* device structure pointer        */
mid_getcondition_t      *argp; 		/* getcon struct. defined in mid.h */
ushort                  correlator;	/* uniquely identifies this call...*/
{

        /*--------------------------------------------------------------------
        Set up the  "ddf"  pointer to point to the  "free_area"  within
        the physical displays structure (phys_displays).

        Support of multiple displays requires that each display keep
        its own copy of the  "phys_displays"  structure.  The free area
        pointer within this structure will point to the  "midddf_t"
        structure for each display.  This structure allows DDF functions
        and their corresponding interrupt handlers to communicate.

        ddf must be pre-defined since it is used in HWPDDFSetup
        --------------------------------------------------------------------*/

        midddf_t                *ddf =
                                (midddf_t *) pdev->devHead.display->free_area;

        /*--------------------------------------------------------------------
        If ddf_data_getcpos_t structure ever overflows, more space must be
        allocated on the pinned heap.  more_space_ptr points to this new space.
        --------------------------------------------------------------------*/

        ddf_data_getcondition_t     *more_space_ptr;



        /*--------------------------------------------------------------------
        Used as temp variable to find last structure being used in linked list.
        --------------------------------------------------------------------*/

        ddf_data_getcondition_t     *last_structure_ptr;



        /*--------------------------------------------------------------------
        Pointer to structure which is being used for this particular DDF call.
        --------------------------------------------------------------------*/ 

	ddf_data_getcondition_t     *current_ptr; 
	int             old_interrupt_priority;	/*save old priority for enable*/
        short           i, j;
        short           seek_status;    /* used when looking for free struct */
        long            flush = 0x40000;/* value to send FIFO to flush       */
	rcmProc		*pproc;		/* ptr to "current" context          */
        rcx		*pRCX ; 
        int             rc = 0;         /* Use for e_sleep                   */



        HWPDDFSetup;                    /* gain access to hardware pointer   */

        MID_DD_ENTRY_TRACE ( midgetcondition, 1, GET_CONDITION, ddf,
                0,
                correlator,
                argp->wait_flag,
                0 );



	BUGLPR(dbg_midgetcondition, 1, ("Entering mid_getcondition()\n"));

        BUGLPR(dbg_midgetcondition, 3, ("From caller:\n" ));
        BUGLPR(dbg_midgetcondition, 3, ("  argp->wait_flag = 0x%x \n",
		argp->wait_flag ));
        BUGLPR(dbg_midgetcondition, 3, ("  argp->correlator = 0x%x \n",
		argp->correlator));
        BUGLPR(dbg_midgetcondition, 3, ("  argp->status_word = 0x%x \n\n",
		argp->status_word));

        BUGLPR(dbg_midgetcondition, 3, ("correlator=0x%x\n",correlator));




        /*--------------------------------------------------------------------
	Use FIND_GP macro to get process pointer of current process, ie, 
	process which called us.  Then use this pointer to point to this
	process's current context.
        --------------------------------------------------------------------*/

	FIND_GP(pdev, pproc);

        BUGLPR(dbg_midgetcondition, 4,("Calling make_cur_and_guard_domain.\n"));



	/*---------------------------------------------------------------------
	Call the RCM function,  "make_cur_and_guard_domain()"  to signal to 	
	the RCM that we must not have a context switch on this context until  
	"unguard_domain()" is called to release it.  This is done to 
	guarantee that when we send a structure element to the adapter via a 
	hardware macro call, that we send it into the FIFO of the correct 
	context.  If we did not secure the context, then a context switch 
	could occur after the macro call was started and before the structure 
	element has made it into the correct FIFO.
	---------------------------------------------------------------------*/

	pRCX = pproc->pDomainCur[0] ;
        if ( pRCX->flags & RCX_NULL )
        { 
    	    BUGLPR(dbg_midgetcondition, 1,
				("Exit mid_getcondition, NULL context\n\n"));
    	    MID_DD_EXIT_TRACE (midgetcondition, 2, GET_CONDITION, ddf, pproc,
								pRCX, 0, 0);
    	    return (MID_RC_OK) ;
        }

	MID_GUARD_AND_MAKE_CUR (pdev,pRCX) ; 


        /*---------------------------------------------------------------------
        Read 3DM1 status area on adapter using scenario 1:

        SCENARIO 1   --  NO_WAIT

        Check the  "wait"  flag sent in by the caller.  If this flag is not
        set, which should be the normal case, then the caller simply wants the
        current status of the 3DM1 condition word.

        Interrupts need to be enabled here since we are writing to a 
        structure in user space.  If this structure is paged out, an 
        interrupt must occur to page it back in. 
        ---------------------------------------------------------------------*/

	if (  ! (argp->wait_flag) )
	{

	        /*------------------
		   enable bus
		------------------*/

		PIO_EXC_ON();


		/*------------------------------------------------------------ 
		Call hardware macro to read 3DM1 status word directly 
		from the adapter into the data structure passed by the 
		caller,  "mid_getcondition".  
		------------------------------------------------------------*/

		MID_RD_M1SB_VALUE( MID_M1SB_CONDITION_FLAG, argp->status_word);

        	BUGLPR(dbg_midgetcondition, 2, ("NO-WAIT case \n" ));

        	BUGLPR(dbg_midgetcondition,2,("From adapter: \n" ));
        	BUGLPR(dbg_midgetcondition,2,("   argp->status_word = 0x%x\n",
			argp->status_word ));


		/*------------------------------------------------------------ 
		Call hardware macro to read user's correlator (the one passed
		in on their "setcondition" call) directly from the adapter into 
		the data structure passed by the caller,  "mid_getcondition".  
		------------------------------------------------------------*/

	        MID_RD_M1SB_VALUE( MID_M1SB_CORRELATOR, argp->correlator );

        	BUGLPR(dbg_midgetcondition,2,("   argp->correlator  = 0x%x\n",
			argp->correlator ));


		/*------------------
		   disable bus
		------------------*/

		PIO_EXC_OFF();



		/*-------------------------------------------------------------
		Call  "unguard_domain()".  This indicates to the RCM that this 
		context is now candidate for a context switch.
		-------------------------------------------------------------*/

        	BUGLPR(dbg_midgetcondition, 4, ("Calling unguard_domain.\n"));

		MID_UNGUARD_DOMAIN (pdev,pRCX) ; 

        	BUGLPR(dbg_midgetcondition, 4,
			("Returned from unguard_domain call.\n"));



		BUGLPR(dbg_midgetcondition, 1,("Leaving mid_getcondition()\n"));

		return(0);
	} 


        /*---------------------------------------------------------------------
        Disable CPU interrupts to guarantee integrity of our linked list
        structure.  If an interrupt were to occur while building this
        structure, then part of the data for the first interrupt may be lost.
        ---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 5, ("Disabling CPU interrupts - start.\n"));

        old_interrupt_priority = i_disable(PDEV_PRIORITY);

        BUGLPR(dbg_midgetcondition, 5, ("Disabling CPU interrupts - done.\n"));



        /*---------------------------------------------------------------------
        Read 3DM1 status area on adapter using scenario 2:

        SCENARIO 2  --  WAIT

        Check the  "wait"  flag passed in by the caller.  If this flag is set,
        this means that the caller wants the adapter to update the status word
        before returning the value.  This requires that we synchronize the
        adapter refresh with our read.  We must wait until we are certain that
        the 3DM1 status word has been updated before we initiate a read.  This
        requires use of the interrupt handler, whereas in Scenario 1, we can
        directly read the existing information and ignore how recently it was
        refreshed.
        ---------------------------------------------------------------------*/





        /*---------------------------------------------------------------------
        Determine if there is a free element in the  "ddf_data_getcondition_t"
        structure by checking for NULL in the data field.  This structure is
        defined with an initial array size of ARY_SIZE in the  "midddf_t"
        structure.  If all elements are in use, this means we have ARY_SIZE  "m
        id_getcondition"  type interrupts pending and we malloc ARY_SIZE more
        of these structures in the pinned heap.  This should cut down on the
        number of malloc calls made without wasting much space.  Four will be
        picked as an initial malloc size since there should rarely be more than
        four interrupts of any given type pending at the same time.  When the
        count of "mid_getcondition()"  calls pending gets to one, then free any
        groups of four structures that have been allocated over and above the
        original four.
        ---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 2, ("WAIT case \n" ));


        i = 0;
        last_structure_ptr = &ddf->ddf_data_getcondition[0];
        seek_status = SEARCHING;

        BUGLPR(dbg_midgetcondition, 5, ("SEARCHING for free structure.\n"));


        /*--------------------------------------------------------------------
        Find first available slot in array and set current_ptr to
        point to it.
        --------------------------------------------------------------------*/

        while (seek_status == SEARCHING)
        {

                if (last_structure_ptr->correlator != NULL)
                /*-----------------------------------------------------------
                If true, then structure element is occupied. Is it the last?
                -----------------------------------------------------------*/
                {

                        i++;

                        BUGLPR(dbg_midgetcondition, 5,
                        ("Found occupied structure, still looking...i=0x%x \n",
                                i ));


                        if (last_structure_ptr->next == NULL)
                        /*---------------------------------------------------
                        If true, we have found the last linked list element
                        and must allocate more.
                        ---------------------------------------------------*/
                        {

                        	BUGLPR(dbg_midgetcondition, BUGACT,
	                        ("About to malloc more space for structs.\n"));

        			i_enable(old_interrupt_priority);

                               more_space_ptr = (ddf_data_getcondition_t *)
                               xmalloc(ARY_SIZE*sizeof(ddf_data_getcondition_t),
	                		3, pinned_heap );

        			old_interrupt_priority = i_disable(PDEV_PRIORITY);

                                if (more_space_ptr == NULL) /* malloc failed */
                                {
                                        BUGLPR(dbg_midgetcondition, BUGACT,
                                        ("xmalloc failed !!!!!!!!!\n"));
                                }


                                /*--------------------------------------------
                                Initialize "next" and "correlator" fields in
                                new structures to NULL.
                                --------------------------------------------*/

                                last_structure_ptr->next = more_space_ptr;

                                for (j=0; j<=ARY_SIZE-2; j++)
                                {
                                        (more_space_ptr+j)->next =
                                                more_space_ptr+(j+1);

                                        (more_space_ptr+j)->correlator = NULL;
                                }


                                /*--------------------------------------------
                                Initialize last "next" and "correlator" to NUL
                                --------------------------------------------*/

                                (more_space_ptr+(ARY_SIZE-1))->next = NULL;
                                (more_space_ptr+(ARY_SIZE-1))->correlator =NULL;



                                /*--------------------------------------------
				point to 1st free space
                                --------------------------------------------*/

	                        current_ptr = last_structure_ptr->next; 



                                /*---------------------------------------------
                                Break out of "while" loop - we now have struct
                                ---------------------------------------------*/

                                seek_status = FOUND;
                                break;

                        }

                        last_structure_ptr = last_structure_ptr->next;


                }


                else    /*  found a free structure */
                {
                        seek_status = FOUND;


        		/*---------------------------------------------------
			Set current_ptr to point to last array element 
			checked.  This array element is the first one
			to be found unoccupied.
        		---------------------------------------------------*/

			current_ptr = last_structure_ptr;

                        BUGLPR(dbg_midgetcondition, BUGACT,
                            ("Found a free structure. current_ptr=0x%x i=%d\n",
                              current_ptr,i));

                }

        }



	/*---------------------------------------------------------------------
	When we have made sure that there is an unused  
	"ddf_data_getcondition_t"  structure available to us and that 
	interrupts are disabled, then fill in this available structure by 
	doing the following:

        - Insert correlator value passed in by  "mid_ddf()"  into  "correlator"
          field of this structure.

	- Place pointer to function-specific data structure,  of type 
	  "mid_getcondition_t"  in this case, into data field of the  "ddf_data
	  _getcondition_t"  structure.  Since the  "ddf_data_getcondition_t"
	  is part of the "midddf_t" structure, it will be available to the 
	  interrupt handler.  Therefore, the user data will be available to the
	  interrupt handler.
	---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 5, ("Initializing structure.\n"));
        current_ptr->correlator   = correlator;
        current_ptr->user_data    = argp;
	current_ptr->int_rcvd     = 0;
	current_ptr->sleep_flg	  = 0;



        BUGLPR(dbg_midgetcondition, 3,("Initialized structure to:\n"));
        BUGLPR(dbg_midgetcondition, 3,
		("Is current_ptr->correlator=0x%x == 0x%x?\n",
        	current_ptr->correlator, 
		ddf->ddf_data_getcondition[i].correlator));
        BUGLPR(dbg_midgetcondition, 3,
		("Is current_ptr->next=0x%x == 0x%x?\n",
           	current_ptr->next, 
		ddf->ddf_data_getcondition[i].next));
        BUGLPR(dbg_midgetcondition, 3,
		("Is current_ptr.user_data=0x%x == 0x%x\n",
           	current_ptr->user_data, 
		ddf->ddf_data_getcondition[i].user_data));


        /*------------------
            enable bus
        ------------------*/

        PIO_EXC_ON();



#ifndef  WATCHDOG_TEST   /* If testing watchdog timer, don't send call
                            to adapter.  This will force the timer to pop   */

        /* ----------------
           Enable interrupts before write to FIFO to avoid deadlock if FIFO
           is full.   Interrupts are disabled after the write
        -----------------*/

        i_enable(old_interrupt_priority);


	/*---------------------------------------------------------------------
	Make a MID_Synchronization call.  This will cause an interrupt when
	received and thus guarantee that the status word on the adapter gets
	updated.  In the NOWAIT case, the status word is not guaranteed to be
	up to date.
        --------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 2, 
		("MID_Synchronization call:  correlator=0x%x\n", correlator));

	MID_Synchronization( correlator );

	old_interrupt_priority = i_disable(PDEV_PRIORITY);
#endif
	


        /*------------------
           disable bus
        ------------------*/

        PIO_EXC_OFF();



	/*---------------------------------------------------------------------
	Call  "unguard_domain()".  This indicates to the RCM that this 
	context is now candidate for a context switch.
	---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 4, ("Calling unguard_domain.\n"));

	MID_UNGUARD_DOMAIN (pdev,pRCX) ; 

        BUGLPR(dbg_midgetcondition, 4,("Returned from unguard_domain call.\n"));



	/*--------------------------------------------------------------------
	Start up the watchdog timer so that if the interrupt never 
	comes back (because of broken hardware for example), then we have a
	way of returning control to the caller and cleaning up.  The watchdog
	handler function is specified in mid_initialize_DDF().

	Assign wakeup address for this timer to be the same for the e_sleep()
	which follows since we wish to resume control immediately following
	the sleep in the event that the timer pops.
	--------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 3,
                ("calling w_start with:  0x%x \n",
                (&current_ptr->watchdog_data.dog ) ));

        BUGLPR(dbg_midgetcondition, 5,
                ("     watchdog restart period = 0x%x seconds. \n",
                (current_ptr->watchdog_data.dog.restart ) ));

        BUGLPR(dbg_midgetcondition, 5,
                ("     watchdog prev field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.prev ) ));

        BUGLPR(dbg_midgetcondition, 5,
                ("     watchdog next field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.next ) ));

        BUGLPR(dbg_midgetcondition, 5,
                ("     watchdog count field    = 0x%x. \n",
                (current_ptr->watchdog_data.dog.count ) ));

        BUGLPR(dbg_midgetcondition, 5,
                ("     watchdog func field     = 0x%x. \n",
                (current_ptr->watchdog_data.dog.func ) ));


	current_ptr->watchdog_data.sleep_addr = &current_ptr->wakeup_address;


#ifdef  ENABLE_WATCHDOGS  /* Disable the watchdog timers.  They can cause   */
                          /* problems when the adapter is legitimately      */
                          /* taking more time than the watchdog is set for. */

	w_start( &( current_ptr->watchdog_data.dog ) );
#endif


	current_ptr->wakeup_address = EVENT_NULL;  /* NOTE: temporary */  

        BUGLPR(dbg_midgetcondition, BUGACT, ("wakeup_address=0x%x  i=%d\n",
                current_ptr->wakeup_address, i));
        BUGLPR(dbg_midgetcondition, BUGACT,
                ("&current_ptr.wakeup_address=0x%x\n ",
                &current_ptr->wakeup_address));
        BUGLPR(dbg_midgetcondition, BUGACT, ("SLEEPING...\n"));

        /* -----------------------------------------------------------------
           Since interrupts were enabled before the write to FIFO, we may have
           received the interrupt already.  If this is true, int_rcvd set,
           do not sleep.  If not set, set sleep_flg and then sleep.  The
           int_rcvd flag is set in the interrupt handler and the sleep_flg is
           tested there.
        -------------------------------------------------------------------*/

	if( !current_ptr->int_rcvd )
	{

		/*------------------------------------------------------------
		Put this process to sleep and wait to be awakened by this 
		function's interrupt handler, "mid_intr_getcondition".
		------------------------------------------------------------*/

		current_ptr->sleep_flg++;

	        MID_DD_TRACE_PARMS ( midgetcondition, 1, GET_CONDITION_PARMS, 
			ddf,
                	0,
                        correlator,
                        current_ptr->int_rcvd,
                        current_ptr->sleep_flg );


		/*------------------------------------------------------------
		  This "while" loop is simply to ensure that we actually sleep
		  at this point.  There have been occaissions where sleep has
		  not worked, so this forces "e_sleep" calls until the flag is
		  cleared in the interrupt handler.
		------------------------------------------------------------*/

                while (current_ptr->sleep_flg != 0x10)
                {

			e_sleep( &current_ptr->wakeup_address, EVENT_SHORT );

                    	if(current_ptr->sleep_flg != 0x10)
                    	{
                        	BUGLPR(dbg_midgetcondition, 1, 
					("Did not sleep\n"));
                    	}

                }


        	BUGLPR(dbg_midgetcondition, BUGACT, ("AWAKE!!!!\n"));
	}


#ifdef  ENABLE_WATCHDOGS  /* Disable the watchdog timers.  They can cause   */
                          /* problems when the adapter is legitimately      */
                          /* taking more time than the watchdog is set for. */

	/*--------------------------------------------------------------------
	We made it back successfully from the 
	adapter so turn off watchdog timer.
	--------------------------------------------------------------------*/

	w_stop( &( current_ptr->watchdog_data.dog) );
#endif


	/*---------------------------------------------------------------------
	Enable interrupts.  We must do this here to guarantee the integrity of 
	the user data structure.  If we were to page fault (because the user 
	data structure is on another page of virtual memory), then we would 
	panic or hang the system since there is no way to page in that 
	structure without interrupts enabled.  Another solution would be to 
	pin the user data structure and then write to it, but pinning is very 
	expensive.
	---------------------------------------------------------------------*/

        i_enable(old_interrupt_priority);


	/*---------------------------------------------------------------------
	When re-awakened, assign the two pieces of data retrieved from the 
	interrupt handler into the caller's data structure, ie, place status 
	word and caller's correlator value into the  "mid_getcondition_t"  
	structure.
	---------------------------------------------------------------------*/

	argp->status_word = current_ptr->ddf_getcondition.status_word;
	argp->correlator  = current_ptr->ddf_getcondition.correlator;

        BUGLPR(dbg_midgetcondition, 3, ("Passing back:\n" ));
        BUGLPR(dbg_midgetcondition, 3, ("   argp->status_word = 0x%x\n",
                argp->status_word ));
        BUGLPR(dbg_midgetcondition, 3, ("   argp->correlator = 0x%x\n",
                argp->correlator ));

	/*---------------------------------------------------------------------
	Disable interrupts.  Interrupts must be disabled before we clean up 
	the DDF data structures.  If an interrupt were to occur while changing 
	one of these structures, then another process could write to or read 
	from it, thereby corrupting the structure for one or both processes.
	---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 5, ("Disable interrupts.\n"));

        old_interrupt_priority = i_disable(PDEV_PRIORITY);



	/*---------------------------------------------------------------------
	Clean up any data structures used to make them 
	available for another getcondition call.
	---------------------------------------------------------------------*/

	current_ptr->correlator     = NULL;
	current_ptr->wakeup_address = EVENT_NULL;
	current_ptr->user_data      = NULL;



	/*---------------------------------------------------------------------
	Enable CPU interrupts.  Must re-enable interrupts before 
	returning to caller.
	---------------------------------------------------------------------*/

        BUGLPR(dbg_midgetcondition, 5, ("enable interrupts\n"));

        i_enable(old_interrupt_priority);


        MID_DD_EXIT_TRACE ( midgetcondition, 1, GET_CONDITION, ddf,
                0,
                argp->correlator,
                argp->status_word,
                0 );



	BUGLPR(dbg_midgetcondition, 1, ("Leaving mid_getcondition()\n"));

        return(0);

}
