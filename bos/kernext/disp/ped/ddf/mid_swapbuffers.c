static char sccsid[] = "@(#)09  1.13.1.11  src/bos/kernext/disp/ped/ddf/mid_swapbuffers.c, peddd, bos411, 9428A410j 3/31/94 21:32:21";
/*
 *   COMPONENT_NAME: PEDDD
 *
 *   FUNCTIONS: mid_swapbuffers
 *		
 *
 *   ORIGINS: 27
 *
 *   IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 *   combined with the aggregated modules for this product)
 *                    SOURCE MATERIALS
 *
 *   (C) COPYRIGHT International Business Machines Corp. 1992,1994
 *   All Rights Reserved
 *   US Government Users Restricted Rights - Use, duplication or
 *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */



#define Bool unsigned
#include <sys/types.h>          /* added for i_disable / i_enable       */
#include <sys/xmem.h>
#include <sys/rcm_win.h>
#include <sys/aixgsc.h>
#include <sys/rcm.h>
#include <sys/syspest.h>
#include <sys/errno.h>          /* added for i_disable / i_enable       */
#include <sys/intr.h>           /* added for i_disable / i_enable       */
#include <sys/sleep.h>          /* added to support e_sleep             */
#include <sys/malloc.h> 
#include "hw_dd_model.h"
#include "hw_regs_u.h"
#include "hw_typdefs.h"
#include "hw_macros.h"
#include "hw_FIFkern.h"
#include "mid_deferbuf.h"
#include "midddf.h"
#include "mid.h"
#include "midhwa.h"             /* BUS access definitions in here            */
#include "rcm_mac.h"            /* rcm-related macros.  Using FIND_GP        */
#include "mid_rcm_mac.h"	/* for PED GUARD and UNGUARD */
#include "midRC.h"              /* For get_WID request code                  */
#include "mid_dd_trace.h"
MID_MODULE (midswap);


#define SEARCHING 1		/* Values assigned to seek_status when ...  */
#define FOUND     0     	/* searching for a free structure element.  */



/*-------------------------------------------------------------------------
Define interrupt disable/enable value.  This value defined in middef.c   
-------------------------------------------------------------------------*/

#define PDEV_PRIORITY (pdev->devHead.display->interrupt_data.intr.priority-1)



BUGXDEF(dbg_middd);



/*--------------------------------------------------------------------------

			M I D _ S W A P B U F F E R S

Swap Buffers (mid_swapbuffers)


DESCRIPTION

Exchange the front and back frame buffers, in the normal case.

May also be called to set the display and/or draw buffers individually.


long swapbuffers( ddf, argp, correlator )
		midddf_t		*ddf;
		mid_swapbuffers_t 	*argp;
		ushort			correlator;


INPUT PARAMETERS:

ddf		Pointer to  "midddf_t"  structure.  This structure is part of
		the physical displays structure but is used only by the DDF
		functions.  The  "midddf_t"  structure holds pointers and data
		specific to each of the DDF functions and is used to 
		communicate this information from caller to interrupt handler 
		and back.

argp		Pointer to structure of type  "mid_swapbuffers_t".  This 
		structure holds update flags for draw selection and display
		selection of frame buffers, and frame buffer control flags.

correlator      A 16-bit value used to identify a particular call to this
                function.  This value is passed in by  "mid_ddf()"  and was
                generated by a call to "mid_get_correlator()".

    ***  NOTE:  This correlator is not used.  The correlator passed to the
    		device is generated internally by this routine. 



RETURN VALUES:

none.


PSEUDOCODE:

        FIND_GP()               - get process pointer

        make_cur_and_guard_domain()

        Disable CPU interrupts

        Get_WID()               - get window ID

        Search for data structure and initialize structure values:
                First search for structure used by current WID, and use it,
                Otherwise, search for unused structure

                Update data structures for use by interrupt handler

        if ( Window is obscured )    THIS TEST REMOVED FOR NOW     
        {
                MID_MARK_BUFFERS_SWAPPED( ... );
                unguard_domain()
                Enable CPU interrupts
                return;
        }

        Enable bus

        Calculate correlator

        MID_FrameBufferControl macro call       - swap buffers call

        Disable bus

        unguard_domain()

        Enable CPU interrupts

        ReleaseGuardedWID()

---------------------------------------------------------------------------*/



long mid_swapbuffers( pdev, argp, ddf_correlator )
gscDev 			*pdev;		/* device structure pointer	     */
mid_swapbuffers_t	*argp;		/* swapbuffers-specific ... in mid.h */
unsigned short		ddf_correlator;	/* uniqely identifies this call      */
{

	/*-----------------------------------------------------------------
	Set up the  "ddf"  pointer to point to the  "free_area"  within
	the physical displays structure (phys_displays).              
	                                                                
	Support of multiple displays requires that each display keep    
	its own copy of the  "phys_displays"  structure.  The free area
	pointer within this structure will point to the  "midddf_t"   
	structure for each display.  This structure allows DDF functions
	and their corresponding interrupt handlers to communicate.     

	ddf must be pre-defined since it is used in HWPDDFSetup
	-----------------------------------------------------------------*/

	midddf_t	*ddf = (midddf_t *) pdev->devHead.display->free_area;


	/*-------------------------------------------------------------
	Used to find last structure being used in linked list.
	-------------------------------------------------------------*/

	ddf_SBdata_t	*last_structure_ptr = NULL;




	int		old_interrupt_priority;	/*save old priority for enable*/
	short		i, j;
	int		index ;

	short		seek_status;	/* used when looking for free struct */
	ulong		uflags;		/* tmp var. for flags from user.     */
	ulong		fbcflags;	/* tmp var. for flags from user.     */

        rcmProcPtr      pproc;          /* ptr to "current" graphics process */
        rcx		*pRCX ;		/* ptr to "current" process's context */
	rcmWG		*WG_ptr;	/* ptr to current DI window geom     */
	midWG_t		*midWG;		/* ptr to DD window geometry    */

	ulong		swap_indicator; /* To swap, or not to swap, ...      */
	mid_wid_t	current_window_ID; /* WID of current process.        */

	ushort	correlator ; 		/* Real correlator sent to adapter */
	ulong	correlation_count ;	/* New correlation count to send */

	ulong	set_display_buffer_indicator; /* Is "set display" bit set?   */
	ulong	display_buffer_A_indicator;   /* Is buffer A to be displayed?*/
	ulong	display_buffer_B_indicator;   /* Is buffer B to be displayed?*/




        HWPDDFSetup;           /* gain access to hardware pointer            */

        MID_DD_ENTRY_TRACE (midswap, 2, SWAP_BUFFERS, ddf,
                0, ddf_correlator, argp->uflags, argp->fbcflags );

	BUGLPR(dbg_midswap, 1, ("Entering mid_swapbuffers()\n"));
	BUGLPR(dbg_midswap, 3, ("correlator=0x%x\n",ddf_correlator));


        /*--------------------------------------------------
	Quick check for invalid input values.
        --------------------------------------------------*/

	if ( ! argp->uflags )
        /*--------------------------------------------------
	if "uflags" is zero, then there is nothing to do.    
        --------------------------------------------------*/
	{
		BUGLPR(dbg_midswap, 1, 
			("Return with no action.  uflags=0x%x\n",argp->uflags));
		return(1);
	}

#ifdef ERRCHECK 	/* Enable this code only for debugging */

        /*--------------------------------------------------
	Set display request but frame buffer control flag is invalid
        --------------------------------------------------*/

	if ( (argp->uflags == 0x00004000) && 
		( (argp->fbcflags < 0x1000) || (argp->fbcflags >= 0x4000)) )
	{
		BUGLPR(dbg_midswap, 1, 
			("Draw request fbcflags out of range.  uflags=0x%x \n ",
			argp->uflags ));

		BUGLPR(dbg_midswap, 1, ("fbcflags=0x%x  \n", argp->fbcflags ));

		return(2);
	}
		

        /*--------------------------------------------------
	Set draw request but frame buffer control flag is invalid
        --------------------------------------------------*/

	if ( (argp->uflags == 0x00002000) && 
		( (argp->fbcflags != 0x0) && (argp->fbcflags != 0x10)) )
	{
		BUGLPR(dbg_midswap, 1, 
			("Draw request fbcflags out of range.  uflags=0x%x \n ",
			argp->uflags ));

		BUGLPR(dbg_midswap, 1, ("fbcflags=0x%x \n ", argp->fbcflags ));

		return(3);
	}

#endif
		

        /*---------------------------------------------------------------------
        Use FIND_GP macro to get process pointer of current process, ie,
        process which called us.  Then use this pointer to point to this
        process's current window geometry.
        ---------------------------------------------------------------------*/

        FIND_GP(pdev, pproc); 

	if ( !pproc )
	{
        	BUGLPR(dbg_midswap,0, ("  pproc pointer is NULL ! ! !  \n"));
		return(-1);
	}

        BUGLPR(dbg_midswap,5,
		("After FIND_GP call: pdev=0x%x, pproc=0x%x.\n",pdev,pproc));



	/*---------------------------------------------------------------------
	Set up pointer to current window geometry from
	the pointer to the current process.
        ---------------------------------------------------------------------*/

	pRCX = pproc-> pDomainCur[0] ; 

        if ( pRCX->flags & RCX_NULL )
        { 
    	    BUGLPR(dbg_midswap, 1, ("Exit midswap, NULL context\n\n") );      
    	    MID_DD_EXIT_TRACE (midswap, 2, SWAP_BUFFERS, ddf, pproc,
								pRCX, 0, 0);
    	    return (MID_RC_OK) ;
        }

	WG_ptr = pRCX-> pWG;


	/*---------------------------------------------------------------------
	Call the RCM function,  "make_cur_and_guard_domain()"  to signal to the 
	RCM that we must not have a context switch on this context until  
	"unguard_domain()" is called to release it.  This is done to 
	guarantee that when we send a structure element to the adapter via a 
	hardware macro call, that we send it into the FIFO of the correct 
	context.  If we did not secure the context, then a context switch could 
	occur after the macro call was started and before the structure element 
	has made it into the correct FIFO.
	---------------------------------------------------------------------*/

        BUGLPR(dbg_midswap, 3, ("Calling make_cur_and_guard_domain.\n"));

	MID_GUARD_AND_MAKE_CUR (pdev,pRCX) ; 

        BUGLPR(dbg_midswap, 3, 
		("Returned from make_cur_and_guard_domain call.\n"));


	/*---------------------------------------------------------------------
	Assign user-provided flag information to local variables.


	Possible values for "uflags" and "fbcflags" include:

	uflags    - 0x8000  swap only (ignore all other flag fields)
		  - 0x4000  set draw buffer
		  - 0x2000  set display buffer
		  - 0x0000  do nothing

	fbcflags  - 0x0     display buffer A
		  - 0x10    display buffer B
		  - 0x1000  draw buffer B
		  - 0x2000  draw buffer A
		  - 0x3000  draw buffers A and B

	---------------------------------------------------------------------*/

	uflags   = argp->uflags;
	fbcflags = argp->fbcflags;
	BUGLPR(dbg_midswap, 5, ("   uflags = 0x%x  fbcflags = 0x%x.\n", 
		uflags, fbcflags));



	/*---------------------------------------------------------------------
        Disable CPU interrupts to guarantee integrity of our linked list  
        structure.  If an interrupt were to occur while building this    
        structure, then part of the data for the first interrupt may be 
        lost.                                                          
	---------------------------------------------------------------------*/

	BUGLPR(dbg_midswap, 3, ("Disabling CPU interrupts - start.\n"));

        old_interrupt_priority = i_disable(PDEV_PRIORITY);

	BUGLPR(dbg_midswap, 3, ("Disabling CPU interrupts - done.\n"));




	/*---------------------------------------------------------------------
	6 types of swapbuffers calls:
		1)  caller actually wants to swap front and back buffers.
		2)  caller does not wish to swap buffers, but only
			       to set both buffers A and B to draw.
		3)  caller does not wish to swap buffers, but only
			       to set the draw buffer to buffer A.
		4)  caller does not wish to swap buffers, but only
			       to set the draw buffer to buffer B.
		5)  caller does not wish to swap buffers, but only
			       to set the display buffer to buffer A.
		6)  caller does not wish to swap buffers, but only
			       to set the display buffer to buffer B.
	
	NOTE:
	  Unlike other DDF entries, the correlator for swapbuffers is generated
	  internally.  

	  The swap buffers correlator contains several fields:
	    . a function ID, (type of frame buffer command--swap is just one 
		type, albeit the most common), 
	    . An index into the swap array, 
	    . A correlation count to allow us to know when the adapter has
	        caught up. 
	    . A bit indicating the current frame buffer.  This is used only if
		we do get out of sync with the adapter.

	---------------------------------------------------------------------*/


	/*---------------------------------------------------------------------

	swap_indicator
		If "1", then swap buffers, and ignore all other flags.

	set_draw_buffer_indicator
		If "1", this is a request to change the draw buffer.
	draw_buffer_A_indicator
		If "1", set draw buffer to A.
	draw_buffer_B_indicator
		If "1", set draw buffer to B.

	---------------------------------------------------------------------*/


	swap_indicator = (uflags & 0x00008000);                     /* bit 15 */

	set_display_buffer_indicator = (uflags & 0x00002000);       /* bit 13 */
	display_buffer_A_indicator   = ( !(fbcflags & 0x00000010) );/* bit  4 */
	display_buffer_B_indicator   = (  (fbcflags & 0x00000010) );/* bit  4 */




	BUGLPR(dbg_midswap, 4, ("\n swap_indicator=0x%x.\n\n", swap_indicator));

	BUGLPR(dbg_midswap, 4, ("set_display_buffer_indicator=0x%x.\n", 
		set_display_buffer_indicator ));
	BUGLPR(dbg_midswap, 4, ("display_buffer_A_indicator=0x%x.\n", 
		display_buffer_A_indicator));
	BUGLPR(dbg_midswap, 4, ("display_buffer_B_indicator=0x%x.\n\n", 
		display_buffer_B_indicator));




	if ( !( swap_indicator  || set_display_buffer_indicator ) )
	/*-------------------------------------------------------------------
	   This is either an invalid swapbuffers or just a draw buffer change.
	   The device driver ignores both, so treat them the same.
	-------------------------------------------------------------------*/
	{
                if ( WG_ptr )
                /* if we have a legitimate value for window geometry pointer */
                {
                        midWG = (midWG_t *)(WG_ptr->pPriv) ;
                        current_window_ID = midWG-> wid;
                }
		correlator =  MID_SWAP_DRAW_CHANGE_ONLY ;

		BUGLPR(dbg_midswap, 2, ("Draw only request \n"));

		/*------------------
		    enable bus
		------------------*/
		PIO_EXC_ON();

	}

	else    /* BEGIN real swap request */
	{

	/*------------------------------------
	Assign value for current window ID.
	------------------------------------*/

	/*---------------------------------------------------------------------
	Call "get_WID()" to secure a unique window ID.   The window ID is
	used to associate a particular Pixel Interpretation with a window
	geometry.  There are only 16
	hardware window ID's available on Pedernales.  Therefore, there can be
	only 16 possible pixel interpretations rendered correctly at any given
	time.  Since swapping buffers means a change of pixel interpretation,
	we must have a unique window ID for the window geometry for which
	frame buffers are being swapped.  A unique WID is necessary for
	swapping buffers because all window geometries with the same WID will
	be interpreted the same.  This will produce wrong results if the
	different window geometries have different pixel interpretations
	associated with them.

	If  "get_WID()"  cannot return a unique WID, then it puts this
	call to sleep until it does have a window ID for us.
	---------------------------------------------------------------------*/

	BUGLPR(dbg_midswap, 5, ("calling get_WID with:\n" ));
	BUGLPR(dbg_midswap, 5, ("         MID_GET_GUARDED_WID=0x%x\n",
		MID_GET_GUARDED_WID ));
	BUGLPR(dbg_midswap, 5, ("         pdev                =0x%x\n",
		pdev ));
	BUGLPR(dbg_midswap, 5, ("         WG_ptr              =0x%x\n",
		WG_ptr ));
	BUGLPR(dbg_midswap, 5, ("         pRCX = 0x%x\n", pRCX ));

	if ( WG_ptr )   
	/* if we have a legitimate value for window geometry pointer */
	{
		midWG = (midWG_t *)(WG_ptr->pPriv) ;
		midWG-> pRegion = WG_ptr-> wg.pClip ;

		get_WID(MID_GET_GUARDED_WID, pdev, WG_ptr, pRCX);

        	MID_DD_TRACE_PARMS (midswap, 1, SWAP_BUFFERS, ddf, midWG, 
			WG_ptr, MID_DDT_WID(midWG->wid), MID_DDT_PI(midWG));

		current_window_ID = midWG-> wid;

		BUGLPR(dbg_midswap, 5, ("Set current_window_ID to:  0x%x\n", 
			current_window_ID ));
	}
 
	else 	/* ptr not yet set.  */
	{

		/*------------------------------------------------------------
		If WG ptr is NULL, then set window_ID to a hardcoded value. We 
		do not want window_ID set to "MID_WID_NULL" if there is    
		actually swapping to be done since the next swap would come
		into this code, look at the WID field of this structure, and
		take it for itself, because the test for an un-used structure
		is a "MID_WID_NULL" in the window_ID field.  

		This value will be checked, and dealt with in the 
		interrupt handler.	
		------------------------------------------------------------*/

		current_window_ID = 0xD06F000D;

		BUGLPR(dbg_midswap, 5, 
			("Set current_window_ID to:  0x%x\n", 
			current_window_ID ));
	}



	/*--------------------------------------------------------------------
	Search for a swapbuffers data structure in the following manner:
		1)  First, search through swap structures until we find a 
		    match for the window ID of the current graphics process.
		2)  If no window ID match is found, start search over, this 
		    time looking for the first free structure. 
	--------------------------------------------------------------------*/

	seek_status = SEARCHING;


#define SWAP_LIST	ddf->ddf_data_swapbuffers_hold_list

	BUGLPR(dbg_midswap, 5, ("SEARCHING for free structure.\n"));

	for ( i=0; i<SB_ARY_SIZE; i++ )
	{

		last_structure_ptr = &(SWAP_LIST[i]) ;


		if (last_structure_ptr->window_ID == current_window_ID )
		/*--------------------------------------------------------
		This means that there is currently at least one swap 
		currently pending for this window ID.

		Increment the usage count, Note that the correlator passed 
		in is not used.  A correlator based on swap type is later
		generated.
		--------------------------------------------------------*/
		{
			BUGLPR(dbg_midswap, 5, 
			("Found structure used by this WID: i=%d WID=0x%x\n",
				i, current_window_ID));

			seek_status = FOUND;
			index = i ; 

			break;

		}
	}




	/*-----------------------------------------------------------------
	If we didn't find a structure already being used by a particular 
	window ID (graphics process), then find the first available.  
	Determine if there is a free element in the  "ddf_SWdata_t"  
	structure by checking for MID_WID_NULL in the window_ID field.
	-----------------------------------------------------------------*/

	i = 0;
	last_structure_ptr = &SWAP_LIST[0] ;

	while (seek_status == SEARCHING)
	{	

		if (last_structure_ptr->window_ID != MID_WID_NULL)
		/*------------------------------------------------------------
		If true, then structure element is occupied. Is it the last?
		------------------------------------------------------------*/
		{

#			if 0
        		MID_DD_TRACE_PARMS (midswap, 3, SWAP_BUFFERS_PARMS, ddf,
                				0, i, last_structure_ptr, 0);
#			endif

			i++;

			if (i >= SB_ARY_SIZE)
			/*----------------------------------------------------
			If true, we have run out of structures.  This should
			never happen since Get_WID() is supposed to put
			us to sleep when there are no more WIDs left.  We have
			16 structures and that is the max # of WIDs possible
			so by the time we get a WID, there should always be a
			structure available.
			----------------------------------------------------*/
			{


		        	MID_DD_TRACE_PARMS (midswap, 1, 
					SWAP_BUFFERS_PARMS, ddf,
                			0, correlator, current_window_ID, i );

				BUGLPR(dbg_midswap, 0, 
				("Out of structures!. i=0x%x MAX_WIDS=0x%x"));

				BUGLPR(dbg_midswap, 0, 
					("   THIS SHOULD NEVER HAPPEN !!!\n"));
				
				return(99);

			}


			last_structure_ptr = &SWAP_LIST[i];

		}


		else    /*  found a free structure */
		{

			BUGLPR(dbg_midswap, 5, 
				("Found a free structure. i=%d\n",i));
			seek_status = FOUND;

			/*----------------------------------------------------
			Copy the window ID and usage count into the 
			"ddf_SBdata_t"  structure.  The window ID will be
			deleted when the usage count for this window ID == 0.
			----------------------------------------------------*/

			BUGLPR(dbg_midswap, 5, 
				("Setting ddf_data values. \n",i));

			SWAP_LIST[i].window_ID = current_window_ID;


			index = i ; 


			/*----------------------------------------------------
			   Init the corr count 
			   This ensures that we start in sync.  After the 
			   last window finished using this entry, the counts
			   should have been equal, however, neither count is
			   initialized and this ensure we're in sync. 
			----------------------------------------------------*/

			SWAP_LIST[i].corr_recv = SWAP_LIST[i].corr_sent ; 


			/*----------------------------------------------------
			   Copy window's current frame buffer into WID entry.
			----------------------------------------------------*/

			if ( (midWG->pi.pieces.flags) & MID_USING_BACK_BUFFER)
			{ 
				SWAP_LIST[i].flags |= MID_USING_BACK_BUFFER ;
			} 
			else  /* currently using Frame Buffer A, init appro */
			{ 
				SWAP_LIST[i].flags &= ~MID_USING_BACK_BUFFER ;
			} 
		}
	}

	/*------------------
	    enable bus
	------------------*/
        PIO_EXC_ON();




	/*-------------------------------------------------------------------

	BEGIN building the correlator -- first the function code 

	Translate the uflags and fbcflags into a function code that will be
	packed in the correlator. 

	-------------------------------------------------------------------*/

	if ( swap_indicator )
	/*-------------------------------------------------------------------
	   This is a "swap" type swapbuffers call.  Precedence dictates that 
	   if bit 15 of uflags is "1", then ignore all other flag fields. 
	-------------------------------------------------------------------*/
	{
		correlator =  MID_SWAP_JUST_SWAP ;
		SWAP_LIST[index].flags ^= MID_USING_BACK_BUFFER ;
	}

	else
	{
		/*-----------------------------------------------------------
	   	    This is sort of a "swap" -- actually we are directly
	   	    setting the display buffer.  This part of the request must 
	   	    be remembered.  We may also be changing the draw buffer 
	   	    but the device driver does not care about this. 
		-----------------------------------------------------------*/
	
		correlator =  MID_SWAP_DISPLAY_BUFFER ;

		if (display_buffer_A_indicator)
		{
			SWAP_LIST[index].flags &= ~MID_USING_BACK_BUFFER ;
		}
		else 	/* request is to display frame buffer B */
		{
			SWAP_LIST[index].flags |= MID_USING_BACK_BUFFER ;
		}
	}


	/*-------------------------------------------------------------------
	    Calculate the current frame buffer.  (Note that this is the 
	    current buffer with respect to what has been SENT to the adapter). 
	-------------------------------------------------------------------*/

	if ( (SWAP_LIST[index].flags) & MID_USING_BACK_BUFFER)
	{ 
		correlator |= MID_SWAP_CORR_FRAME_BUFFER ; 
	} 
	/* else currently using Frame Buffer A */

	BUGLPR(dbg_midswap, 1, ("   with f/b = 0x%x \n", correlator));



	/*-------------------------------------------------------------------
	STILL building the correlator -- Now add the array index 

	The low-order 4 bits are the index into the array of swap structures
	and will be used by the interrupt handler to associate the interrupt
	with a swap table entry and hance a WID and window.
	-------------------------------------------------------------------*/
	correlator |= index  ; 

	BUGLPR(dbg_midswap, 1, ("   with index = 0x%x \n", correlator));




	/*-------------------------------------------------------------------
	STILL building the correlator -- Calculate the correlation code
	-------------------------------------------------------------------*/

	correlation_count = SWAP_LIST[index].corr_sent + 1 ;

	if ( correlation_count > MID_SWAP_CORR_CORRELATION_COUNT_MAX ) 
	{ 
		correlation_count = 0 ; 
	} 




	/*-------------------------------------------------------------------
	    SLEEP section -- CHECK if we are too far ahead of the adapter

	If the correlator "sent count" has wrapped back on the received count, 
	then we must wait (sleep) for the adapter to catch up).

	Note that we keep sleeping until the interrupt handler has turned off
	the SWAP_SLEEPING flag.  This protects us from spurious wakeups.

	Note that we unguard the domain whilst sleeping. 
	-------------------------------------------------------------------*/

	i=(correlation_count > SWAP_LIST[index].corr_recv) ? correlation_count:
		correlation_count + MID_SWAP_CORR_CORRELATION_COUNT_MAX;
	if( i > (SWAP_LIST[index].corr_recv + 
			MID_SWAP_CORR_CORRELATION_COUNT_WAKEUP) )
		
	{ 
		SWAP_LIST[index].flags |= 
				(SWAP_SLEEPING | SWAP_STILL_USING_WID) ;
		SWAP_LIST[index].sleep_word = EVENT_NULL ;
		
        	MID_DD_EXIT_TRACE (midswap, 1, SWAP_BUFFERS, ddf, 0, 
				(SWAP_LIST[index].corr_recv)<<16 ||
				(SWAP_LIST[index].flags),
				SWAP_LIST[index].sleep_word, 0xF1 );

#if 0
		brkpoint (&SWAP_LIST[index], 
				correlation_count, 
				SWAP_LIST[index].corr_recv,
				SWAP_LIST[index].flags,
				SWAP_LIST[index].sleep_word ) ;
#endif

		MID_UNGUARD_DOMAIN (pdev, pRCX) ; 


		while ( SWAP_LIST[index].flags & SWAP_SLEEPING )
		{
			e_sleep ( &(SWAP_LIST[index].sleep_word), 0) ;
		} 


		/*----------------------------------------------------------
		    We are awake again 
			
		    Re-enable CPU interrupts, and reacquire the domain.
		    Then disable interrupts before resetting the
		    "still using WID" flag. 
		----------------------------------------------------------*/

        	i_enable(old_interrupt_priority);

		MID_GUARD_AND_MAKE_CUR (pdev, pRCX) ; 
        	old_interrupt_priority = i_disable(PDEV_PRIORITY);

		SWAP_LIST[index].flags &= ~SWAP_STILL_USING_WID ;
	} 






	/*----------------------------------------------------------
	    Update the SENT correlator 
		
	    Before re-enabling interrupt, update the sent correlator.
	    This prevents the interrupt handler from releasing our
	    WID before we send the Frame Buffer Control.
	    Also start the watchdog timer. 
	----------------------------------------------------------*/

	SWAP_LIST[index].corr_sent = correlation_count ;

	correlator += (correlation_count << 8) ; 

	BUGLPR(dbg_midswap, 1, ("   with corr_count = 0x%x \n", correlator));



#define ENABLE_WATCHDOGS  
#ifdef  ENABLE_WATCHDOGS  /* Disable the watchdog timers.  They can cause   */
                          /* problems when the adapter is legitimately      */
                          /* taking more time than the watchdog is set for. */


	/*----------------------------------------------------------
	    (Re)Start the watchdog timer
		
	    We start the watchdog timer before enabling interrupts.  
	    This prevents the interrupt handler from stopping it  
	    before we start it.  Also, note that stops will not
	    necessarily match starts one-to-one.  We expect to get
	    a lot more starts than stops.  The only critical start
	    and stop is the last one (in any sequence).
	----------------------------------------------------------*/
	w_start( &(SWAP_LIST[index].watch.dog )) ;
#endif

	}       /* END real swap request */


	/*------------------
	Re-enable CPU interrupts.
	------------------*/

        i_enable(old_interrupt_priority);

	/*-------------------------------------------------------------------
	Make MID_FrameBufferControl macro call to initiate the buffer swap.  
	The following are passed as arguments to the MID_FrameBufferControl 
	call:

	  -  correlator is used to associate this  "mid_swapbuffers"  call with 
	     this set of data.  
	  -  "uflags"  are the update flags for draw and display selection 
	     passed in by the caller.
	  -  "fbcflags"  are the frame buffer control flags, also passed in 
	     by the caller.
	-------------------------------------------------------------------*/

        MID_DD_TRACE_PARMS (midswap, 1, SWAP_BUFFERS_PARMS, ddf,
                0, correlator, current_window_ID, index);

	BUGLPR(dbg_midswap, 1, 
		("Calling MID_FrameBufferControl with 0x%x 0x%x 0x%x\n", 
		correlator, uflags, fbcflags));

	MID_FrameBufferControl (correlator, uflags, fbcflags);

	BUGLPR(dbg_midswap, 3, 
		("After MID_FrameBufferControl with 0x%x\n", correlator));



	/*------------------
	   disable bus
	------------------*/
        PIO_EXC_OFF();





	/*-------------------------------------------------------------------
	Call  "unguard_domain()".  This indicates to the RCM that this 
	context is now candidate for a context switch.  
	-------------------------------------------------------------------*/

        BUGLPR(dbg_midswap, 3, ("Calling unguard_domain.\n"));

	MID_UNGUARD_DOMAIN (pdev, pRCX) ; 

        BUGLPR(dbg_midswap, 3, ("Returned from unguard_domain call.\n"));



	BUGLPR(dbg_midswap, 1, ("Leaving  mid_swapbuffers()\n"));

        if ( WG_ptr )
        {
                MID_DD_EXIT_TRACE (midswap, 1, SWAP_BUFFERS, ddf, midWG, WG_ptr,
                MID_DDT_WID(midWG->wid), MID_DDT_PI(midWG) | 0xF0);
        }
        else
        {
                MID_DD_EXIT_TRACE (midswap, 1, SWAP_BUFFERS, ddf, NULL, WG_ptr,
                NULL, 0xF0);
        }
	return(0);

}	/* end of mid_swapbuffers()  */
