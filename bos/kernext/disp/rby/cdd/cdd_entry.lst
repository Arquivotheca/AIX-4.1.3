C Set ++ for AIX Compiler Version 3.1 --- ../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c 06/21/95 11:51:07

>>>>> SOURCE SECTION <<<<<

        1 | static char sccsid[] = "@(#)12  1.2  src/bos/kernext/disp/rby/cdd/cdd_entry.c, vddrby, bos411, 9428A410j 3/18/94 17:24:16";
        2 | /*
        3 |  * COMPONENT_NAME: VDDRBY
        4 |  *
        5 |  * FUNCTIONS: cdd_entry
        6 |  *
        7 |  * ORIGINS: 27
        8 |  *
        9 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
       10 |  * combined with the aggregated modules for this product)
       11 |  *                  SOURCE MATERIALS
       12 |  * (C) COPYRIGHT International Business Machines Corp. 1992
       13 |  * All Rights Reserved
       14 |  *
       15 |  * US Government Users Restricted Rights - Use, duplication or
       16 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
       17 |  */
       18 | 
       19 | /*------------------------------------------------------
       20 | |
       21 | |       Define a symbol needed by <sys/aixfont.h>
       22 | |
       23 | |------------------------------------------------------*/
       24 | 
       25 | #define Bool unsigned
       26 | 
       27 | /*-------------------------------------------------------
       28 | |
       29 | |       Define the standard include files used by
       30 | |       these various functions
       31 | |
       32 | |--------------------------------------------------------*/
       33 | 
       34 | #include <sys/types.h>
       35 | #include <sys/aixfont.h>
       36 | #include <lft.h>
       37 | #include <sys/dir.h>                    /* needed by ccm_dds.h          */
       38 | #include <sys/mdio.h>                   /* needed by cdd_macros.h       */
       39 | #include <sys/file.h>                   /* needed by ccm.h              */
       40 | #include <sys/lockl.h>                  /* needed by cdd.h              */
       41 | #include <sys/intr.h>                   /* needed by vt.h               */
       42 | 
       43 | /*---------------------------------------------------------------
       44 | |
       45 | |       Define common HFT subsystem include files which are
       46 | |       required by or which enable this code
       47 | |
       48 | | NOTE: The order of these is important
       49 | |
       50 | |---------------------------------------------------------------*/
       51 | /*
       52 | #include "keytab.h"   
       53 | #include "vt.h"
       54 | */
       55 | 
       56 | /*----------------------------------------------------------
       57 | |
       58 | |       Define the common character mode include files
       59 | |       which define the special structure used with the
       60 | |       common character mode programming interfaces
       61 | |
       62 | | NOTE: The order of these is important! CDD before CCM
       63 | |
       64 | |-----------------------------------------------------------*/
       65 | 
       66 | #include "cdd.h"
       67 | #include "cdd_macros.h"
       68 | 
       69 | #include "rby_cdd_hw_defs.h"
       70 | 
       71 | /*-----------------------------------------------------------------------
       72 | |
       73 | |       After all of the header files have been included, but before
       74 | |       we define the functions of interest, we need to include the
       75 | |       source code for the cdd subroutines.  This code needs to be
       76 | |       included, because everything must be static and static requires
       77 | |       it all to be compiled at the same time into one object.
       78 | |       The subroutines must be included after the header files,
       79 | |       because they depend on the typedefs and so on that are in the
       80 | |       header files.  The subroutines are included before the entry
       81 | |       routine definition, as an aid to readability.
       82 | |
       83 | |-------------------------------------------------------------------------*/
       84 | 
       85 | /*
       86 | #include        "cdd_subrs.c"
       87 | #include        "cdd_init.c"
       88 | #include        "cdd_enable.c"
       89 | #include        "cdd_set_POS.c"
       90 | #include        "cdd_load_ucode.c"
       91 | #include        "cdd_qvpd.c"
       92 | #include        "cdd_blit.c"
       93 | 
       94 |  * NAME: cdd_entry
       95 |  *
       96 |  * FUNCTION:  The CDD routines provide the device dependent functionality
       97 |  *            needed to interface to the graphics adapter.  All hardware
       98 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
       99 |  *            routines do not need device specific code to accomplish the common
      100 |  *            character mode functionality.
      101 |  *
      102 |  *            The input parameter is the pointer to the cdd_header_t which
      103 |  *            has pointers to the information that is needed to accomplish.
      104 |  *
      105 |  *            If information is to be written to the adapter, the data is pointed
      106 |  *            to by the pDataIn pointer and the various cdd svcs functions are used.
      107 |  *
      108 |  *
      109 |  *   WARNING: this routine cannot have a static char SCCS id, because having
      110 |  *   predefined strings will force this routine to require the use of RS/6000
      111 |  *   register R2, which points to the TOC !!!
      112 |  *
      113 |  *
      114 |  * EXECUTION ENVIRONMENT:
      115 |  *      This code is pageable.  It runs in all CDD environments:
      116 |  *              - Kernel device driver
      117 |  *              - AIX process (config method)
      118 |  *              - System IPL ROS
      119 |  *
      120 |  * (NOTES:)
      121 |  *      Called from various routines in the Common Character Mode VDD
      122 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
      123 |  *
      124 |  *      Because of the design rules on building CDD modules, all of the
      125 |  *      functions required by the CDD must be #included-ed into this routine.
      126 |  *      There can be no external considerations.
      127 |  *
      128 |  *      This routine writes directly to the hardware.  It may make use
      129 |  *      of some standard CDD utilities found in "cdd_subrs.h" in the
      130 |  *      same source directory as this routine.
      131 |  *
      132 |  *      All I/O accomplished by this routine is done through the CDD_svcs
      133 |  *      routines as defined in the cdd_macros.h header file.
      134 |  *      These routines are accessed via a pointer reference to the functions:
      135 |  *      busgetc, busgets, busgetl, busputc, busputs, and busputl.
      136 |  *
      137 |  *
      138 |  * (RECOVERY OPERATION:) None
      139 |  *
      140 |  * (DATA STRUCTURES:) cdd_header_t * cdd
      141 |  *
      142 |  * RETURNS:
      143 |  *      an error code of type "int" with value 0 if OK, or with
      144 |  *      nonzero error codes if not.  The error return values are stored
      145 |  *      in the cdd.h header file in the appropriate member(s).
      146 |  */
      147 | int cdd_entry( cdd_header_t * cdd )
      148 | 
      149 | {
      150 | 
      151 |         /*----------------------------------------
      152 |         | References to local data
      153 |         | must NOT refer to global variables outside
      154 |         | the scope of the function!!
      155 |         |-----------------------------------------*/
      156 | 
      157 |           int    rc;
      158 |           ulong  cmd;
      159 | 
      160 | /*-----------------------------------------------------
      161 | |
      162 | |       START OF SOURCE CODE
      163 | |
      164 | |------------------------------------------------------*/
      165 | #ifdef RBYCDD
      166 | printf("cdd_entry: cdd = %x\n",cdd);
      167 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 167.8: 1506-234 (W) Expecting a newline character on #endif directive.
      168 |         /*-------------------------------------------------
      169 |         |
      170 |         |  First test that the supplied pointer is valid
      171 |         |
      172 |         |----------------------------------------------------*/
      173 | 
      174 |         if  ( cdd == NULL )
      174 +         if  ( cdd == 0 )
      175 |                 return( E_CDD_HDR );
      176 | 
      177 |         /*-------------------------------------------------
      178 |         |
      179 |         |  Test that a valid command structure is present
      180 |         |
      181 |         |----------------------------------------------------*/
      182 | 
      183 |         if (( CDD_command( cdd ) == NULL ))
      183 +         if (( ((cdd)->p_cdd_command_attrs) == 0 ))
      184 |                 return( E_CDD_HDR );
      185 | 
      186 |         /*------------------------------------------------------
      187 |         |
      188 |         |  Branch to the correct function based on the command
      189 |         |  parameter that was sent.
      190 |         |
      191 |         |-------------------------------------------------------*/
      192 | 
      193 |         cmd = CDD_cmd( cdd );
      193 +         cmd = (((cdd)->p_cdd_command_attrs)->command);
      194 | 
      195 |         switch (cmd)
      196 |         {
      197 |                 /*--------------------------
      198 |                 | put blit first since it is
      199 |                 | called the most
      200 |                 |--------------------------*/
      201 | 
      202 |         case CDD_CMD_BLIT:
      203 |                 rc = cdd_blit( cdd );
      204 |                 break;
      205 | 
      206 |         case CDD_CMD_INIT:
      207 |                 rc = cdd_init( cdd );
      208 |                 break;
      209 | 
      210 |         case CDD_CMD_ENABLE:
      211 |                 rc = cdd_enable( cdd );
      212 |                 break;
      213 | 
      214 |         case CDD_CMD_DISABLE:
      215 |                 rc = cdd_disable( cdd );
      216 |                 break;
      217 | 
      218 |         case CDD_CMD_LOAD_UCODE:
      219 |                 rc = cdd_load_ucode( cdd );
      220 |                 break;
      221 | 
      222 |         case CDD_CMD_SET_POS:
      223 |                 rc = cdd_set_POS( cdd );
      224 |                 break;
      225 | 
      226 |         case CDD_CMD_QVPD:
      227 |                 rc = cdd_qvpd( cdd );
      228 |                 break;
      229 | 
      230 |         default:
      231 |                 rc = E_CDD_BAD_CMD;
      232 |                 break;
      233 |         }
      234 | #ifdef RBYCDD
      235 | printf("cdd_entry:  exit\n");
      236 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 236.8: 1506-234 (W) Expecting a newline character on #endif directive.
      237 | 
      238 |         return( rc );
      239 | 
      240 | }
      241 | 
      242 | /*
      243 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
      244 |  *
      245 |  * FUNCTIONS: cdd_enable, cdd_disable
      246 |  *
      247 |  * ORIGINS: 27
      248 |  *
      249 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
      250 |  * combined with the aggregated modules for this product)
      251 |  * OBJECT CODE ONLY SOURCE MATERIALS
      252 |  * (C) COPYRIGHT International Business Machines Corp. 1992
      253 |  * All Rights Reserved
      254 |  *
      255 |  * US Government Users Restricted Rights - Use, duplication or
      256 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
      257 |  */
      258 | 
      259 | /*
      260 |  * NAME: cdd_enable
      261 |  *
      262 |  * FUNCTION:  The CDD routines provide the device dependent functionality
      263 |  *            needed to interface to the graphics adapter.  All hardware
      264 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
      265 |  *            routines do not need device specific code to accomplish the common
      266 |  *            character mode functionality.
      267 |  *
      268 |  *            The input parameter is the pointer to the cdd_header_t which
      269 |  *            has pointers to the information that is needed to accomplish.
      270 |  *
      271 |  *            Holds the device driver entry point of the
      272 |  *            Common Character Mode device specific kernel load extension
      273 |  *            for setPOS.
      274 |  *
      275 |  *            The enable and disable functions, for Microchannel adapters,
      276 |  *            supply front ends to POS register 2 bit 0.  That is, these
      277 |  *            routines simply place the adapter onto the bus and take it
      278 |  *            off the bus.  For other types of bus, there may be additional
      279 |  *            function required.
      280 |  *
      281 |  *            A disabled adapter should never respond to any signals on the
      282 |  *            bus.  It should be logically inert.  It should only occupy
      283 |  *            volume and consume power, and the latter is optional.
      284 |  *
      285 |  *            An enabled adapter is capable of responding to addresses on
      286 |  *            the bus.  However, "enabled" does NOT mean configured.  The
      287 |  *            setPOS routines must still be run, as well as the load ucode.
      288 |  *
      289 |  *            This kernel extension is an AIX load module
      290 |  *            which is compiled under special programming constraints.
      291 |  *            It is designed in particular to not have any programming
      292 |  *            constructs which cause the XLC compiler to produce
      293 |  *            references to the XCOFF TOC.  By doing this, the load
      294 |  *            module can be loaded both into the AIX kernel for the
      295 |  *            CCM VDD's use, and into the AIX System Boot ROS for
      296 |  *            similar use during boot time.
      297 |  *
      298 |  *            The enable and disable routines do not change the hardware
      299 |  *            state stored in the DDF.
      300 |  *
      301 |  *            If information is to be written to the adapter, the data is pointed
      302 |  *            to by the pDataIn pointer and the various cdd svcs functions are used.
      303 |  *
      304 |  *      NOTES:
      305 |  *
      306 |  *            1. This function must define RBY_BASE_PTR since the
      307 |  *               "hw_model.h" is included with the symbol RBY_RMS
      308 |  *                defined, and since such an action allows the code
      309 |  *                to supply the base address of the adapter.
      310 |  *
      311 |  *            2. This function does not handle exceptions.  Instead,
      312 |  *              it passes them back to the caller for handling.
      313 |  *
      314 |  *           Because the adapter may be configured in a system in which the
      315 |  *           IPL ROS has already set up the hardware, the cdd_flags
      316 |  *           must be tested.
      317 |  *
      318 |  *   WARNING: this routine cannot have a static char SCCS id, because having
      319 |  *   predefined strings will force this routine to require the use of RS/6000
      320 |  *   register R2, which points to the TOC !!!
      321 |  *
      322 |  *
      323 |  * EXECUTION ENVIRONMENT:
      324 |  *      This code is pageable.  It runs in all CDD environments:
      325 |  *              - Kernel device driver
      326 |  *              - AIX process (config method)
      327 |  *              - System IPL ROS
      328 |  *
      329 |  * (NOTES:)
      330 |  *      Called from various routines in the Common Character Mode VDD
      331 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
      332 |  *
      333 |  *      This routine writes directly to the hardware.  It may make use
      334 |  *      of some standard CDD utilities found in "cdd_subrs.h" in the
      335 |  *      same source directory as this routine.
      336 |  *
      337 |  *      All I/O accomplished by this routine is done through the CDD_svcs
      338 |  *      routines as defined in the cdd_macros.h header file.
      339 |  *      These routines are accessed via a pointer reference to the functions:
      340 |  *      busgetc, busgets, busgetl, busputc, busputs, and busputl.
      341 |  *
      342 |  *
      343 |  * (RECOVERY OPERATION:) None
      344 |  *
      345 |  * (DATA STRUCTURES:) cdd_header_t * cdd
      346 |  *
      347 |  * RETURNS:
      348 |  *      an error code of type "int" with value 0 if OK, or with
      349 |  *      nonzero error codes if not.  The error return values are stored
      350 |  *      in the cdd.h header file in the appropriate member(s).
      351 |  */
      352 | 
      353 | static int cdd_enable( cdd_header_t * cdd )
      354 | {
      355 | 
      356 |                   int   rc;
      357 | 
      358 |                   rby_cdd_ddf *  ddf;
      359 |                   rby_cdd_ddf * RBY_ddf;
      360 |                   uchar  pos_val;
      361 | 
      362 | /*-----------------------------------------------------
      363 | |
      364 | |       START OF SOURCE CODE
      365 | |
      366 | |------------------------------------------------------*/
      367 | 
      368 |         /*-------------------------------------------------
      369 |         |
      370 |         |  Test the input parameters to make sure that
      371 |         |  we received the right kind of command
      372 |         |
      373 |         |----------------------------------------------------*/
      374 | #ifdef RBYCDD
      375 |  printf("cdd_enable entered:\n");
      376 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 376.8: 1506-234 (W) Expecting a newline character on #endif directive.
      377 | 
      378 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
      379 | 
      380 |         if ( rc != E_CDD_PASS ) return (rc);
      381 | 
      382 |         /*------------------------------------------------------
      383 |         |
      384 |         |  There are no inputs or outputs from this command.
      385 |         |  But, we do need to check the device attributes
      386 |         |
      387 |         |-------------------------------------------------------*/
      388 | 
      389 |         /*---------------------------------------------
      390 |         | make sure there is a valid segment and address range
      391 |         |---------------------------------------------*/
      392 | 
      393 |         if ( ( CDD_busmem_base( cdd, 0 ) == 0 )  ||
      393 +         if ( ( (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]) == 0 )  ||
      394 |               ( CDD_busmem_len( cdd, 0 ) == 0 )  ||
      394 +               ( (((cdd)->p_cdd_device_attrs)->address_space_length[(0)]) == 0 )  ||
      395 |               ( CDD_busmem_seg( cdd ) == 0 )     ||
      395 +               ( (((cdd)->p_cdd_device_attrs)->busmem_att) == 0 )     ||
      396 |               ( CDD_iocc_seg( cdd ) == 0 )       ||
      396 +               ( (((cdd)->p_cdd_device_attrs)->iocc_att) == 0 )       ||
      397 |               ( CDD_iocc_base( cdd ) == 0 )      ||
      397 +               ( (((cdd)->p_cdd_device_attrs)->iocc_addr_base) == 0 )      ||
      398 |               ( !CDD_ADDR_IS_BUS_MEM( CDD_busmem_seg( cdd ),
      398 +               ( !
      399 |                      CDD_busmem_base( cdd, 0 ) ) ) ||
      399 + ( ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_IOCC_SELECT ) == 0 ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_BUSx ) == CDD_BUSx ) && (( ((((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)])) & CDD_BUS_IO_MASK) != 0 ) ) ) ||
      400 |               ( !CDD_ADDR_IS_IOCC(    CDD_iocc_seg( cdd ),
      400 +               ( !
      401 |                                  CDD_iocc_base( cdd ) ) ) )
      401 + ( ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_IOCC_SELECT ) == CDD_IOCC_SELECT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_BUSx ) == CDD_BUSx ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) >= CDD_IOCC_BASE ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) < CDD_IOCC_TOP ) ) ) )
      402 |         {
      403 | 
      404 |                 return( CDD_rc( cdd ) = E_CDD_DEV_ARGS );
      404 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_DEV_ARGS );
      405 |         }
      406 | 
      407 |         /*-----------------------------------------------
      408 |         |  Passing through to here means we think we have
      409 |         |  a valid command and valid cdd support structures.
      410 |         |
      411 |         | Initialize the data that were defined within this
      412 |         | function
      413 |         |
      414 |         |------------------------------------------------*/
      415 | 
      416 |         ddf                = ( rby_cdd_ddf * )  CDD_ddf( cdd );
      416 +         ddf                = ( rby_cdd_ddf * )  (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
      417 |         RBY_ddf            = ddf;
      418 | 
      419 |         ddf->RBY_rc        = 0;
      420 |         ddf->RBY_cdd       = cdd;
      421 |         ddf->RBY_seg       = CDD_busmem_seg( cdd );
      421 +         ddf->RBY_seg       = (((cdd)->p_cdd_device_attrs)->busmem_att);
      422 |         ddf->RBY_base      = CDD_busmem_base( cdd , 0 );
      422 +         ddf->RBY_base      = (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]);
      423 |         ddf->RBY_iocc_seg  = CDD_iocc_seg( cdd );
      423 +         ddf->RBY_iocc_seg  = (((cdd)->p_cdd_device_attrs)->iocc_att);
      424 |         ddf->RBY_iocc_base = CDD_iocc_base( cdd );
      424 +         ddf->RBY_iocc_base = (((cdd)->p_cdd_device_attrs)->iocc_addr_base);
      425 |         ddf->RBY_slot      = CDD_slot( cdd );
      425 +         ddf->RBY_slot      = (((cdd)->p_cdd_device_attrs)->slot);
      426 | 
      427 |         /*-------------------------------------------------
      428 |         |
      429 |         | Retrieve POS 2 from the bus, in preparation of enabling
      430 |         | the adapter.  We will write this value back to the bus
      431 |         | with the enable bit added
      432 |         |
      433 |         |------------------------------------------------------*/
      434 | 
      435 |         pos_val = 0;
      436 |         RBY_GET_POS( 2 , pos_val );
      436 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),(&(pos_val))); };
      437 |         RETURN_ON_EXCEPTION;
      437 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
      438 | 
      439 |         RBY_PUT_POS( 2 , ( pos_val | POS2_ENABLE ) );
      439 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),((( pos_val | 0x01 )))); };
      440 |         RETURN_ON_EXCEPTION;
      440 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
      441 | 
      442 |         /*------------------------------------------------------------
      443 |         |
      444 |         | if we fall through to here, then the POS 2 register
      445 |         | is set, and we can assume that the adapter is ready
      446 |         | to respond to the MicroChannel signals.
      447 |         |
      448 |         |------------------------------------------------------------*/
      449 | 
      450 |         CDD_exception( cdd )            = 0;
      450 +         (((cdd)->p_cdd_device_attrs)->exception_code)            = 0;
      451 | 
      452 |         CDD_rc( cdd )                   = E_CDD_PASS;
      452 +         (((cdd)->p_cdd_command_attrs)->rc_out)                   = E_CDD_PASS;
      453 | 
      454 | #ifdef RBYCDD
      455 |  printf("cdd_enable exited:\n");
      456 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 456.8: 1506-234 (W) Expecting a newline character on #endif directive.
      457 |         return( E_CDD_PASS );
      458 | 
      459 | }
      460 | 
      461 | /*
      462 |  * NAME: cdd_disable
      463 |  *
      464 |  * FUNCTION:  The CDD routines provide the device dependent functionality
      465 |  *            needed to interface to the graphics adapter.  All hardware
      466 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
      467 |  *            routines do not need device specific code to accomplish the common
      468 |  *            character mode functionality.
      469 |  *
      470 |  *            The input parameter is the pointer to the cdd_header_t which
      471 |  *            has pointers to the information that is needed to accomplish.
      472 |  *
      473 |  *            Holds the device driver entry point of the
      474 |  *            Common Character Mode device specific kernel load extension
      475 |  *            for setPOS.
      476 |  *
      477 |  *            The enable and disable functions, for Microchannel adapters,
      478 |  *            supply front ends to POS register 2 bit 0.  That is, these
      479 |  *            routines simply place the adapter onto the bus and take it
      480 |  *            off the bus.  For other types of bus, there may be additional
      481 |  *            function required.
      482 |  *
      483 |  *            A disabled adapter should never respond to any signals on the
      484 |  *            bus.  It should be logically inert.  It should only occupy
      485 |  *            volume and consume power, and the latter is optional.
      486 |  *
      487 |  *            An enabled adapter is capable of responding to addresses on
      488 |  *            the bus.  However, "enabled" does NOT mean configured.  The
      489 |  *            setPOS routines must still be run, as well as the load ucode.
      490 |  *
      491 |  *            This kernel extension is an AIX load module
      492 |  *            which is compiled under special programming constraints.
      493 |  *            It is designed in particular to not have any programming
      494 |  *            constructs which cause the XLC compiler to produce
      495 |  *            references to the XCOFF TOC.  By doing this, the load
      496 |  *            module can be loaded both into the AIX kernel for the
      497 |  *            CCM VDD's use, and into the AIX System Boot ROS for
      498 |  *            similar use during boot time.
      499 |  *
      500 |  *            The enable and disable routines do not change the hardware
      501 |  *            state stored in the DDF.
      502 |  *
      503 |  *            If information is to be written to the adapter, the data is pointed
      504 |  *            to by the pDataIn pointer and the various cdd svcs functions are used.
      505 |  *
      506 |  *      NOTES:
      507 |  *
      508 |  *            1. This function must define RBY_BASE_PTR since the
      509 |  *               "hw_model.h" is included with the symbol RBY_RMS
      510 |  *                defined, and since such an action allows the code
      511 |  *                to supply the base address of the adapter.
      512 |  *
      513 |  *            2. This function does not handle exceptions.  Instead,
      514 |  *              it passes them back to the caller for handling.
      515 |  *
      516 |  *           Because the adapter may be configured in a system in which the
      517 |  *           IPL ROS has already set up the hardware, the cdd_flags
      518 |  *           must be tested.
      519 |  *
      520 |  *   WARNING: this routine cannot have a static char SCCS id, because having
      521 |  *   predefined strings will force this routine to require the use of RS/6000
      522 |  *   register R2, which points to the TOC !!!
      523 |  *
      524 |  *
      525 |  * EXECUTION ENVIRONMENT:
      526 |  *      This code is pageable.  It runs in all CDD environments:
      527 |  *              - Kernel device driver
      528 |  *              - AIX process (config method)
      529 |  *              - System IPL ROS
      530 |  *
      531 |  * (NOTES:)
      532 |  *      Called from various routines in the Common Character Mode VDD
      533 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
      534 |  *
      535 |  *      This routine writes directly to the hardware.  It may make use
      536 |  *      of some standard CDD utilities found in "cdd_subrs.h" in the
      537 |  *      same source directory as this routine.
      538 |  *
      539 |  *      All I/O accomplished by this routine is done through the CDD_svcs
      540 |  *      routines as defined in the cdd_macros.h header file.
      541 |  *      These routines are accessed via a pointer reference to the functions:
      542 |  *      busgetc, busgets, busgetl, busputc, busputs, and busputl.
      543 |  *
      544 |  *
      545 |  * (RECOVERY OPERATION:) None
      546 |  *
      547 |  * (DATA STRUCTURES:) cdd_header_t * cdd
      548 |  *
      549 |  * RETURNS:
      550 |  *      an error code of type "int" with value 0 if OK, or with
      551 |  *      nonzero error codes if not.  The error return values are stored
      552 |  *      in the cdd.h header file in the appropriate member(s).
      553 |  */
      554 | 
      555 | static int cdd_disable( cdd_header_t * cdd )
      556 | {
      557 | 
      558 |                    int   rc;
      559 | 
      560 |                    rby_cdd_ddf *  ddf;
      561 |                    rby_cdd_ddf *  RBY_ddf;
      562 |                    uchar  pos_val;
      563 | 
      564 | /*-----------------------------------------------------
      565 | |
      566 | |       START OF SOURCE CODE
      567 | |
      568 | |------------------------------------------------------*/
      569 | 
      570 |         /*-------------------------------------------------
      571 |         |
      572 |         |  Test the input parameters to make sure that
      573 |         |  we received the right kind of command
      574 |         |
      575 |         |----------------------------------------------------*/
      576 | #ifdef RBYCDD
      577 |  printf("cdd_disable entered:\n");
      578 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 578.8: 1506-234 (W) Expecting a newline character on #endif directive.
      579 | 
      580 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
      581 | 
      582 |         if ( rc != E_CDD_PASS ) return (rc);
      583 | 
      584 |         /*------------------------------------------------------
      585 |         |
      586 |         |  There are no inputs or outputs from this command.
      587 |         |  But, we do need to check the device attributes
      588 |         |
      589 |         |-------------------------------------------------------*/
      590 | 
      591 |         /*---------------------------------------------
      592 |         | make sure there is a valid segment and address range
      593 |         |---------------------------------------------*/
      594 | 
      595 |         if ( ( CDD_busmem_base( cdd, 0 ) == 0 )   ||
      595 +         if ( ( (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]) == 0 )   ||
      596 |              ( CDD_busmem_len( cdd, 0 ) == 0 )    ||
      596 +              ( (((cdd)->p_cdd_device_attrs)->address_space_length[(0)]) == 0 )    ||
      597 |              ( CDD_busmem_seg( cdd ) == 0 )       ||
      597 +              ( (((cdd)->p_cdd_device_attrs)->busmem_att) == 0 )       ||
      598 |               ( CDD_iocc_seg( cdd ) == 0 )        ||
      598 +               ( (((cdd)->p_cdd_device_attrs)->iocc_att) == 0 )        ||
      599 |               ( CDD_iocc_base( cdd ) == 0 )       ||
      599 +               ( (((cdd)->p_cdd_device_attrs)->iocc_addr_base) == 0 )       ||
      600 |               ( !CDD_ADDR_IS_BUS_MEM( CDD_busmem_seg( cdd ),
      600 +               ( !
      601 |                               CDD_busmem_base( cdd, 0 ) ) ) ||
      601 + ( ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_IOCC_SELECT ) == 0 ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_BUSx ) == CDD_BUSx ) && (( ((((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)])) & CDD_BUS_IO_MASK) != 0 ) ) ) ||
      602 |               ( !CDD_ADDR_IS_IOCC( CDD_iocc_seg( cdd ),
      602 +               ( !
      603 |                                  CDD_iocc_base( cdd ) ) ) )
      603 + ( ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_IOCC_SELECT ) == CDD_IOCC_SELECT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_BUSx ) == CDD_BUSx ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) >= CDD_IOCC_BASE ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) < CDD_IOCC_TOP ) ) ) )
      604 |         {
      605 |                 return( CDD_rc( cdd ) = E_CDD_DEV_ARGS );
      605 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_DEV_ARGS );
      606 |         }
      607 | 
      608 |         /*-----------------------------------------------
      609 |         |  Passing through to here means we think we have
      610 |         |  a valid command and valid cdd support structures.
      611 |         |
      612 |         | Initialize the data that were defined within this
      613 |         | function
      614 |         |
      615 |         |------------------------------------------------*/
      616 | 
      617 |         ddf                = ( rby_cdd_ddf * )  CDD_ddf( cdd );
      617 +         ddf                = ( rby_cdd_ddf * )  (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
      618 |         RBY_ddf            = ddf;
      619 |         ddf->RBY_rc        = 0;
      620 |         ddf->RBY_cdd       = cdd;
      621 |         ddf->RBY_seg       = CDD_busmem_seg( cdd );
      621 +         ddf->RBY_seg       = (((cdd)->p_cdd_device_attrs)->busmem_att);
      622 |         ddf->RBY_base      = CDD_busmem_base( cdd , 0 );
      622 +         ddf->RBY_base      = (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]);
      623 |         ddf->RBY_iocc_seg  = CDD_iocc_seg( cdd );
      623 +         ddf->RBY_iocc_seg  = (((cdd)->p_cdd_device_attrs)->iocc_att);
      624 |         ddf->RBY_iocc_base = CDD_iocc_base( cdd );
      624 +         ddf->RBY_iocc_base = (((cdd)->p_cdd_device_attrs)->iocc_addr_base);
      625 |         ddf->RBY_slot      = CDD_slot( cdd );
      625 +         ddf->RBY_slot      = (((cdd)->p_cdd_device_attrs)->slot);
      626 | 
      627 |         /*-------------------------------------------------
      628 |         |
      629 |         | Retrieve POS 2 from the adapter, in preparation of disabling
      630 |         | the adapter.  We will write this value to the bus with
      631 |         | the enable bit masked off
      632 |         |
      633 |         |------------------------------------------------------*/
      634 | 
      635 |         RBY_GET_POS( 2 , pos_val  );
      635 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),(&(pos_val))); };
      636 |         RETURN_ON_EXCEPTION;
      636 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
      637 | 
      638 |         RBY_PUT_POS( 2 , ( pos_val & ~POS2_ENABLE ) );
      638 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),((( pos_val & ~0x01 )))); };
      639 |         RETURN_ON_EXCEPTION;
      639 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
      640 | 
      641 |         /*------------------------------------------------------------
      642 |         |
      643 |         | if we fall through to here, then the POS 2 register
      644 |         | is unset, and we can assume that the adapter cannot
      645 |         | respond to the MicroChannel signals.
      646 |         |
      647 |         |------------------------------------------------------------*/
      648 | 
      649 |         CDD_exception( cdd )            = 0;
      649 +         (((cdd)->p_cdd_device_attrs)->exception_code)            = 0;
      650 | 
      651 |         CDD_rc( cdd )                   = E_CDD_PASS;
      651 +         (((cdd)->p_cdd_command_attrs)->rc_out)                   = E_CDD_PASS;
      652 | 
      653 | #ifdef RBYCDD
      654 |  printf("cdd_disable exited:\n");
      655 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 655.8: 1506-234 (W) Expecting a newline character on #endif directive.
      656 | 
      657 |         return( E_CDD_PASS );
      658 | 
      659 | }
      660 | 
      661 | /*
      662 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
      663 |  *
      664 |  * FUNCTIONS: cdd_init
      665 |  *
      666 |  * ORIGINS: 27
      667 |  *
      668 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
      669 |  * combined with the aggregated modules for this product)
      670 |  * OBJECT CODE ONLY SOURCE MATERIALS
      671 |  * (C) COPYRIGHT International Business Machines Corp. 1992
      672 |  * All Rights Reserved
      673 |  *
      674 |  * US Government Users Restricted Rights - Use, duplication or
      675 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
      676 |  */
      677 | 
      678 | /*
      679 |  * NAME: cdd_init
      680 |  *
      681 |  * FUNCTION:  The CDD routines provide the device dependent functionality
      682 |  *            needed to interface to the graphics adapter.  All hardware
      683 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
      684 |  *            routines do not need device specific code to accomplish the common
      685 |  *            character mode functionality.
      686 |  *
      687 |  *            The input parameter is the pointer to the cdd_header_t which
      688 |  *            has pointers to the information that is needed to accomplish.
      689 |  *
      690 |  *            Init can only be called in two cases:
      691 |  *            (1) as the first CDD routine called
      692 |  *            (2) as the first CDD routine called after reset_hw.
      693 |  *
      694 |  *            Case (2) is optional.  If init is called, then a full hardware
      695 |  *            and software reset is being performed.  If init is not called,
      696 |  *            then only a hardware reset is being performed, and any state
      697 |  *            that was in the ddf will be preserved.
      698 |  *
      699 |  *            This kernel extension is an AIX load module
      700 |  *            which is compiled under special programming constraints.
      701 |  *            It is designed in particular to not have any programming
      702 |  *            constructs which cause the XLC compiler to produce
      703 |  *            references to the XCOFF TOC.  By doing this, the load
      704 |  *            module can be loaded both into the AIX kernel for the
      705 |  *            CCM VDD's use, and into the AIX System Boot ROS for
      706 |  *            similar use during boot time.
      707 |  *
      708 |  *            See the individual function headers for details of the
      709 |  *            purpose of each function.
      710 |  *
      711 |  *   WARNING: this routine cannot have a static char SCCS id, because having
      712 |  *   predefined strings will force this routine to require the use of RS/6000
      713 |  *   register R2, which points to the TOC !!!
      714 |  *
      715 |  *
      716 |  * EXECUTION ENVIRONMENT:
      717 |  *      This code is pageable.  It runs in all CDD environments:
      718 |  *              - Kernel device driver
      719 |  *              - AIX process (config method)
      720 |  *              - System IPL ROS
      721 |  *
      722 |  * (NOTES:)
      723 |  *      Called from various routines in the Common Character Mode VDD
      724 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
      725 |  *
      726 |  *      Because of the design rules on building CDD modules, all of the
      727 |  *      functions required by the CDD must be #included-ed into this routine.
      728 |  *      There can be no external considerations.
      729 |  *
      730 |  *      1. This function must define RBY_BASE_PTR since the
      731 |  *         "hw_model.h" is included with the symbol RBY_RMS
      732 |  *         defined, and since such an action allows the code
      733 |  *         to supply the base address of the adapter.
      734 |  *
      735 |  *      2. This function does not handle exceptions.  Instead,
      736 |  *         it passes them back to the caller for handling.
      737 |  *
      738 |  *      The init code is called first, before any other CDD routines, and
      739 |  *      does not access any hardware.  It simply returns data structures
      740 |  *      to the the caller, and (optionally) sets up data structures
      741 |  *      in the ddf.
      742 |  *
      743 |  *      Init does not check and does not care whether the CDD services
      744 |  *      or CDD functions structures contain valid contents.
      745 |  *
      746 |  *
      747 |  *      Init does check the device attributes and command attributes structures.
      748 |  *      The ddf must be valid in the device attributes, and the command and rc
      749 |  *      will be used in the command atributes, as well as the data out.
      750 |  *
      751 |  * (RECOVERY OPERATION:) None
      752 |  *
      753 |  * (DATA STRUCTURES:) cdd_header_t * cdd
      754 |  *
      755 |  * RETURNS:
      756 |  *      an error code of type "int" with value 0 if OK, or with
      757 |  *      nonzero error codes if not.  The error return values are stored
      758 |  *      in the cdd.h header file in the appropriate member(s).
      759 |  */
      760 | 
      761 | static int cdd_init(  cdd_header_t *  cdd  )
      762 | {
      763 |         /*-----------------------------------------------
      764 |          |       DATA DECLARATIONS
      765 |          | References to local data
      766 |          | must NOT refer to global variables outside
      767 |          | the scope of the function!!
      768 |          |----------------------------------------------*/
      769 | 
      770 |         cdd_init_out_t * p_out;
      771 |         int rc, i, flags;
      772 |         rby_cdd_ddf * ddf;
      773 |         ulong ddf_len;
      774 |         char * ptr;
      775 |         char * product_name;
      776 |         cdd_init_cmd_t * p_cmd;
      777 | 
      778 |         /*-----------------------------------------------------
      779 |         |       START OF SOURCE CODE
      780 |         |------------------------------------------------------*/
      781 |         p_cmd = (cdd_init_cmd_t *) CDD_DataIn( cdd);
      781 +         p_cmd = (cdd_init_cmd_t *) (((cdd)->p_cdd_command_attrs)->pDataIn);
      782 |         /*-----------------------------------------------------
      783 |         |  First test that the supplied pointer is valid
      784 |         |----------------------------------------------------*/
      785 | #ifdef RBYCDD
      786 |  printf("cdd_init: entry\n");
      787 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 787.8: 1506-234 (W) Expecting a newline character on #endif directive.
      788 | 
      789 |         if  ( cdd == NULL )
      789 +         if  ( cdd == 0 )
      790 |                 return( E_CDD_FAIL );
      791 | 
      792 |         /*-----------------------------------------------------
      793 |         |  Check the supplied version
      794 |         |----------------------------------------------------*/
      795 | 
      796 |         if  ( CDD_version( cdd ) < CDD_CURRENT_SW_VERSION )
      796 +         if  ( ((cdd)->version) < CDD_CURRENT_SW_VERSION )
      797 |                 return( E_CDD_VERSION );
      798 | 
      799 |         /*-----------------------------------------------------
      800 |         |  Test that the header structure itself is valid
      801 |         |----------------------------------------------------*/
      802 | 
      803 |         if (( CDD_command( cdd ) == NULL ) ||
      803 +         if (( ((cdd)->p_cdd_command_attrs) == 0 ) ||
      804 |                        ( CDD_device( cdd ) == NULL ))
      804 +                        ( ((cdd)->p_cdd_device_attrs) == 0 ))
      805 | 
      806 |                 return( E_CDD_HDR );
      807 | 
      808 |         /*----------------------------------------------------
      809 |         |  Test the device attributes structure subset that
      810 |         |  should be present at every invocation and make
      811 |         |  sure lengths of supplied data are OK
      812 |         |----------------------------------------------------*/
      813 | 
      814 |         if (( CDD_ddf( cdd ) == NULL ) ||
      814 +         if (( (((cdd)->p_cdd_device_attrs)->ddf_scratchpad) == 0 ) ||
      815 |                ( CDD_ddf_len( cdd ) < sizeof( rby_cdd_ddf )))
      815 +                ( (((cdd)->p_cdd_device_attrs)->ddf_len) < sizeof( rby_cdd_ddf )))
      816 | 
      817 |                 return( E_CDD_DEV_ARGS );
      818 | 
      819 |         ddf = CDD_ddf( cdd );
      819 +         ddf = (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
      820 |         ddf_len = CDD_ddf_len( cdd );
      820 +         ddf_len = (((cdd)->p_cdd_device_attrs)->ddf_len);
      821 | 
      822 |         /*-------------------------------------------------------
      823 |         |  Test the init command specific parameters for
      824 |         |  correctness
      825 |                                         ||
      826 |             (CDD_len_out( cdd ) <  sizeof( cdd_init_out_t)))
      827 |         |-------------------------------------------------------*/
      828 | 
      829 |         if ((CDD_cmd( cdd ) != CDD_CMD_INIT ) ||
      829 +         if (((((cdd)->p_cdd_command_attrs)->command) != CDD_CMD_INIT ) ||
      830 |             (CDD_DataOut( cdd ) == NULL ) ) 
      830 +             ((((cdd)->p_cdd_command_attrs)->pDataOut) == 0 ) ) 
      831 |         {
      832 |                 /*-----------------------------------------
      833 |                 | bad init command structure sent
      834 |                 | since we have valid pointer to command args,
      835 |                 | we need to write out the proper return
      836 |                 |-----------------------------------------*/
      837 |                 CDD_rc( cdd ) = E_CDD_CMD_ARGS;
      837 +                 (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_CMD_ARGS;
      838 |                 return( E_CDD_CMD_ARGS );
      839 |         }
      840 | 
      841 |         /*-----------------------------------------------
      842 |         |  Passing through to here means we think we have
      843 |         |  a valid command and valid cdd support structures.
      844 |         |
      845 |         | Initialize the data that were defined within this
      846 |         | function
      847 |         |------------------------------------------------*/
      848 | 
      849 |         p_out = (cdd_init_out_t *) CDD_DataOut( cdd );
      849 +         p_out = (cdd_init_out_t *) (((cdd)->p_cdd_command_attrs)->pDataOut);
      850 | 
      851 |         /*-------------------------------------------------
      852 |         | reset the ddf
      853 |         |------------------------------------------------*/
      854 | 
      855 |         for ( i = 0,  ptr = (char *) ddf;
      856 |             i< sizeof( rby_cdd_ddf );
      857 |             i++ , ptr++ )
      858 |         {
      859 |                 *ptr = 0;
      860 |         }
      861 | 
      862 |         /*--------------------------------------------------------
      863 |         |
      864 |         | Now for the real work
      865 |         |
      866 |         | First, set up the address space requirements that will
      867 |         | be hints for the ROS code to use when calling back
      868 |         | to set_busmem_ranges( ) of the procs
      869 |         |
      870 |         |----------------------------------------------------------*/
      871 | 
      872 |         CDD_INIT_busmem_base( p_out, 0 ) = RBY_DEFAULT_BUSMEM_BASE;
      872 +         ( (p_out) -> busmem_hw_base[ (0) ] ) = RBY_DEFAULT_BUSMEM_BASE;
      873 |         CDD_INIT_busmem_len(  p_out, 0 ) = RBY_DEFAULT_BUSMEM_LEN;
      873 +         ( (p_out)->address_space_length[ (0) ] ) = RBY_DEFAULT_BUSMEM_LEN;
      874 | 
      875 |         for ( i=1; i<CDD_MAX_BUSMEM_RANGES; i++ )
      876 |         {
      877 |                 CDD_INIT_busmem_len( p_out, i )  = 0;
      877 +                 ( (p_out)->address_space_length[ (i) ] )  = 0;
      878 |                 CDD_INIT_busmem_base( p_out, i ) = 0;
      878 +                 ( (p_out) -> busmem_hw_base[ (i) ] ) = 0;
      879 |         }
      880 | 
      881 |         CDD_INIT_busmem_seg( p_out ) = CDD_BUSx      |
      881 +         ( (p_out)->busmem_att ) = CDD_BUSx      |
      882 |                                        CDD_SEG_T_BIT |
      883 |                                        CDD_ADDR_CHK  |
      884 |                                        CDD_ADDR_INCR |
      885 |                                        CDD_BYPASS_TCW;
      886 | 
      887 |         /*-----------------------------^^^
      888 |         |  should the BYPASS bit be
      889 |         |  turned on?
      890 |         |--------------------------------*/
      891 | 
      892 |         CDD_INIT_iocc_seg( p_out )  =  CDD_IOCC_0_BID;
      892 +         ( (p_out)->iocc_att )  =  CDD_IOCC_0_BID;
      893 | 
      894 |         CDD_INIT_iocc_base( p_out ) =  CDD_IOCC_BASE;
      894 +         ( (p_out)->iocc_addr_base ) =  CDD_IOCC_BASE;
      895 | 
      896 |         /*--------------------------------------------------------
      897 |         | Now give hints on the type of blit that can be handled
      898 |         | at any given time
      899 |         |---------------------------------------------------------*/
      900 | 
      901 |         CDD_INIT_max_w( p_out )  = RBY_CDD_BLIT_MAX_W;
      901 +         ( (p_out)->max_width )  = RBY_CDD_BLIT_MAX_W;
      902 |         CDD_INIT_max_h( p_out )  = RBY_CDD_BLIT_MAX_H;
      902 +         ( (p_out)->max_height )  = RBY_CDD_BLIT_MAX_H;
      903 |         CDD_INIT_max_a( p_out )  = (RBY_CDD_BLIT_MAX_W * RBY_CDD_BLIT_MAX_H);
      903 +         ( (p_out)->max_area )  = (RBY_CDD_BLIT_MAX_W * RBY_CDD_BLIT_MAX_H);
      904 |         CDD_INIT_origin( p_out ) = CDD_ORIGIN_UL;
      904 +         ( (p_out)->origin_type ) = CDD_ORIGIN_UL;
      905 | 
      906 |         /*--------------------------------------------------------
      907 |         | The adapter does not require an interrupt handler in
      908 |         | CDD mode.  Set up the default interrupt characteristics
      909 |         | The numbers correspond to the contents of the ODM PdAt
      910 |         | descriptors of the same name
      911 |         |---------------------------------------------------------*/
      912 | 
      913 |         CDD_INIT_intr_lvl( p_out )    = 4; /*HW number, [0..15], no constants known */
      913 +         ( (p_out)->dflt_int_level )    = 4; /*HW number, [0..15], no constants known */
      914 |         CDD_INIT_intr_pri( p_out )    = INTCLASS3;
      914 +         ( (p_out)->dflt_int_priority )    = 4;
      915 |         CDD_INIT_dma_arb( p_out )     = 4; /*HW number, no constants known */
      915 +         ( (p_out)->dflt_dma_arb_level )     = 4; /*HW number, no constants known */
      916 |         CDD_INIT_has_intr( p_out )    = FALSE; /* no IH for this adapter */
      916 +         ( (p_out)->has_intr_handler )    = 0; /* no IH for this adapter */
      917 |         CDD_INIT_runs_polled( p_out ) = TRUE;  /* this adapter runs polled */
      917 +         ( (p_out)->can_run_in_polled_mode ) = 1;  /* this adapter runs polled */
      918 | 
      919 |         /*---------------------------------------------------------
      920 |         | Set-up the product name 
      921 |         |---------------------------------------------------------*/
      922 | 
      923 |         flags = p_cmd->cdd_flags & 0x000000f0;
      924 |         if ( flags )
      925 |         {
      926 |         product_name = CDD_INIT_product_name( p_out );
      926 +         product_name = ( (p_out)->product_name );
      927 |         *product_name++ = 'G';
      928 |         *product_name++ = 'X';
      929 |         *product_name++ = 'T';
      930 |         *product_name++ = '1';
      931 |         *product_name++ = '0';
      932 |         *product_name++ = '0';
      933 |         *product_name++ = '0';
      934 |         *product_name   = '\0';
      935 |         }
      936 | 
      937 |         /*---------------------------------------------------------
      938 |         | If we fall through to here, we are done.  The init is
      939 |         | now written into the hardware!!
      940 |         |---------------------------------------------------------*/
      941 | 
      942 |         CDD_exception( cdd )  = 0;
      942 +         (((cdd)->p_cdd_device_attrs)->exception_code)  = 0;
      943 | 
      944 |         CDD_rc( cdd ) = E_CDD_PASS;
      944 +         (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_PASS;
      945 | 
      946 | #ifdef RBYCDD
      947 |  printf("cdd_init: exit\n");
      948 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 948.8: 1506-234 (W) Expecting a newline character on #endif directive.
      949 | 
      950 |         return( E_CDD_PASS );
      951 | 
      952 | }
      953 | 
      954 | /*
      955 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
      956 |  *
      957 |  * FUNCTIONS: cdd_load_ucode
      958 |  *
      959 |  * ORIGINS: 27
      960 |  *
      961 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
      962 |  * combined with the aggregated modules for this product)
      963 |  * OBJECT CODE ONLY SOURCE MATERIALS
      964 |  * (C) COPYRIGHT International Business Machines Corp. 1992
      965 |  * All Rights Reserved
      966 |  *
      967 |  * US Government Users Restricted Rights - Use, duplication or
      968 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
      969 |  */
      970 | 
      971 | /*
      972 |  * NAME: cdd_load_ucode
      973 |  *
      974 |  * FUNCTION:  The CDD routines provide the device dependent functionality
      975 |  *            needed to interface to the graphics adapter.  All hardware
      976 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
      977 |  *            routines do not need device specific code to accomplish the common
      978 |  *            character mode functionality.
      979 |  *
      980 |  *            The input parameter is the pointer to the cdd_header_t which
      981 |  *            has pointers to the information that is needed to accomplish.
      982 |  *
      983 |  *            This routine writes directly to the hardware.  It may make use
      984 |  *            of some standard CDD utilities found in "cdd_subrs.c" in the
      985 |  *            same source directory as this routine.
      986 |  *
      987 |  *            All I/O accomplished by this routine is done through the CDD_svcs
      988 |  *            routines as defined in the cdd_macros.h header file.
      989 |  *            These routines are accessed via a pointer reference to the functions:
      990 |  *            busgetc, busgets, busgetl, busputc, busputs, and busputl.
      991 |  *
      992 |  *   WARNING: this routine cannot have a static char SCCS id, because having
      993 |  *   predefined strings will force this routine to require the use of RS/6000
      994 |  *   register R2, which points to the TOC !!!
      995 |  *
      996 |  * EXECUTION ENVIRONMENT:
      997 |  *      This code is pageable.  It runs in all CDD environments:
      998 |  *              - Kernel device driver
      999 |  *              - AIX process (config method)
     1000 |  *              - System IPL ROS
     1001 |  *
     1002 |  * (NOTES:)
     1003 |  *
     1004 |  * (RECOVERY OPERATION:) None
     1005 |  *
     1006 |  * (DATA STRUCTURES:) cdd_header_t * cdd
     1007 |  *
     1008 |  * RETURNS:
     1009 |  *      an error code of type "int" with value 0 if OK, or with
     1010 |  *      nonzero error codes if not.  The error return values are stored
     1011 |  *      in the cdd.h header file in the appropriate member(s).
     1012 |  */
     1013 | 
     1014 | static int cdd_load_ucode( cdd_header_t * cdd )
     1015 | {
     1016 | 
     1017 |         cdd_load_ucode_cmd_t *  p_cmd;     /* to read in the command    */
     1018 |         cdd_load_ucode_out_t *  p_out;     /* to write back screen size */
     1019 |         int rc, data;
     1020 |         uchar posbyte;
     1021 |         int temp, flags;
     1022 |         uint temp1, temp2;
     1023 | 
     1024 |         rby_cdd_ddf *  ddf;
     1025 |         rby_cdd_ddf *  RBY_ddf;            /* name used by the macros   */
     1026 |         int           old_time, new_time,i;
     1027 | 
     1028 |         /*--------------------------------------------------------
     1029 |          |       START OF SOURCE CODE
     1030 |          |------------------------------------------------------*/
     1031 | #ifdef RBYCDD
     1032 |   printf("cdd_load_ucode: entry\n");
     1033 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1033.8: 1506-234 (W) Expecting a newline character on #endif directive.
     1034 | 
     1035 | 
     1036 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
     1037 | 
     1038 |         if ( rc != E_CDD_PASS )
     1039 |                 return (rc);
     1040 | 
     1041 |         /*--------------------------------------------------------
     1042 |         |  Test the load_ucode command specific parameters for
     1043 |         |  correctness
     1044 |             (CDD_len_in( cdd ) <  sizeof( cdd_load_ucode_cmd_t)) ||
     1045 |             (CDD_len_out( cdd ) <  sizeof( cdd_load_ucode_cmd_t)))
     1046 |         |-------------------------------------------------------*/
     1047 | 
     1048 |         if ((CDD_DataIn( cdd ) == NULL ) ||
     1048 +         if (((((cdd)->p_cdd_command_attrs)->pDataIn) == 0 ) ||
     1049 |             (CDD_DataOut( cdd ) == NULL)) 
     1049 +             ((((cdd)->p_cdd_command_attrs)->pDataOut) == 0)) 
     1050 |         {
     1051 |                 CDD_rc( cdd )  = E_CDD_CMD_ARGS;
     1051 +                 (((cdd)->p_cdd_command_attrs)->rc_out)  = E_CDD_CMD_ARGS;
     1052 |                 return( E_CDD_CMD_ARGS );
     1053 |         }
     1054 | 
     1055 |         /*---------------------------------------------
     1056 |         | copy in the working length variables, for
     1057 |         | additional command checking
     1058 |         |--------------------------------------------*/
     1059 | 
     1060 |         p_cmd = (cdd_load_ucode_cmd_t *) CDD_DataIn( cdd );
     1060 +         p_cmd = (cdd_load_ucode_cmd_t *) (((cdd)->p_cdd_command_attrs)->pDataIn);
     1061 |         p_out = (cdd_load_ucode_out_t *) CDD_DataOut( cdd );
     1061 +         p_out = (cdd_load_ucode_out_t *) (((cdd)->p_cdd_command_attrs)->pDataOut);
     1062 | 
     1063 |         flags = p_cmd->cdd_flags & 0x000000f0;
     1064 |         /*---------------------------------------------
     1065 |         | do the additional checking on command parms
     1066 |              ||  (CDD_LOAD_UCODE_len( p_cmd ) ==  0 ) ) )
     1067 |         if (( ! (CDD_LOAD_UCODE_flags( p_cmd ) & CDD_FLAGBIT_IPLROS))
     1068 |              && ( (CDD_LOAD_UCODE_ptr( p_cmd ) == NULL )))
     1069 |         {
     1070 |                 CDD_rc( cdd )      = E_CDD_CMD_LOAD_UCODE;
     1071 |                 return( E_CDD_CMD_LOAD_UCODE );
     1072 |         }
     1073 |         We don't have ucode, so don't check!!!!
     1074 |         |---------------------------------------------*/
     1075 | 
     1076 |         /*-----------------------------------------------------
     1077 |         | make sure there is a valid segment and address range
     1078 |         |----------------------------------------------------*/
     1079 | 
     1080 |         if (( CDD_busmem_base( cdd, 0 ) == 0 )  ||
     1080 +         if (( (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]) == 0 )  ||
     1081 |             ( CDD_busmem_len(  cdd, 0 ) == 0 ) ||
     1081 +             ( (((cdd)->p_cdd_device_attrs)->address_space_length[(0)]) == 0 ) ||
     1082 |             ( !CDD_ADDR_IS_BUS_MEM( CDD_busmem_seg( cdd ),
     1082 +             ( !
     1083 |             CDD_busmem_base( cdd, 0 ))))
     1083 + ( ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_IOCC_SELECT ) == 0 ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_BUSx ) == CDD_BUSx ) && (( ((((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)])) & CDD_BUS_IO_MASK) != 0 ) )))
     1084 |         {
     1085 |                 CDD_rc( cdd ) = E_CDD_DEV_ARGS ;
     1085 +                 (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_DEV_ARGS ;
     1086 |                 return( E_CDD_DEV_ARGS );
     1087 |         }
     1088 | 
     1089 |         /*----------------------------------------------------
     1090 |         |  Passing through to here means we think we have
     1091 |         |  a valid command and valid cdd support structures.
     1092 |         |
     1093 |         | Initialize the data that was defined within this
     1094 |         | function
     1095 |         |
     1096 |         |----------------------------------------------------*/
     1097 | 
     1098 |         ddf                 = ( rby_cdd_ddf * ) CDD_ddf( cdd );
     1098 +         ddf                 = ( rby_cdd_ddf * ) (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
     1099 |         RBY_ddf             = ddf;
     1100 |         ddf->RBY_rc         = 0;
     1101 |         ddf->RBY_cdd        = cdd;
     1102 |         ddf->RBY_seg        = CDD_busmem_seg( cdd );
     1102 +         ddf->RBY_seg        = (((cdd)->p_cdd_device_attrs)->busmem_att);
     1103 |         ddf->RBY_base       = CDD_busmem_base( cdd , 0 );
     1103 +         ddf->RBY_base       = (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]);
     1104 |         ddf->RBY_len_ucode  = p_cmd -> length_of_ucode;
     1105 |         ddf->RBY_p_ucode    = p_cmd -> p_ucode;
     1106 |         ddf->RBY_hw_state   = RBY_hw_state_is_unknown;
     1107 | 
     1108 |         /*----------------------------------------------------------
     1109 |         | Reset the adapter to get it into Common Character Mode
     1110 |         |------------------------------------------------------------
     1111 |         RBY_ddf->RBY_rc = CDD_busputl( RBY_ddf->RBY_cdd,
     1112 |                                        RBY_ddf->RBY_seg,
     1113 |                                        RBY_PTR_CMD_RESET_REG,
     1114 |                                        RESET_ADAP );
     1115 | 
     1116 |         RBY_ddf->RBY_rc = CDD_busputl( RBY_ddf->RBY_cdd,
     1117 |                                        RBY_ddf->RBY_seg,
     1118 |                                        RBY_PTR_CMD_RESET_REG,
     1119 |                                        CLEAR_RESET );
     1120 | */
     1121 |         /*--------------------------------------------
     1122 |         | Select POS 3B by writing 0x01 to POS 6 and 7
     1123 |         |--------------------------------------------*/
     1124 |         RBY_PUT_POS( 6 , 0x01 );
     1124 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((6))))),((0x01))); };
     1125 |         RETURN_ON_EXCEPTION;
     1125 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1126 | 
     1127 |         RBY_PUT_POS( 7 , 0x01 );
     1127 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((7))))),((0x01))); };
     1128 |         RETURN_ON_EXCEPTION;
     1128 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1129 | 
     1130 |         /*-------------------------------------------------------
     1131 |         | Wait for 'ruby available' ie diag's to complete
     1132 |         |------------------------------------------------------*/
     1133 | #ifdef RBYCDD
     1134 |         printf("waiting for Ruby available\n");
     1135 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1135.8: 1506-234 (W) Expecting a newline character on #endif directive.
     1136 | 
     1137 |             RBY_GET_POS( 3, posbyte );
     1137 +             { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(&(posbyte))); };
     1138 |             RETURN_ON_EXCEPTION;
     1138 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1139 | 
     1140 |         for (i = 0; i < 16000000 && !(posbyte & 0x80); i ++)
     1141 |          {
     1142 |           RBY_ddf->RBY_rc = CDD_busputc( RBY_ddf->RBY_cdd,              \
     1142 +           RBY_ddf->RBY_rc = 
     1143 |                                        RBY_ddf->RBY_iocc_seg,           \
     1144 |                                        0x000000E0,                      \
     1145 |                                        0 );
     1145 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(0x000000E0),(0));
     1146 |             RBY_GET_POS( 3, posbyte );
     1146 +             { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(&(posbyte))); };
     1147 |             RETURN_ON_EXCEPTION;
     1147 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1148 |          }
     1149 | 
     1150 |         /*----------------------------------
     1151 |         | Write zeros to POS 6 and 7
     1152 |         |----------------------------------*/
     1153 |         RBY_PUT_POS( 6 , ( POS_CLEAR )) ;
     1153 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((6))))),((( 0x00 )))); } ;
     1154 |         RETURN_ON_EXCEPTION;
     1154 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1155 | 
     1156 |         RBY_PUT_POS( 7 , ( POS_CLEAR )) ;
     1156 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((7))))),((( 0x00 )))); } ;
     1157 |         RETURN_ON_EXCEPTION;
     1157 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1158 | 
     1159 |         /*-------------------------------------------------------
     1160 |         | Wait for diags to complete on adapter before proceeding
     1161 |         |------------------------------------------------------*/
     1162 |         if ( posbyte & 0x80 )
     1163 |          {
     1164 |           for (i = 0; i < 16000000; i ++)
     1165 |            {
     1166 |               RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1166 +               RBY_ddf->RBY_rc = 
     1167 |                                              RBY_ddf->RBY_seg,
     1168 |                                              RBY_PTR_ERROR_WORD,
     1169 |                                              &(data) );
     1169 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010004 )),(&(data)));
     1170 |             RETURN_ON_EXCEPTION;
     1170 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1171 |             if ((data & ERROR_FLAGS) || (data == 0xc0000000))
     1171 +             if ((data & 0x30000000) || (data == 0xc0000000))
     1172 |             {
     1173 |                 /*
     1174 |                 CDD_rc( cdd ) = E_CDD_CMD_LOAD_UCODE;
     1175 |                 return( E_CDD_CMD_LOAD_UCODE );
     1176 |                 */
     1177 |                 break;
     1178 |             }
     1179 | 
     1180 |         /*-------------------------------------------------------
     1181 |         | IOCC delay
     1182 |         |------------------------------------------------------*/
     1183 |             RBY_GET_POS( 3, posbyte );
     1183 +             { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(&(posbyte))); };
     1184 |             RETURN_ON_EXCEPTION;
     1184 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1185 |             RBY_ddf->RBY_rc = CDD_busputc( RBY_ddf->RBY_cdd,            
     1185 +             RBY_ddf->RBY_rc = 
     1186 |                                        RBY_ddf->RBY_iocc_seg,           
     1187 |                                        0x000000E0,                    
     1188 |                                        0 );
     1188 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(0x000000E0),(0));
     1189 |             RBY_GET_POS( 3, posbyte );
     1189 +             { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(&(posbyte))); };
     1190 |             RETURN_ON_EXCEPTION;
     1190 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1191 | 
     1192 |            }
     1193 |          }
     1194 | 
     1195 | 
     1196 |         if (data != 0xc0000000)
     1197 |          {
     1198 |           if ( flags )
     1199 |           {
     1200 |            cdd->p_cdd_command_attrs->product_SRN[0] = '9';
     1201 |            cdd->p_cdd_command_attrs->product_SRN[1] = '0';
     1202 |            cdd->p_cdd_command_attrs->product_SRN[2] = '8';
     1203 | 
     1204 |            if (posbyte & 0x80)
     1205 |            {
     1206 |             cdd->p_cdd_command_attrs->product_SRN[3] = ((data & 0x00000f00) >> 8) + '0';
     1207 |             cdd->p_cdd_command_attrs->product_SRN[4] = ((data & 0x000000f0) >> 4) + '0';
     1208 |             cdd->p_cdd_command_attrs->product_SRN[5] = (data & 0x0000000f) + '0';
     1209 |            }
     1210 |            else
     1211 |            {
     1212 |             cdd->p_cdd_command_attrs->product_SRN[3] = '1';
     1213 |             cdd->p_cdd_command_attrs->product_SRN[4] = '6';
     1214 |             cdd->p_cdd_command_attrs->product_SRN[5] = '0';
     1215 |            }
     1216 | 
     1217 |            cdd->p_cdd_command_attrs->product_SRN[6] = '\0';
     1218 |            cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1219 |            cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1220 |            cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1221 |            cdd->p_cdd_command_attrs->component_loc[0] = '\0';
     1222 |           }
     1223 | 
     1224 |           CDD_rc( cdd ) = E_CDD_BAD_HW_OP;
     1224 +           (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_BAD_HW_OP;
     1225 |           return( E_CDD_BAD_HW_OP );
     1226 |          }
     1227 | 
     1228 |         ddf->RBY_hw_state = RBY_hw_state_is_reset;
     1229 | 
     1230 |         /*----------------------------------------------------------
     1231 |         | Initialize adapter for Common Character Mode
     1232 |         |------------------------------------------------------------*/
     1233 |         RBY_ddf->RBY_rc = CDD_busputl( RBY_ddf->RBY_cdd,
     1233 +         RBY_ddf->RBY_rc = 
     1234 |                                        RBY_ddf->RBY_seg,
     1235 |                                        RBY_PTR_MAILBOX_OUT,
     1236 |                                        RBY_CDD_INIT_OP);
     1236 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010124 )),(RBY_CDD_INIT_OP));
     1237 | 
     1238 |         ddf->RBY_hw_state = RBY_hw_state_is_reset_and_CCM;
     1239 | 
     1240 |         /*-----------------------------------------------------------
     1241 |         |
     1242 |         | Initialize the screen size in pixels. 1280x1024 are currently
     1243 |         | the only choice
     1244 |         |
     1245 |         if ( flags )
     1246 |         {
     1247 |         }
     1248 |         |-----------------------------------------------------------*/
     1249 | 
     1250 |         temp1 = *((uint *)(CDD_svcs( cdd )->lockl));
     1250 +         temp1 = *((uint *)(((cdd)->p_cdd_svcs)->lockl));
     1251 |         temp2 = *((uint *)(CDD_svcs( cdd )->unlockl));
     1251 +         temp2 = *((uint *)(((cdd)->p_cdd_svcs)->unlockl));
     1252 |         if ( flags || (temp1 != temp2))
     1253 |          {
     1254 |         CDD_LOAD_UCODE_x_min( p_out )   = 0;
     1254 +         ( (p_out)->x_min )   = 0;
     1255 |         CDD_LOAD_UCODE_x_max( p_out )   = RBY_CDD_BLIT_MAX_X;
     1255 +         ( (p_out)->x_max )   = RBY_CDD_BLIT_MAX_X;
     1256 |         CDD_LOAD_UCODE_y_min( p_out )   = 0;
     1256 +         ( (p_out)->y_min )   = 0;
     1257 |         CDD_LOAD_UCODE_y_max( p_out )   = RBY_CDD_BLIT_MAX_Y;
     1257 +         ( (p_out)->y_max )   = RBY_CDD_BLIT_MAX_Y;
     1258 |          }
     1259 | 
     1260 |         /*---------------------------------------------------------
     1261 |         |
     1262 |         | If we fall through to here, we are done.  The adapter is
     1263 |         | now ready to accept blit commands.
     1264 |         |
     1265 |         |---------------------------------------------------------*/
     1266 | 
     1267 |         CDD_exception( cdd ) = 0;
     1267 +         (((cdd)->p_cdd_device_attrs)->exception_code) = 0;
     1268 | 
     1269 |         CDD_rc( cdd )        = E_CDD_PASS;
     1269 +         (((cdd)->p_cdd_command_attrs)->rc_out)        = E_CDD_PASS;
     1270 | 
     1271 | #ifdef RBYCDD
     1272 |   printf("cdd_load_ucode: exit\n");
     1273 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1273.8: 1506-234 (W) Expecting a newline character on #endif directive.
     1274 | 
     1275 | 
     1276 |         return( E_CDD_PASS );
     1277 | 
     1278 | }
     1279 | 
     1280 | /*
     1281 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
     1282 |  *
     1283 |  * FUNCTIONS: cdd_qvpd
     1284 |  *
     1285 |  * ORIGINS: 27
     1286 |  *
     1287 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
     1288 |  * combined with the aggregated modules for this product)
     1289 |  * OBJECT CODE ONLY SOURCE MATERIALS
     1290 |  * (C) COPYRIGHT International Business Machines Corp. 1992
     1291 |  * All Rights Reserved
     1292 |  *
     1293 |  * US Government Users Restricted Rights - Use, duplication or
     1294 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
     1295 |  */
     1296 | 
     1297 | /*
     1298 |  * NAME: cdd_qvpd
     1299 |  *
     1300 |  * FUNCTION:
     1301 |  *              Holds the device driver entry point of the
     1302 |  *              Common Character Mode device specific kernel load extension
     1303 |  *              for qvpd.
     1304 |  *
     1305 |  *              The CDD routines provide the device dependent functionality
     1306 |  *              needed to interface to the GTO graphics adapter.  All hardware
     1307 |  *              knowledge of the adapters is kept in the CDD modules.  The calling
     1308 |  *              routines do not need device specific code to accomplish the
     1309 |  *              common character mode functionality.
     1310 |  *
     1311 |  *              This kernel extension is an AIX load module
     1312 |  *              which is compiled under special programming constraints.
     1313 |  *              It is designed in particular to not have any programming
     1314 |  *              constructs which cause the XLC compiler to produce
     1315 |  *              references to the XCOFF TOC.  By doing this, the load
     1316 |  *              module can be loaded both into the AIX kernel for the
     1317 |  *              CCM VDD's use, and into the AIX System Boot ROS for
     1318 |  *              similar use during boot time.
     1319 |  *
     1320 |  *              See the individual function headers for details of the
     1321 |  *              purpose of each function.
     1322 |  *
     1323 |  *   WARNING: this routine cannot have a static char SCCS id, because having
     1324 |  *   predefined strings will force this routine to require the use of RS/6000
     1325 |  *   register R2, which points to the TOC !!!
     1326 |  *
     1327 |  *
     1328 |  * EXECUTION ENVIRONMENT:
     1329 |  *      This code is pageable.  It runs in all CDD environments:
     1330 |  *              - Kernel device driver
     1331 |  *              - AIX process (config method)
     1332 |  *              - System IPL ROS
     1333 |  *
     1334 |  * (NOTES:)
     1335 |  *          This routine writes directly to the hardware.  It may make use
     1336 |  *          of some standard CDD utilities found in "cdd_subrs.c" in the
     1337 |  *          same source directory as this routine.
     1338 |  *
     1339 |  *          All I/O accomplished by this routine is done through the CDD_svcs
     1340 |  *          routines as defined in the cdd_macros.h header file.
     1341 |  *          These routines are accessed via a pointer reference to the functions:
     1342 |  *          busgetc, busgets, busgetl, busputc, busputs, and busputl.
     1343 |  *
     1344 |  * (RECOVERY OPERATION:) None
     1345 |  *
     1346 |  * (DATA STRUCTURES:) cdd_header_t * cdd
     1347 |  *
     1348 |  * RETURNS:
     1349 |  *         an error code of type "int" with value 0 if OK, or with
     1350 |  *         nonzero error codes if not.  The error return values are stored
     1351 |  *         in the cdd.h header file in the appropriate member(s).
     1352 |  */
     1353 | 
     1354 | static int cdd_qvpd( cdd_header_t * cdd )
     1355 | {
     1356 |         /*-----------------------------------------------
     1357 |          |       DATA DECLARATIONS
     1358 |          |-----------------------------------------------*/
     1359 | 
     1360 |         cdd_qvpd_cmd_t *  p_cmd;          /* to read in the command */
     1361 |         cdd_qvpd_out_t *  p_out;          /* to put out the data */
     1362 |         cdd_vpd_t *       p_vpd;
     1363 | 
     1364 |         int   rc, i, length, len1, len2, crc1, crc2;
     1365 |         uint *vpd_ptr;
     1366 |         ushort crc;
     1367 | 
     1368 |         rby_cdd_ddf * ddf;
     1369 |         rby_cdd_ddf * RBY_ddf;        /* name used by the macros */
     1370 | 
     1371 |         uchar    posbyte;
     1372 |         char  * buf, * temp;
     1373 |         ulong   data_ptr;
     1374 |         int   data;
     1375 | 
     1376 |         ulong   configuration;
     1377 | 
     1378 |         union {
     1379 |               uint int_data;
     1380 |               char char_data[4];
     1381 |         } u;
     1382 | 
     1383 |         /*-----------------------------------------------------
     1384 |          |
     1385 |          |       START OF SOURCE CODE
     1386 |          |
     1387 |          |------------------------------------------------------*/
     1388 | 
     1389 | 
     1390 |         /*-------------------------------------------------
     1391 |         |  Test the input parameters to make sure that
     1392 |         |  we received the right kind of command
     1393 |         |----------------------------------------------------*/
     1394 | #ifdef RBYCDD
     1395 |   printf("cdd_qvpd: entry\n");
     1396 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1396.8: 1506-234 (W) Expecting a newline character on #endif directive.
     1397 | 
     1398 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
     1399 | 
     1400 |         if ( rc != E_CDD_PASS )
     1401 |              return (rc);
     1402 | 
     1403 |         /*------------------------------------------------------
     1404 |         |  Test the qvpd command specific parameters for
     1405 |         |  correctness
     1406 |         |-------------------------------------------------------*/
     1407 | 
     1408 |         if ( (CDD_cmd( cdd ) != CDD_CMD_QVPD )  ||
     1408 +         if ( ((((cdd)->p_cdd_command_attrs)->command) != CDD_CMD_QVPD )  ||
     1409 |              (CDD_DataIn( cdd ) == NULL ) ||
     1409 +              ((((cdd)->p_cdd_command_attrs)->pDataIn) == 0 ) ||
     1410 |              (CDD_len_in( cdd ) <  sizeof( cdd_qvpd_cmd_t) ) ||
     1410 +              ((((cdd)->p_cdd_command_attrs)->length_in) <  sizeof( cdd_qvpd_cmd_t) ) ||
     1411 |              (CDD_DataOut( cdd ) == NULL ) ||
     1411 +              ((((cdd)->p_cdd_command_attrs)->pDataOut) == 0 ) ||
     1412 |              (CDD_len_out( cdd ) < sizeof( cdd_qvpd_out_t) ) )
     1412 +              ((((cdd)->p_cdd_command_attrs)->length_out) < sizeof( cdd_qvpd_out_t) ) )
     1413 |         {
     1414 | 
     1415 |                 CDD_rc( cdd )      = E_CDD_CMD_ARGS;
     1415 +                 (((cdd)->p_cdd_command_attrs)->rc_out)      = E_CDD_CMD_ARGS;
     1416 |                 return( E_CDD_CMD_ARGS );
     1417 |         }
     1418 | 
     1419 |         /*-------------------------------------------
     1420 |         | copy in the working length variables, for
     1421 |         | additional command checking
     1422 |         |--------------------------------------------*/
     1423 | 
     1424 |         p_cmd = (cdd_qvpd_cmd_t *) CDD_DataIn( cdd );
     1424 +         p_cmd = (cdd_qvpd_cmd_t *) (((cdd)->p_cdd_command_attrs)->pDataIn);
     1425 |         p_out = (cdd_qvpd_out_t *) CDD_DataOut( cdd );
     1425 +         p_out = (cdd_qvpd_out_t *) (((cdd)->p_cdd_command_attrs)->pDataOut);
     1426 | 
     1427 |         /*---------------------------------------------
     1428 |         | do the additional checking on command parms
     1429 |         |---------------------------------------------*/
     1430 | 
     1431 |         if ( ( p_cmd->start_slot >  7 ) ||
     1432 |                 ( p_out->p_cdd_vpd  == 0 ) )
     1433 |         {
     1434 |                 CDD_rc( cdd )      = E_CDD_CMD_QVPD;
     1434 +                 (((cdd)->p_cdd_command_attrs)->rc_out)      = E_CDD_CMD_QVPD;
     1435 |                 return( E_CDD_CMD_QVPD );
     1436 |         }
     1437 | 
     1438 |         /*--------------------------------------------------------
     1439 |         | make sure there is a valid segment and address range
     1440 |         |-------------------------------------------------------*/
     1441 | 
     1442 |         if ( ( CDD_busmem_base( cdd, 0 ) == 0 )  ||
     1442 +         if ( ( (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]) == 0 )  ||
     1443 |              ( CDD_busmem_len( cdd, 0 ) == 0 )   ||
     1443 +              ( (((cdd)->p_cdd_device_attrs)->address_space_length[(0)]) == 0 )   ||
     1444 |              ( CDD_busmem_seg( cdd ) == 0 )      ||
     1444 +              ( (((cdd)->p_cdd_device_attrs)->busmem_att) == 0 )      ||
     1445 |              ( CDD_iocc_seg( cdd ) == 0 )        ||
     1445 +              ( (((cdd)->p_cdd_device_attrs)->iocc_att) == 0 )        ||
     1446 |              ( CDD_iocc_base( cdd ) == 0 )       ||
     1446 +              ( (((cdd)->p_cdd_device_attrs)->iocc_addr_base) == 0 )       ||
     1447 |              ( !CDD_ADDR_IS_BUS_MEM( CDD_busmem_seg( cdd ),
     1447 +              ( !
     1448 |                 CDD_busmem_base( cdd, 0 ) ) )    ||
     1448 + ( ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_IOCC_SELECT ) == 0 ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_BUSx ) == CDD_BUSx ) && (( ((((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)])) & CDD_BUS_IO_MASK) != 0 ) ) )    ||
     1449 |              ( !CDD_ADDR_IS_IOCC( CDD_iocc_seg( cdd ),
     1449 +              ( !
     1450 |             CDD_iocc_base( cdd ) ) ) )
     1450 + ( ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_IOCC_SELECT ) == CDD_IOCC_SELECT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_BUSx ) == CDD_BUSx ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) >= CDD_IOCC_BASE ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) < CDD_IOCC_TOP ) ) ) )
     1451 |         {
     1452 |                 CDD_rc( cdd )      = E_CDD_DEV_ARGS ;
     1452 +                 (((cdd)->p_cdd_command_attrs)->rc_out)      = E_CDD_DEV_ARGS ;
     1453 |                 return( E_CDD_DEV_ARGS );
     1454 |         }
     1455 | 
     1456 |         /*-----------------------------------------------
     1457 |         |  Passing through to here means we think we have
     1458 |         |  a valid command and valid cdd support structures.
     1459 |         |
     1460 |         | Initialize the data that were defined within this
     1461 |         | function
     1462 |         |
     1463 |         |------------------------------------------------*/
     1464 | 
     1465 |         p_vpd              = p_out -> p_cdd_vpd;
     1466 |         ddf                = ( rby_cdd_ddf * )  CDD_ddf( cdd );
     1466 +         ddf                = ( rby_cdd_ddf * )  (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
     1467 |         RBY_ddf            = ddf;
     1468 |         ddf->RBY_rc        = 0;
     1469 |         ddf->RBY_cdd       = cdd;
     1470 |         ddf->RBY_seg       = CDD_busmem_seg( cdd );
     1470 +         ddf->RBY_seg       = (((cdd)->p_cdd_device_attrs)->busmem_att);
     1471 |         ddf->RBY_base      = CDD_busmem_base( cdd , 0 );
     1471 +         ddf->RBY_base      = (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]);
     1472 |         ddf->RBY_iocc_seg  = CDD_iocc_seg( cdd );
     1472 +         ddf->RBY_iocc_seg  = (((cdd)->p_cdd_device_attrs)->iocc_att);
     1473 |         ddf->RBY_iocc_base = CDD_iocc_base( cdd );
     1473 +         ddf->RBY_iocc_base = (((cdd)->p_cdd_device_attrs)->iocc_addr_base);
     1474 |         ddf->RBY_slot      = CDD_QVPD_slot( p_cmd );
     1474 +         ddf->RBY_slot      = ( (p_cmd) -> start_slot );
     1475 |         ddf->RBY_hw_state  = RBY_hw_state_is_unknown;
     1476 | 
     1477 |         /*---------------------------------------------------------
     1478 |         | Read VPD from the cards installed in the adapter
     1479 |         |---------------------------------------------------------*/
     1480 |         buf     = CDD_VPD_buffer( p_vpd, 0 );
     1480 +         buf     = ( (p_vpd) -> per_unit_data[ 0 ].buffer );
     1481 |         CDD_VPD_num_valid_units( p_vpd )   = 1;
     1481 +         ( (p_vpd) -> num_valid_units )   = 1;
     1482 |         CDD_VPD_buf_length( p_vpd, 0 )     = CDD_VPD_MAX_LEN;
     1482 +         ( (p_vpd) -> per_unit_data[ 0 ].buf_length )     = CDD_VPD_MAX_LEN;
     1483 |         CDD_VPD_min_ucode_lvl( p_vpd, 0 )  = 0;
     1483 +         ( (p_vpd) -> per_unit_data[ 0 ].min_ucode_lvl )  = 0;
     1484 | 
     1485 | 
     1486 |         /*--------------------------------------------------------
     1487 |         | Make sure the adapter's ready
     1488 |         |-------------------------------------------------------*/
     1489 | 
     1490 |         data = 0;
     1491 | 
     1492 |         do{
     1493 |             RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1493 +             RBY_ddf->RBY_rc = 
     1494 |                                            RBY_ddf->RBY_seg,
     1495 |                                            RBY_PTR_ERROR_WORD,
     1496 |                                            &(data));
     1496 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010004 )),(&(data)));
     1497 |             RETURN_ON_EXCEPTION;
     1497 +             if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1498 | 
     1499 | 
     1500 |         if (data & ERROR_FLAGS)
     1500 +         if (data & 0x30000000)
     1501 |          {
     1502 | /*
     1503 |           cdd->p_cdd_command_attrs->product_SRN[0] = '9';
     1504 |           cdd->p_cdd_command_attrs->product_SRN[1] = '0';
     1505 |           cdd->p_cdd_command_attrs->product_SRN[2] = '8';
     1506 |           cdd->p_cdd_command_attrs->product_SRN[3] = ((data & 0x00000f00) >> 8) + '0';
     1507 |           cdd->p_cdd_command_attrs->product_SRN[4] = ((data & 0x000000f0) >> 4) + '0';
     1508 |           cdd->p_cdd_command_attrs->product_SRN[5] = (data & 0x0000000f) + '0';
     1509 |           cdd->p_cdd_command_attrs->product_SRN[6] = '\0';
     1510 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1511 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1512 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     1513 |           cdd->p_cdd_command_attrs->component_loc[0] = '\0';
     1514 | */
     1515 |           CDD_rc( cdd ) = E_CDD_BAD_HW_OP;
     1515 +           (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_BAD_HW_OP;
     1516 |           return( E_CDD_BAD_HW_OP );
     1517 |          }
     1518 |         }while (data != RCV_RDY);
     1518 +         }while (data != 0xC0000000);
     1519 | 
     1520 |         /*----------------------------------
     1521 |         | read VPD from POS 3 for the McIC
     1522 |         |----------------------------------*/
     1523 | #ifdef PASS_2_HW
     1524 |         for ( i=1;   i <= CDD_VPD_MAX_LEN;   i++, buf++ )
     1525 |         {
     1526 |                 RBY_PUT_POS( 6 , byte) ;
     1527 |                 RETURN_ON_EXCEPTION;
     1528 | 
     1529 |                  RBY_GET_POS( 3, posbyte );
     1530 |                  RETURN_ON_EXCEPTION;
     1531 |                  *buf = posbyte;
     1532 |         }
     1533 | #endif
     1534 | 
     1535 |         /*------------------------------------------
     1536 |         | Read configuration data
     1537 |         |-----------------------------------------*/
     1538 |          configuration   = 0;
     1539 | 
     1540 |          RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1540 +          RBY_ddf->RBY_rc = 
     1541 |                                         RBY_ddf->RBY_seg,
     1542 |                                         RBY_PTR_CFG_WORD_1,
     1543 |                                         &(configuration));
     1543 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010400 )),(&(configuration)));
     1544 |          RETURN_ON_EXCEPTION;
     1544 +          if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1545 | 
     1546 |         /*------------------------------------------
     1547 |         | Read GPSS VPD
     1548 |         |-----------------------------------------*/
     1549 | 
     1550 |         buf     = CDD_VPD_buffer( p_vpd, 1 );
     1550 +         buf     = ( (p_vpd) -> per_unit_data[ 1 ].buffer );
     1551 |         CDD_VPD_num_valid_units( p_vpd )   = 2;
     1551 +         ( (p_vpd) -> num_valid_units )   = 2;
     1552 |         CDD_VPD_min_ucode_lvl( p_vpd, 1 )  = 0;
     1552 +         ( (p_vpd) -> per_unit_data[ 1 ].min_ucode_lvl )  = 0;
     1553 | 
     1554 |         /*------------------------------------------
     1555 |         | Get GPSS VPD length
     1556 |         | VPD format(one byte per word in lsb):
     1557 |         |  word 1: total length of GPSS VPD block
     1558 |         |  word 2: 0
     1559 |         |  word 3: 'V'
     1560 |         |  word 4: 'P'
     1561 |         |  word 5: 'D'
     1562 |         |  word 6: upper half gpss vpd data length
     1563 |         |  word 7: lower half gpss vpd data length
     1564 |         |  word 8: upper half gpss crc sum
     1565 |         |  word 9: lower half gpss crc sum
     1566 |         |  word 10 - end: vpd data
     1567 |         |-----------------------------------------*/
     1568 |         if ( configuration & 0x01 )
     1569 |          {
     1570 |           vpd_ptr = RBY_PTR_VPD_START;
     1570 +           vpd_ptr = (ulong)( (( RBY_ddf -> RBY_base )) + 0x00010800 );
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1570.19: 1506-068 (W) Operation between types "unsigned int*" and "unsigned long" is not allowed.
     1571 |           vpd_ptr += 5;
     1572 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1572 +           RBY_ddf->RBY_rc = 
     1573 |                                         RBY_ddf->RBY_seg,
     1574 |                                         vpd_ptr++,
     1575 |                                         &(len1));
     1575 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len1)));
     1576 |           RETURN_ON_EXCEPTION;
     1576 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1577 | 
     1578 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1578 +           RBY_ddf->RBY_rc = 
     1579 |                                         RBY_ddf->RBY_seg,
     1580 |                                         vpd_ptr++,
     1581 |                                         &(len2));
     1581 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len2)));
     1582 |           RETURN_ON_EXCEPTION;
     1582 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1583 |           length = (len1 << 8) | len2;
     1584 | 
     1585 |           CDD_VPD_buf_length( p_vpd, 1 ) = length;
     1585 +           ( (p_vpd) -> per_unit_data[ 1 ].buf_length ) = length;
     1586 | 
     1587 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1587 +           RBY_ddf->RBY_rc = 
     1588 |                                         RBY_ddf->RBY_seg,
     1589 |                                         vpd_ptr++,
     1590 |                                         &(crc1));
     1590 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc1)));
     1591 |           RETURN_ON_EXCEPTION;
     1591 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1592 | 
     1593 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1593 +           RBY_ddf->RBY_rc = 
     1594 |                                         RBY_ddf->RBY_seg,
     1595 |                                         vpd_ptr++,
     1596 |                                         &(crc2));
     1596 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc2)));
     1597 |           RETURN_ON_EXCEPTION;
     1597 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1598 |           crc = (ushort)((crc1 << 8) | crc2);
     1599 | 
     1600 |         /*---------------------------------------------------
     1601 |         | read GPSS VPD into buffer. The VPD is contained in
     1602 |         | in a word. We are only interested in the lower order byte
     1603 |         |--------------------------------------------------*/
     1604 |           temp = buf; 
     1605 |           for ( i=0; i < length && i < 256; i++, buf++ )
     1606 |           {
     1607 |               RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1607 +               RBY_ddf->RBY_rc = 
     1608 |                                            RBY_ddf->RBY_seg,
     1609 |                                            vpd_ptr,
     1610 |                                            &(u.int_data));
     1610 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr),(&(u.int_data)));
     1611 |            RETURN_ON_EXCEPTION;
     1611 +            if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1612 |                  vpd_ptr ++;
     1613 |                  *buf = u.char_data[3];
     1614 |           }
     1615 | 
     1616 |          }
     1617 |         /*------------------------------------------
     1618 |         | Get RSS VPD length
     1619 |         |-----------------------------------------*/
     1620 | 
     1621 |         buf     = CDD_VPD_buffer( p_vpd, 2 );
     1621 +         buf     = ( (p_vpd) -> per_unit_data[ 2 ].buffer );
     1622 |         CDD_VPD_num_valid_units( p_vpd )   = 3;
     1622 +         ( (p_vpd) -> num_valid_units )   = 3;
     1623 |         CDD_VPD_min_ucode_lvl( p_vpd, 2 )  = 0;
     1623 +         ( (p_vpd) -> per_unit_data[ 2 ].min_ucode_lvl )  = 0;
     1624 | 
     1625 |         /*------------------------------------------
     1626 |         | Get RSS VPD length
     1627 |         |-----------------------------------------*/
     1628 |         if ( configuration & 0x02 )
     1629 |          {
     1630 |           vpd_ptr += 5;
     1631 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1631 +           RBY_ddf->RBY_rc = 
     1632 |                                         RBY_ddf->RBY_seg,
     1633 |                                         vpd_ptr++,
     1634 |                                         &(len1));
     1634 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len1)));
     1635 |           RETURN_ON_EXCEPTION;
     1635 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1636 | 
     1637 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1637 +           RBY_ddf->RBY_rc = 
     1638 |                                         RBY_ddf->RBY_seg,
     1639 |                                         vpd_ptr++,
     1640 |                                         &(len2));
     1640 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len2)));
     1641 |           RETURN_ON_EXCEPTION;
     1641 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1642 |           length = (len1 << 8) | len2;
     1643 | 
     1644 |           CDD_VPD_buf_length( p_vpd, 1 ) = length;
     1644 +           ( (p_vpd) -> per_unit_data[ 1 ].buf_length ) = length;
     1645 | 
     1646 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1646 +           RBY_ddf->RBY_rc = 
     1647 |                                         RBY_ddf->RBY_seg,
     1648 |                                         vpd_ptr++,
     1649 |                                         &(crc1));
     1649 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc1)));
     1650 |           RETURN_ON_EXCEPTION;
     1650 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1651 | 
     1652 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1652 +           RBY_ddf->RBY_rc = 
     1653 |                                         RBY_ddf->RBY_seg,
     1654 |                                         vpd_ptr++,
     1655 |                                         &(crc2));
     1655 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc2)));
     1656 |           RETURN_ON_EXCEPTION;
     1656 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1657 |           crc = (ushort)((crc1 << 8) | crc2);
     1658 | 
     1659 |         /*---------------------------------------------------
     1660 |         | read RSS VPD into buffer. The VPD is contained in
     1661 |         | in a word. We are only interested in the lower order byte
     1662 |         |--------------------------------------------------*/
     1663 |           temp = buf; 
     1664 |           for ( i=0; i < length && i < 256; i++, buf++ )
     1665 |           {
     1666 |               RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1666 +               RBY_ddf->RBY_rc = 
     1667 |                                            RBY_ddf->RBY_seg,
     1668 |                                            vpd_ptr,
     1669 |                                            &(u.int_data));
     1669 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr),(&(u.int_data)));
     1670 |            RETURN_ON_EXCEPTION;
     1670 +            if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1671 |                  vpd_ptr ++;
     1672 |                  *buf = u.char_data[3];
     1673 |           }
     1674 | 
     1675 |          }
     1676 |         /*------------------------------------------
     1677 | 
     1678 |         /*------------------------------------------
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1678.10: 1506-342 (W) "/*" detected in comment.
     1679 |         | If VOO option is installed, get its VPD
     1680 |         |-----------------------------------------*/
     1681 | 
     1682 |         if ( configuration & 0x04 )
     1683 |         {
     1684 |              /*------------------------------------------
     1685 |              | Get VOO VPD length
     1686 |              |-----------------------------------------*/
     1687 | 
     1688 |              buf     = CDD_VPD_buffer( p_vpd, 3 );
     1688 +              buf     = ( (p_vpd) -> per_unit_data[ 3 ].buffer );
     1689 |              CDD_VPD_num_valid_units( p_vpd )   = 4;
     1689 +              ( (p_vpd) -> num_valid_units )   = 4;
     1690 |              CDD_VPD_min_ucode_lvl( p_vpd, 3 )  = 0;
     1690 +              ( (p_vpd) -> per_unit_data[ 3 ].min_ucode_lvl )  = 0;
     1691 | 
     1692 |         /*------------------------------------------
     1693 |         | Get VOO VPD length
     1694 |         |-----------------------------------------*/
     1695 |         
     1696 |           vpd_ptr += 5;
     1697 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1697 +           RBY_ddf->RBY_rc = 
     1698 |                                         RBY_ddf->RBY_seg,
     1699 |                                         vpd_ptr++,
     1700 |                                         &(len1));
     1700 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len1)));
     1701 |           RETURN_ON_EXCEPTION;
     1701 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1702 | 
     1703 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1703 +           RBY_ddf->RBY_rc = 
     1704 |                                         RBY_ddf->RBY_seg,
     1705 |                                         vpd_ptr++,
     1706 |                                         &(len2));
     1706 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(len2)));
     1707 |           RETURN_ON_EXCEPTION;
     1707 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1708 |           length = (len1 << 8) | len2;
     1709 | 
     1710 |           CDD_VPD_buf_length( p_vpd, 1 ) = length;
     1710 +           ( (p_vpd) -> per_unit_data[ 1 ].buf_length ) = length;
     1711 | 
     1712 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1712 +           RBY_ddf->RBY_rc = 
     1713 |                                         RBY_ddf->RBY_seg,
     1714 |                                         vpd_ptr++,
     1715 |                                         &(crc1));
     1715 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc1)));
     1716 |           RETURN_ON_EXCEPTION;
     1716 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1717 | 
     1718 |           RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1718 +           RBY_ddf->RBY_rc = 
     1719 |                                         RBY_ddf->RBY_seg,
     1720 |                                         vpd_ptr++,
     1721 |                                         &(crc2));
     1721 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr++),(&(crc2)));
     1722 |           RETURN_ON_EXCEPTION;
     1722 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1723 |           crc = (ushort)((crc1 << 8) | crc2);
     1724 | 
     1725 |         /*---------------------------------------------------
     1726 |         | read VOO VPD into buffer. The VPD is contained in
     1727 |         | in a word. We are only interested in the lower order byte
     1728 |         |--------------------------------------------------*/
     1729 |           temp = buf; 
     1730 |           for ( i=0; i < length && i < 256;  i++, buf++ )
     1731 |           {
     1732 |               RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     1732 +               RBY_ddf->RBY_rc = 
     1733 |                                            RBY_ddf->RBY_seg,
     1734 |                                            vpd_ptr,
     1735 |                                            &(u.int_data));
     1735 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),(vpd_ptr),(&(u.int_data)));
     1736 |            RETURN_ON_EXCEPTION;
     1736 +            if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1737 |                  vpd_ptr ++;
     1738 |                  *buf = u.char_data[3];
     1739 |           }
     1740 | 
     1741 |          }
     1742 |         /*------------------------------------------
     1743 |        }
     1744 | 
     1745 |        CDD_VPD_dev_flags( p_vpd, 0 )   = configuration;
     1746 | 
     1747 |       /*---------------------------------------------------------
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1747.8: 1506-342 (W) "/*" detected in comment.
     1748 |       | If we fall through to here, we are done.  The qvpd is
     1749 |       | now written into the hardware!!
     1750 |       |---------------------------------------------------------*/
     1751 | 
     1752 |       CDD_exception( cdd ) = 0;
     1752 +       (((cdd)->p_cdd_device_attrs)->exception_code) = 0;
     1753 | 
     1754 |       CDD_rc( cdd )        = E_CDD_PASS;
     1754 +       (((cdd)->p_cdd_command_attrs)->rc_out)        = E_CDD_PASS;
     1755 | 
     1756 |       return( E_CDD_PASS );
     1757 | }
     1758 | /*
     1759 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
     1760 |  *
     1761 |  * FUNCTIONS: cdd_set_POS
     1762 |  *
     1763 |  * ORIGINS: 27
     1764 |  *
     1765 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
     1766 |  * combined with the aggregated modules for this product)
     1767 |  * OBJECT CODE ONLY SOURCE MATERIALS
     1768 |  * (C) COPYRIGHT International Business Machines Corp. 1992
     1769 |  * All Rights Reserved
     1770 |  *
     1771 |  * US Government Users Restricted Rights - Use, duplication or
     1772 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
     1773 |  */
     1774 | 
     1775 | /*
     1776 |  * NAME: cdd_set_POS
     1777 |  *
     1778 |  * FUNCTION:
     1779 |  *              Holds the device driver entry point of the
     1780 |  *              Common Character Mode device specific kernel load extension
     1781 |  *              for setPOS.
     1782 |  *
     1783 |  *              "setPOS" is the first routine to access the hardware.
     1784 |  *              It is called after init() and before any other routines.
     1785 |  *              It sets up the POS registers and uses the device attributes
     1786 |  *              to set the adapter to its proper I/O status.  It is assumed
     1787 |  *              that the adapter is in a "halted" or "not ready" state
     1788 |  *              at the end of this routine, and that the POS2 enable bit
     1789 |  *              is set, leaving the adapter microchannel interface enabled.
     1790 |  *
     1791 |  *              The next routine to be called (after this routine) is
     1792 |  *              the "load_ucode" routine.  The "load_ucode" routine
     1793 |  *              should only be called after the POS2 enable bit is set
     1794 |  *              by the caller.  "load_ucode" will exit successfully
     1795 |  *              with a fully CCM/CDD operational adapter.
     1796 |  *
     1797 |  *              This kernel extension is an AIX load module
     1798 |  *              which is compiled under special programming constraints.
     1799 |  *              It is designed in particular to not have any programming
     1800 |  *              constructs which cause the XLC compiler to produce
     1801 |  *              references to the XCOFF TOC.  By doing this, the load
     1802 |  *              module can be loaded both into the AIX kernel for the
     1803 |  *              CCM VDD's use, and into the AIX System Boot ROS for
     1804 |  *              similar use during boot time.
     1805 |  *
     1806 |  *              See the individual function headers for details of the
     1807 |  *              purpose of each function.
     1808 |  *
     1809 |  *              This routine writes directly to the hardware.  It may make use
     1810 |  *              of some standard CDD utilities found in "cdd_subrs.c" in the
     1811 |  *              same source directory as this routine.
     1812 |  *
     1813 |  *              All I/O accomplished by this routine is done through the CDD_svcs
     1814 |  *              routines as defined in the cdd_macros.h header file.
     1815 |  *              These routines are accessed via a pointer reference to the functions:
     1816 |  *              busgetc, busgets, busgetl, busputc, busputs, and busputl.
     1817 |  *
     1818 |  *   WARNING: this routine cannot have a static char SCCS id, because having
     1819 |  *   predefined strings will force this routine to require the use of RS/6000
     1820 |  *   register R2, which points to the TOC !!!
     1821 |  *
     1822 |  *
     1823 |  * EXECUTION ENVIRONMENT:
     1824 |  *      This code is pageable.  It runs in all CDD environments:
     1825 |  *              - Kernel device driver
     1826 |  *              - AIX process (config method)
     1827 |  *              - System IPL ROS
     1828 |  *
     1829 |  * (NOTES:)
     1830 |  *          1. This function must define BTY_BASE_PTR since the
     1831 |  *             "hw_model.h" is included with the symbol MID_RMS
     1832 |  *             defined, and since such an action allows the code
     1833 |  *             to supply the base address of the adapter.
     1834 |  *
     1835 |  *          2. This function does not handle exceptions.  Instead,
     1836 |  *             it passes them back to the caller for handling.
     1837 |  *
     1838 |  * (RECOVERY OPERATION:) None
     1839 |  *
     1840 |  * (DATA STRUCTURES:) cdd_header_t * cdd
     1841 |  *
     1842 |  * RETURNS:
     1843 |  *      an error code of type "int" with value 0 if OK, or with
     1844 |  *      nonzero error codes if not.  The error return values are stored
     1845 |  *      in the cdd.h header file in the appropriate member(s).
     1846 |  */
     1847 | 
     1848 | static int cdd_set_POS( cdd_header_t * cdd )
     1849 | {
     1850 | 
     1851 |         /*-----------------------------------------------
     1852 |         | References to local data
     1853 |         | must NOT refer to global variables outside
     1854 |         | the scope of the function!!
     1855 |         |----------------------------------------------*/
     1856 | 
     1857 |         cdd_set_pos_cmd_t *     cmd;
     1858 | 
     1859 |         int  rc, length, i, reg, result;
     1860 |         uint temp1, temp2;
     1861 | 
     1862 |         rby_cdd_ddf  * ddf;
     1863 |         rby_cdd_ddf * RBY_ddf;        /* name used by the macros */
     1864 | 
     1865 |         /*-----------------------------------------------------
     1866 |         |
     1867 |         |       START OF SOURCE CODE
     1868 |         |
     1869 |         |------------------------------------------------------*/
     1870 | #ifdef RBYCDD
     1871 | printf("cdd_set_POS: entry cdd = %x\n",cdd);
     1872 | #endif RBYCDD
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 1872.8: 1506-234 (W) Expecting a newline character on #endif directive.
     1873 | 
     1874 | 
     1875 |         /*-------------------------------------------------
     1876 |         |
     1877 |         |  Test the input parameters to make sure that
     1878 |         |  we received the right kind of command
     1879 |         |
     1880 |         |----------------------------------------------------*/
     1881 | 
     1882 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
     1883 |         if ( rc != E_CDD_PASS )
     1884 |               return (rc);
     1885 | 
     1886 |         /*------------------------------------------------------
     1887 |         |  Test the setPOS command specific parameters for
     1888 |         |  correctness
     1889 |                                 ||
     1890 |              (CDD_len_in( cdd ) < sizeof( cdd_set_pos_cmd_t) ) )
     1891 |         |-------------------------------------------------------*/
     1892 |         if ((CDD_DataIn( cdd ) == NULL ) ) 
     1892 +         if (((((cdd)->p_cdd_command_attrs)->pDataIn) == 0 ) ) 
     1893 |                 return( CDD_rc( cdd ) = E_CDD_CMD_ARGS);
     1893 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_CMD_ARGS);
     1894 | 
     1895 |         /*--------------------------------------------------------
     1896 |         | read in the command and make sure that it is valid
     1897 |         |
     1898 |         | NOTE: this adapter only runs in polled mode -- no interrupts
     1899 |         |---------------------------------------------------------*/
     1900 | 
     1901 |         cmd  = (cdd_set_pos_cmd_t *) CDD_DataIn( cdd );
     1901 +         cmd  = (cdd_set_pos_cmd_t *) (((cdd)->p_cdd_command_attrs)->pDataIn);
     1902 | 
     1903 |         if ( CDD_SET_POS_use_polled_mode( cmd ) != TRUE )
     1903 +         if ( ( (cmd)->use_polled_mode) != 1 )
     1904 |                 return( CDD_rc( cdd ) = E_CDD_CMD_SET_POS );
     1904 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_CMD_SET_POS );
     1905 | 
     1906 |         /*---------------------------------------------
     1907 |         | make sure there is a valid segment and address range
     1908 |         |---------------------------------------------*/
     1909 | 
     1910 |         if ( ( CDD_busmem_base( cdd, 0 ) == 0 )   ||
     1910 +         if ( ( (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]) == 0 )   ||
     1911 |              ( CDD_busmem_len( cdd, 0 ) == 0 )    ||
     1911 +              ( (((cdd)->p_cdd_device_attrs)->address_space_length[(0)]) == 0 )    ||
     1912 |              ( CDD_busmem_seg( cdd ) == 0 )       ||
     1912 +              ( (((cdd)->p_cdd_device_attrs)->busmem_att) == 0 )       ||
     1913 |              ( CDD_iocc_seg( cdd ) == 0 )         ||
     1913 +              ( (((cdd)->p_cdd_device_attrs)->iocc_att) == 0 )         ||
     1914 |              ( CDD_iocc_base( cdd ) == 0 )        ||
     1914 +              ( (((cdd)->p_cdd_device_attrs)->iocc_addr_base) == 0 )        ||
     1915 |              ( !CDD_ADDR_IS_BUS_MEM( CDD_busmem_seg( cdd ),
     1915 +              ( !
     1916 |                  CDD_busmem_base( cdd, 0 ) ) )    ||
     1916 + ( ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_IOCC_SELECT ) == 0 ) && ((((((cdd)->p_cdd_device_attrs)->busmem_att)) & CDD_BUSx ) == CDD_BUSx ) && (( ((((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)])) & CDD_BUS_IO_MASK) != 0 ) ) )    ||
     1917 |              ( !CDD_ADDR_IS_IOCC( CDD_iocc_seg( cdd ),
     1917 +              ( !
     1918 |             CDD_iocc_base( cdd ) ) ) )
     1918 + ( ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_SEG_T_BIT ) == CDD_SEG_T_BIT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_IOCC_SELECT ) == CDD_IOCC_SELECT ) && ((((((cdd)->p_cdd_device_attrs)->iocc_att)) & CDD_BUSx ) == CDD_BUSx ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) >= CDD_IOCC_BASE ) && ( ((((cdd)->p_cdd_device_attrs)->iocc_addr_base)) < CDD_IOCC_TOP ) ) ) )
     1919 |         {
     1920 |                 /*----------------------------------------------
     1921 |                 | invalid segment/address pair was supplied
     1922 |                 |----------------------------------------------*/
     1923 | 
     1924 |                 return( CDD_rc( cdd ) = E_CDD_DEV_ARGS );
     1924 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_DEV_ARGS );
     1925 |         }
     1926 | 
     1927 |         /*-----------------------------------------------
     1928 |         |  Passing through to here means we think we have
     1929 |         |  a valid command and valid cdd support structures.
     1930 |         |
     1931 |         | Initialize the data that were defined within this
     1932 |         | function
     1933 |         |
     1934 |         |------------------------------------------------*/
     1935 | 
     1936 |         ddf                 = ( rby_cdd_ddf * )  CDD_ddf( cdd );
     1936 +         ddf                 = ( rby_cdd_ddf * )  (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
     1937 |         RBY_ddf             = ddf;
     1938 |         ddf->RBY_rc         = 0;
     1939 |         ddf->RBY_cdd        = cdd;
     1940 |         ddf->RBY_seg        = CDD_busmem_seg( cdd );
     1940 +         ddf->RBY_seg        = (((cdd)->p_cdd_device_attrs)->busmem_att);
     1941 |         ddf->RBY_base       = CDD_busmem_base( cdd , 0 );
     1941 +         ddf->RBY_base       = (((cdd)->p_cdd_device_attrs)->busmem_hw_base[(0)]);
     1942 |         ddf->RBY_iocc_seg   = CDD_iocc_seg( cdd );
     1942 +         ddf->RBY_iocc_seg   = (((cdd)->p_cdd_device_attrs)->iocc_att);
     1943 |         ddf->RBY_iocc_base  = CDD_iocc_base( cdd );
     1943 +         ddf->RBY_iocc_base  = (((cdd)->p_cdd_device_attrs)->iocc_addr_base);
     1944 |         ddf->RBY_slot       = CDD_slot( cdd );
     1944 +         ddf->RBY_slot       = (((cdd)->p_cdd_device_attrs)->slot);
     1945 |         ddf->RBY_hw_state   = RBY_hw_state_is_unknown;
     1946 | 
     1947 |         /*---------------------------------------------------------
     1948 |         | Set value into POS registers
     1949 |         |---------------------------------------------------------*/
     1950 | 
     1951 |         ddf->RBY_hw_state = RBY_hw_state_is_pending_reset;
     1952 | 
     1953 |         /*----------------------------------
     1954 |         | Disable Adapter
     1955 |         |----------------------------------*/
     1956 |         RBY_PUT_POS( 2 , ( POS2_DISABLE )) ;
     1956 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),((( 0x00 )))); } ;
     1957 |         RETURN_ON_EXCEPTION;
     1957 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1958 | 
     1959 |         /*----------------------------------
     1960 |         | Write zeros to POS 6 and 7
     1961 |         |----------------------------------*/
     1962 |         RBY_PUT_POS( 6 , ( POS_CLEAR )) ;
     1962 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((6))))),((( 0x00 )))); } ;
     1963 |         RETURN_ON_EXCEPTION;
     1963 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1964 | 
     1965 |         RBY_PUT_POS( 7 , ( POS_CLEAR )) ;
     1965 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((7))))),((( 0x00 )))); } ;
     1966 |         RETURN_ON_EXCEPTION;
     1966 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1967 | 
     1968 |         /*----------------------------------
     1969 |         | Initialize POS 3
     1970 |                         POS3_PARITY_ENABLE |
     1971 |         |----------------------------------*/
     1972 |         RBY_PUT_POS( 3 ,
     1972 +         
     1973 |                        (POS3_M_STREAM_ENABLE |
     1974 |                         POS3_S_FEED_BACK_ENABLE |
     1975 |                         POS3_MAIN_ARB_LVL));
     1975 + { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(((0x80 | 0x40 | 0x08)))); };
     1976 |         RETURN_ON_EXCEPTION;
     1976 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1977 | 
     1978 |         /*----------------------------------
     1979 |         | Initialize POS 4
     1980 |                         POS4_CHANNEL_CK_ENABLE));
     1981 |         if ( !(cmd->cdd_flags & 0x000000f0) )
     1982 |         |----------------------------------*/
     1983 |         
     1984 |         temp1 = *((uint *)(CDD_svcs( cdd )->lockl));
     1984 +         temp1 = *((uint *)(((cdd)->p_cdd_svcs)->lockl));
     1985 |         temp2 = *((uint *)(CDD_svcs( cdd )->unlockl));
     1985 +         temp2 = *((uint *)(((cdd)->p_cdd_svcs)->unlockl));
     1986 |         if ( temp1 != temp2 )
     1987 |          {
     1988 |           /* AIX environemnt, turn off ROM enable bit  */
     1989 |           RBY_PUT_POS( 4 ,
     1989 +           
     1990 |                        (((ddf->RBY_base & 0x00F00000) >> 19) |
     1991 |                         POS4_M64_STREAM_ENABLE |
     1992 |                         0));
     1992 + { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((4))))),(((((ddf->RBY_base & 0x00F00000) >> 19) | 0x80 | 0)))); };
     1993 |           RETURN_ON_EXCEPTION;
     1993 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     1994 |          }
     1995 |         else
     1996 |          {
     1997 |           /* IPL ROS environemnt, turn on ROM enable bit  */
     1998 |           RBY_PUT_POS( 4 ,
     1998 +           
     1999 |                        (((ddf->RBY_base & 0x00F00000) >> 19) |
     2000 |                         0x20  |             /* ROM enable BIT   */
     2001 |                         POS4_M64_STREAM_ENABLE |
     2002 |                            2003 |   0));
     2003 + { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((4))))),(((((ddf->RBY_base & 0x00F00000) >> 19) | 0x20 | 0x80 | 0)))); };
     2004 |           RETURN_ON_EXCEPTION;
     2004 +           if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2005 |          }
     2006 | 
     2007 |         /*----------------------------------
     2008 |         | Initialize POS 5
     2009 |         |----------------------------------*/
     2010 |         RBY_PUT_POS( 5 ,
     2010 +         
     2011 |                         (POS5_CHANNEL_CK_FLAG |
     2012 |                          POS5_S_STREAM_ENABLE |
     2013 |                          POS5_S64_STREAM_ENABLE));
     2013 + { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((5))))),(((0xC0 | 0x10 | 0x08)))); };
     2014 |         RETURN_ON_EXCEPTION;
     2014 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2015 | 
     2016 |         /*---------------------------------------
     2017 |         | Select POS 3A by writing 0x01 to POS 7
     2018 |         |--------------------------------------*/
     2019 |         RBY_PUT_POS( 7 , 0x01 );
     2019 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((7))))),((0x01))); };
     2020 |         RETURN_ON_EXCEPTION;
     2020 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2021 | 
     2022 |         /*---------------------------------------
     2023 |         | Set adapter base address
     2024 |         |--------------------------------------*/
     2025 |         RBY_PUT_POS( 3 , ((ddf->RBY_base)>>24) );
     2025 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),((((ddf->RBY_base)>>24)))); };
     2026 |         RETURN_ON_EXCEPTION;
     2026 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2027 | 
     2028 |         /*---------------------------------------
     2029 |         | Select POS 3B by writing 0x01 to POS 6
     2030 |         |--------------------------------------*/
     2031 |         RBY_PUT_POS( 6 , 0x01 );
     2031 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((6))))),((0x01))); };
     2032 |         RETURN_ON_EXCEPTION;
     2032 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2033 | 
     2034 |         /*---------------------------------------
     2035 |         | Initialize POS 3B
     2036 |         |--------------------------------------*/
     2037 |         RBY_PUT_POS( 3 ,
     2037 +         
     2038 |                        (POS3B_BYTE_SWAP_SELECT     |
     2039 |                         POS3B_SEC_ARB_LVL_ENABLE |
     2040 |                         POS3B_SEC_ARB_LVL));
     2040 + { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((3))))),(((0x20 | 0x01 | 0x10)))); };
     2041 |         RETURN_ON_EXCEPTION;
     2041 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2042 | 
     2043 |         /*----------------------------------
     2044 |         | Write zeros to POS 6 and 7
     2045 |         |----------------------------------*/
     2046 |         RBY_PUT_POS( 6 , ( POS_CLEAR )) ;
     2046 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((6))))),((( 0x00 )))); } ;
     2047 |         RETURN_ON_EXCEPTION;
     2047 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2048 | 
     2049 |         RBY_PUT_POS( 7 , ( POS_CLEAR )) ;
     2049 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((7))))),((( 0x00 )))); } ;
     2050 |         RETURN_ON_EXCEPTION;
     2050 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2051 | 
     2052 |         /*-------------------------------------
     2053 |         | set POS 2 card enable
     2054 |         |--------------------------------------*/
     2055 |         RBY_PUT_POS( 2 , ( POS2_ENABLE )) ;
     2055 +         { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_c ))((RBY_ddf->RBY_iocc_seg),(( RBY_ddf->RBY_iocc_base + (((RBY_ddf->RBY_slot) << 16) | ((2))))),((( 0x01 )))); } ;
     2056 |         RETURN_ON_EXCEPTION;
     2056 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2057 | 
     2058 |         ddf->RBY_hw_state = RBY_hw_state_is_halted;
     2059 | 
     2060 |         /*------------------------------------------------------------
     2061 |         | if we fall through to here, then all of the registers
     2062 |         | are set, and we can assume that the adapter is ready
     2063 |         | to enter Common Character Mode
     2064 |         |------------------------------------------------------------*/
     2065 | 
     2066 |         CDD_exception( cdd )   = 0;
     2066 +         (((cdd)->p_cdd_device_attrs)->exception_code)   = 0;
     2067 | 
     2068 |         CDD_rc( cdd )          = E_CDD_PASS;
     2068 +         (((cdd)->p_cdd_command_attrs)->rc_out)          = E_CDD_PASS;
     2069 | 
     2070 | #ifdef RBYCDD
     2071 | printf("cdd_set_POS: exit\n");
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 2071.8: 1506-234 (W) Expecting a newline character on #endif directive.
     2072 | #endif RBYCDD
     2073 | 
     2074 |         return( E_CDD_PASS );
     2075 | 
     2076 | }
     2077 | 
     2078 | /*
     2079 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
     2080 |  *
     2081 |  * FUNCTIONS: check_cdd_structures
     2082 |  *
     2083 |  * ORIGINS: 27
     2084 |  *
     2085 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
     2086 |  * combined with the aggregated modules for this product)
     2087 |  * OBJECT CODE ONLY SOURCE MATERIALS
     2088 |  * (C) COPYRIGHT International Business Machines Corp. 1992
     2089 |  * All Rights Reserved
     2090 |  *
     2091 |  * US Government Users Restricted Rights - Use, duplication or
     2092 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
     2093 |  */
     2094 | 
     2095 | /*
     2096 |  *
     2097 |  *    PURPOSE:
     2098 |  *           The routines that are contained in here are static routines
     2099 |  *           in keeping with the programming conventions required for the
     2100 |  *           CDD Video ROM programming interface.  Therefore, this module
     2101 |  *           is NEVER compiled as a separate .o file that is linked with
     2102 |  *           other CDD routines.  Rather, this file must be included
     2103 |  *           INTO the source code of the CDD routines, before the definition
     2104 |  *           of the routines.
     2105 |  *
     2106 |  *           It is expected that in practice, the
     2107 |  *           actual CDD routines will include the header files, then this
     2108 |  *           package of subroutines, and then the source for the CDD routine.
     2109 |  */
     2110 | 
     2111 | /*
     2112 |  * NAME: check_cdd_structures
     2113 |  *
     2114 |  * FUNCTION:
     2115 |  *         First, make sure that the actual pointer is good.
     2116 |  *         Then, check each of the CDD structures in turn.
     2117 |  *         The procs and svcs structures are checked for null pointers.
     2118 |  *         The command attributes and device attributes structures also
     2119 |  *         contain pointers which are check for null contents
     2120 |  *
     2121 |  *   WARNING: this routine cannot have a static char SCCS id, because having
     2122 |  *   predefined strings will force this routine to require the use of RS/6000
     2123 |  *   register R2, which points to the TOC !!!
     2124 |  *
     2125 |  *
     2126 |  * EXECUTION ENVIRONMENT:
     2127 |  *          This code must be pinned.
     2128 |  *          These routines are expected to be in the device driver environment
     2129 |  *          of the kernel.
     2130 |  *
     2131 |  * (NOTES:)
     2132 |  *      Called from various routines in the Common Character Mode VDD
     2133 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
     2134 |  *
     2135 |  * (RECOVERY OPERATION:) None
     2136 |  *
     2137 |  * (DATA STRUCTURES:) cdd_header_t * cdd
     2138 |  *
     2139 |  * RETURNS:
     2140 |  *      an error code of type "int" with value 0 if OK, or with
     2141 |  *      nonzero error codes if not.  The error return values are stored
     2142 |  *      in the cdd.h header file in the appropriate member(s).
     2143 |  */
     2144 | 
     2145 | static int check_cdd_structures( cdd_header_t * cdd, ulong flags )
     2146 | {
     2147 | 
     2148 |         /*-------------------------------------------------
     2149 |         |
     2150 |         |  First test that the supplied pointer is valid
     2151 |         |
     2152 |         |----------------------------------------------------*/
     2153 | 
     2154 |         if  ( cdd   == NULL )
     2154 +         if  ( cdd   == 0 )
     2155 |                 return( E_CDD_FAIL );
     2156 | 
     2157 |         /*-------------------------------------------------
     2158 |         |
     2159 |         |  Check the supplied version
     2160 |         |
     2161 |         |----------------------------------------------------*/
     2162 | 
     2163 |         if  ( CDD_version( cdd ) != CDD_CURRENT_SW_VERSION )
     2163 +         if  ( ((cdd)->version) != CDD_CURRENT_SW_VERSION )
     2164 |                 return( E_CDD_VERSION );
     2165 | 
     2166 |         /*-------------------------------------------------
     2167 |         |
     2168 |         |  Test that the header structure itself is valid
     2169 |         |
     2170 |         |----------------------------------------------------*/
     2171 | 
     2172 |         if ( ( CDD_command( cdd ) == NULL ) ||
     2172 +         if ( ( ((cdd)->p_cdd_command_attrs) == 0 ) ||
     2173 |              ( CDD_device( cdd ) == NULL ) ||
     2173 +              ( ((cdd)->p_cdd_device_attrs) == 0 ) ||
     2174 |              ( CDD_svcs( cdd ) == NULL ) ||
     2174 +              ( ((cdd)->p_cdd_svcs) == 0 ) ||
     2175 |              ( CDD_procs( cdd ) == NULL ) )
     2175 +              ( ((cdd)->p_cdd_procs) == 0 ) )
     2176 |         {
     2177 |                 return( E_CDD_HDR );
     2178 |         }
     2179 | 
     2180 |         /*-------------------------------------------------
     2181 |         |
     2182 |         |  Test the device attributes structure subset that
     2183 |         |  should be present at every invocation
     2184 |         |
     2185 |         k----------------------------------------------------*/
     2186 | 
     2187 |         if ( flags & CDD_CHK_DEV_ARGS )
     2188 |         {
     2189 |                 if ( ( CDD_ddf( cdd ) == NULL ) ||
     2189 +                 if ( ( (((cdd)->p_cdd_device_attrs)->ddf_scratchpad) == 0 ) ||
     2190 |                       ( CDD_busmem_seg( cdd ) == NULL ) ||
     2190 +                       ( (((cdd)->p_cdd_device_attrs)->busmem_att) == 0 ) ||
     2191 |                       ( CDD_iocc_seg( cdd ) == NULL ) ||
     2191 +                       ( (((cdd)->p_cdd_device_attrs)->iocc_att) == 0 ) ||
     2192 |                       ( CDD_iocc_base( cdd ) == NULL ) ||
     2192 +                       ( (((cdd)->p_cdd_device_attrs)->iocc_addr_base) == 0 ) ||
     2193 |                       ( CDD_ddf_len( cdd ) < sizeof( rby_cdd_ddf ) ) )
     2193 +                       ( (((cdd)->p_cdd_device_attrs)->ddf_len) < sizeof( rby_cdd_ddf ) ) )
     2194 |                 {
     2195 |                         return( E_CDD_DEV_ARGS );
     2196 |                 }
     2197 |         }
     2198 | 
     2199 |         /*-------------------------------------------------
     2200 |         |
     2201 |         |  Test the procedure pointers of the procs structure
     2202 |         |
     2203 |         |----------------------------------------------------*/
     2204 | 
     2205 |         if ( flags & CDD_CHK_PROCS )
     2206 |            if ( ( (CDD_procs( cdd ) -> entry_point ) == NULL ) )
     2206 +            if ( ( (((cdd)->p_cdd_procs) -> entry_point ) == 0 ) )
     2207 |                     return( E_CDD_PROCS );
     2208 | 
     2209 | 
     2210 |         /*-------------------------------------------------
     2211 |         |
     2212 |         |  Test the procedure pointers of the svcs structure
     2213 |         |
     2214 |         |----------------------------------------------------*/
     2215 | 
     2216 |         if ( flags & CDD_CHK_SVCS )
     2217 |         {
     2218 |                 if ( ( (CDD_svcs( cdd ) -> i_enable ) == NULL ) ||
     2218 +                 if ( ( (((cdd)->p_cdd_svcs) -> i_enable ) == 0 ) ||
     2219 |                      ( (CDD_svcs( cdd ) -> i_disable ) == NULL ) ||
     2219 +                      ( (((cdd)->p_cdd_svcs) -> i_disable ) == 0 ) ||
     2220 |                      ( (CDD_svcs( cdd ) -> lockl ) == NULL )  ||
     2220 +                      ( (((cdd)->p_cdd_svcs) -> lockl ) == 0 )  ||
     2221 |                      ( (CDD_svcs( cdd ) -> unlockl ) == NULL ) ||
     2221 +                      ( (((cdd)->p_cdd_svcs) -> unlockl ) == 0 ) ||
     2222 |                      ( (CDD_svcs( cdd ) -> bus_get_l ) == NULL ) ||
     2222 +                      ( (((cdd)->p_cdd_svcs) -> bus_get_l ) == 0 ) ||
     2223 |                      ( (CDD_svcs( cdd ) -> bus_get_s ) == NULL ) ||
     2223 +                      ( (((cdd)->p_cdd_svcs) -> bus_get_s ) == 0 ) ||
     2224 |                      ( (CDD_svcs( cdd ) -> bus_get_c ) == NULL )  ||
     2224 +                      ( (((cdd)->p_cdd_svcs) -> bus_get_c ) == 0 )  ||
     2225 |                      ( (CDD_svcs( cdd ) -> bus_put_l ) == NULL )  ||
     2225 +                      ( (((cdd)->p_cdd_svcs) -> bus_put_l ) == 0 )  ||
     2226 |                      ( (CDD_svcs( cdd ) -> bus_put_s ) == NULL )  ||
     2226 +                      ( (((cdd)->p_cdd_svcs) -> bus_put_s ) == 0 )  ||
     2227 |                      ( (CDD_svcs( cdd ) -> bus_put_c ) == NULL ) ||
     2227 +                      ( (((cdd)->p_cdd_svcs) -> bus_put_c ) == 0 ) ||
     2228 |                      ( (CDD_svcs( cdd ) -> bus_cpy ) == NULL ) )
     2228 +                      ( (((cdd)->p_cdd_svcs) -> bus_cpy ) == 0 ) )
     2229 |                 {
     2230 |                         return( E_CDD_SVCS );
     2231 |                 }
     2232 |         }
     2233 | 
     2234 |         /*-------------------------------------------------
     2235 |         |
     2236 |         |  Fall through to here means everything checked out!
     2237 |         |
     2238 |         |----------------------------------------------------*/
     2239 | 
     2240 |         return( E_CDD_PASS );
     2241 | 
     2242 | }
     2243 | /*
     2244 |  * COMPONENT_NAME: (SYSDISPRBY) Common Character Mode Driver
     2245 |  *
     2246 |  * FUNCTIONS: cdd_blit
     2247 |  *
     2248 |  * ORIGINS: 27
     2249 |  *
     2250 |  * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
     2251 |  * combined with the aggregated modules for this product)
     2252 |  * OBJECT CODE ONLY SOURCE MATERIALS
     2253 |  * (C) COPYRIGHT International Business Machines Corp. 1992
     2254 |  * All Rights Reserved
     2255 |  *
     2256 |  * US Government Users Restricted Rights - Use, duplication or
     2257 |  * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
     2258 |  */
     2259 | 
     2260 | /*
     2261 |  * NAME: cdd_blit
     2262 |  *
     2263 |  * FUNCTION:  The CDD routines provide the device dependent functionality
     2264 |  *            needed to interface to the graphics adapter.  All hardware
     2265 |  *            knowledge of the adapters is kept in the CDD modules.  The calling
     2266 |  *            routines do not need device specific code to accomplish the common
     2267 |  *            character mode functionality.
     2268 |  *
     2269 |  *            The input parameter is the pointer to the cdd_header_t which
     2270 |  *            has pointers to the information that is needed to accomplish.
     2271 |  *
     2272 |  *   WARNING: this routine cannot have a static char SCCS id, because having
     2273 |  *   predefined strings will force this routine to require the use of RS/6000
     2274 |  *   register R2, which points to the TOC !!!
     2275 |  *
     2276 |  *              NOTES:
     2277 |  *
     2278 |  *              1. This function assumes that the pixel data that
     2279 |  *                 is supplied by the blit command structurei is glyph data,
     2280 |  *                 and has NOT been packed into the format required by the
     2281 |  *                 hardware,  and that an additional format change is
     2282 |  *                 required.
     2283 |  *
     2284 |  *                 The input data is shown graphically as follows:
     2285 |  *                 For a 13 X 4 Glyph:
     2286 |  *
     2287 |  *                 Byte wide memory:
     2288 |  *                 -------------------------
     2289 |  *      p_data->   |         8 bits        |
     2290 |  *                 -------------------------
     2291 |  *                 |    5 bits      |xxxxxx|
     2292 |  *                 -------------------------
     2293 |  *                 |         8 bits        |
     2294 |  *                 -------------------------
     2295 |  *                 |    5 bits      |xxxxxx|
     2296 |  *                 -------------------------
     2297 |  *                 |         8 bits        |
     2298 |  *                 -------------------------
     2299 |  *                 |    5 bits      |xxxxxx|
     2300 |  *                 -------------------------
     2301 |  *                 |         8 bits        |
     2302 |  *                 -------------------------
     2303 |  *                 |    5 bits      |xxxxxx|
     2304 |  *                 -------------------------
     2305 |  *
     2306 |  *                 Output data for 13X4 glyph
     2307 |  *                 Word (32bit) wide memory
     2308 |  *                 --------------------------------------------------
     2309 |  *      p_data->   |  13 bits Data     |    19 bits Unused          |
     2310 |  *                 --------------------------------------------------
     2311 |  *                 |  13 bits Data     |    19 bits Unused          |
     2312 |  *                 --------------------------------------------------
     2313 |  *                 |  13 bits Data     |    19 bits Unused          |
     2314 |  *                 --------------------------------------------------
     2315 |  *                 |  13 bits Data     |    19 bits Unused          |
     2316 |  *                 --------------------------------------------------
     2317 |  *
     2318 |  *              2. This function writes directly to the hardware.  It
     2319 |  *                 uses the CDD_busputl service. The command
     2320 |  *                 element for BLIT is one atomic thing, but it is best
     2321 |  *                 treated as a fixed length TOP part and a variable length
     2322 |  *                 BOTTOM part.  The top and bottom are defined in
     2323 |  *                 "rby_cdd_hw_defs.h".  The bottom is the set of pixels
     2324 |  *                 in hardware format.
     2325 |  *
     2326 |  *              3. This function does not handle "stride factor".  Thus,
     2327 |  *                 Subject only to the padding factor of the input pixmap,
     2328 |  *                 the input pixels are assumed to be in sequential, contiguous
     2329 |  *                 order.  After the first row of W pixels is accessed, the
     2330 |  *                 W+1 pixel begins in the next sequential byte of memory,
     2331 |  *                 subject only to pixmap pixel padding.
     2332 |  *
     2333 |  *              4. This function does not handle exceptions.  Instead,
     2334 |  *                 it passes them back to the caller for handling.
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 2334.2: 1506-342 (W) "/*" detected in comment.
     2335 | /*
     2336 |  * EXECUTION ENVIRONMENT:
     2337 |  *      This code is pageable.  It runs in all CDD environments:
     2338 |  *              - Kernel device driver
     2339 |  *              - AIX process (config method)
     2340 |  *              - System IPL ROS
     2341 |  *
     2342 |  * (NOTES:)
     2343 |  *      Called from various routines in the Common Character Mode VDD
     2344 |  *      and from the SYSTEM ROS of various platforms of RISC System/6000.
     2345 |  *
     2346 |  *      This routine writes directly to the hardware.  It may make use
     2347 |  *      of some standard CDD utilities found in "cdd_subrs.h" in the
     2348 |  *      same source directory as this routine.
     2349 |  *
     2350 |  *      All I/O accomplished by this routine is done through the CDD_svcs
     2351 |  *      routines as defined in the cdd_macros.h header file.
     2352 |  *      These routines are accessed via a pointer reference to the functions:
     2353 |  *      busgetc, busgets, busgetl, busputc, busputs, and busputl.
     2354 | 
     2355 |  *
     2356 |  * (RECOVERY OPERATION:) None
     2357 |  *
     2358 |  * (DATA STRUCTURES:) cdd_header_t * cdd
     2359 |  *
     2360 |  * RETURNS:
     2361 |  *      an error code of type "int" with value 0 if OK, or with
     2362 |  *      nonzero error codes if not.  The error return values are stored
     2363 |  *      in the cdd.h header file in the appropriate member(s).
     2364 |  */
     2365 | 
     2366 | static int cdd_blit( cdd_header_t * cdd )
     2367 | {
     2368 | 
     2369 |     cdd_blit_cmd_t * cmd;            /* to read in the command */
     2370 |     ushort           pixmap_len;     /* length of input pixmap */
     2371 |     char *           pixmap;         /* address of input pixmap */
     2372 | 
     2373 |     rby_cdd_ddf *  ddf;
     2374 |     rby_cdd_ddf *  RBY_ddf;
     2375 | 
     2376 |     int  rc;
     2377 |     char * hw_pixmap;
     2378 |     int    length;
     2379 |     int    row,
     2380 |            byte,
     2381 |            num_bytes;
     2382 | 
     2383 |     RBY_CDD_blit_SE    se;         /* holds SE for BLIT  */
     2384 |     RBY_CDD_blit_SE_bottom_t *p_se_bottom;
     2385 |     ushort     bottom_len;
     2386 |     ushort    se_length;
     2387 |     ulong     data;
     2388 | 
     2389 | /*-----------------------------------------------------
     2390 | |
     2391 | |       START OF SOURCE CODE
     2392 | |
     2393 | |------------------------------------------------------*/
     2394 | 
     2395 | #ifdef RBYCDD
     2396 |   printf("cdd_blit entered:cdd = %x \n",cdd);
"../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c", line 2396.8: 1506-234 (W) Expecting a newline character on #endif directive.
     2397 | #endif RBYCDD
     2398 |         rc = check_cdd_structures( cdd , CDD_CHK_ALL );
     2399 |         if ( rc != E_CDD_PASS )
     2400 |                 return( rc );
     2401 | 
     2402 |         /*------------------------------------------------------
     2403 |         |
     2404 |         |  Test the blit command specific parameters for
     2405 |         |  correctness
     2406 |         |
     2407 |              || (CDD_len_in( cdd ) <  sizeof( cdd_blit_cmd_t) ) )
     2408 |         |-------------------------------------------------------*/
     2409 | 
     2410 |         if ( (CDD_DataIn( cdd ) == NULL ))
     2410 +         if ( ((((cdd)->p_cdd_command_attrs)->pDataIn) == 0 ))
     2411 |         {
     2412 |                 CDD_rc( cdd )      = E_CDD_CMD_BLIT;
     2412 +                 (((cdd)->p_cdd_command_attrs)->rc_out)      = E_CDD_CMD_BLIT;
     2413 |                 return( E_CDD_CMD_BLIT );
     2414 |         }
     2415 | 
     2416 |         /*-------------------------------------------
     2417 |         | copy in the working length variables, for
     2418 |         | additional command checking
     2419 |         |
     2420 |         | NOTE: type casting is required on several macros
     2421 |         |       that otherwise return void *.
     2422 |         |--------------------------------------------*/
     2423 | 
     2424 |         cmd        = (cdd_blit_cmd_t *) CDD_DataIn( cdd );
     2424 +         cmd        = (cdd_blit_cmd_t *) (((cdd)->p_cdd_command_attrs)->pDataIn);
     2425 |         pixmap     = (char *) CDD_BLIT_pixel_ptr( cmd );
     2425 +         pixmap     = (char *) ( (cmd) -> p_PixelData );
     2426 |         pixmap_len = CDD_BLIT_pixel_len( cmd );
     2426 +         pixmap_len = ( (cmd) -> PixelDataLength );
     2427 |         ddf        = ( rby_cdd_ddf * ) CDD_ddf( cdd );
     2427 +         ddf        = ( rby_cdd_ddf * ) (((cdd)->p_cdd_device_attrs)->ddf_scratchpad);
     2428 |         RBY_ddf    = ddf;          /* used by the macros */
     2429 | 
     2430 |         /*---------------------------------------------
     2431 |         | do the additional checking on lengths of things
     2432 |         |---------------------------------------------*/
     2433 | 
     2434 |         if ( ( pixmap_len  > ( RBY_CDD_BLIT_MAX_WORDS * 4 ) )
     2435 |               ||  ( pixmap == NULL )
     2435 +               ||  ( pixmap == 0 )
     2436 |               || ( CDD_BLIT_x( cmd ) < 0 )
     2436 +               || ( ( (cmd) -> dest_x ) < 0 )
     2437 |               || ( CDD_BLIT_y( cmd ) < 0 )
     2437 +               || ( ( (cmd) -> dest_y ) < 0 )
     2438 |               || ( CDD_BLIT_w( cmd ) < 0 )
     2438 +               || ( ( (cmd) -> width ) < 0 )
     2439 |               || ( CDD_BLIT_h( cmd ) < 0 )
     2439 +               || ( ( (cmd) -> height ) < 0 )
     2440 |               || ( CDD_BLIT_x( cmd ) > RBY_CDD_BLIT_MAX_X )
     2440 +               || ( ( (cmd) -> dest_x ) > RBY_CDD_BLIT_MAX_X )
     2441 |               || ( CDD_BLIT_y( cmd ) > RBY_CDD_BLIT_MAX_Y )
     2441 +               || ( ( (cmd) -> dest_y ) > RBY_CDD_BLIT_MAX_Y )
     2442 |               || ( CDD_BLIT_w( cmd ) > RBY_CDD_BLIT_MAX_W )
     2442 +               || ( ( (cmd) -> width ) > RBY_CDD_BLIT_MAX_W )
     2443 |               || ( CDD_BLIT_h( cmd ) > RBY_CDD_BLIT_MAX_H ) )
     2443 +               || ( ( (cmd) -> height ) > RBY_CDD_BLIT_MAX_H ) )
     2444 |         {
     2445 |                 CDD_rc( cdd )      = E_CDD_CMD_BLIT;
     2445 +                 (((cdd)->p_cdd_command_attrs)->rc_out)      = E_CDD_CMD_BLIT;
     2446 |                 return( E_CDD_CMD_BLIT );
     2447 |         }
     2448 | 
     2449 |         /*-----------------------------------------------------
     2450 |         | Make sure there is some work to do
     2451 |         | It is OK to call with lengths of 0.
     2452 |         |-------------------------------------------------------*/
     2453 | 
     2454 |         if ( ( pixmap_len == 0 )
     2455 |              || ( CDD_BLIT_w( cmd ) == 0 )
     2455 +              || ( ( (cmd) -> width ) == 0 )
     2456 |              || ( CDD_BLIT_h( cmd ) == 0 ) )
     2456 +              || ( ( (cmd) -> height ) == 0 ) )
     2457 |         {
     2458 |                 CDD_exception( cdd )    = 0;
     2458 +                 (((cdd)->p_cdd_device_attrs)->exception_code)    = 0;
     2459 |                 CDD_rc( cdd )           = E_CDD_PASS;
     2459 +                 (((cdd)->p_cdd_command_attrs)->rc_out)           = E_CDD_PASS;
     2460 |                 return( E_CDD_PASS );
     2461 |         }
     2462 | 
     2463 |         /*--------------------------------------------------------
     2464 |         | Set the p_se_bottom to point to the correct pixels
     2465 |         |
     2466 |         | This may require conversion of formats, depending on the
     2467 |         | CDD_BLIT_format( ) results.
     2468 |         |
     2469 |         | We convert the byte aligned pixmap into a hardware format
     2470 |         | pixmap.  We use the ddf as a workspace.  We do not need to
     2471 |         | convert word-aligned pixmaps
     2472 |         |
     2473 |         | Conversion takes place a row at a time.
     2474 |         |---------------------------------------------------------*/
     2475 | 
     2476 |         if ( CDD_BLIT_format( cmd ) == CDD_BLIT_ALIGN_BYTE )
     2476 +         if ( ( (cmd) -> PixelFormat ) == CDD_BLIT_ALIGN_BYTE )
     2477 |         {
     2478 |                 hw_pixmap  = (char *) ddf->RBY_pixmap;
     2479 |                 num_bytes  = 1 + ( (CDD_BLIT_w(cmd) - 1 ) / 8 );
     2479 +                 num_bytes  = 1 + ( (( (cmd) -> width ) - 1 ) / 8 );
     2480 | 
     2481 |                 for( row = 0; row < CDD_BLIT_h( cmd ); row++ )
     2481 +                 for( row = 0; row < ( (cmd) -> height ); row++ )
     2482 |                 {
     2483 |                      for( byte = 0; byte < num_bytes; byte++, pixmap++)
     2484 |                      {
     2485 |                              *(hw_pixmap + byte) = *pixmap;
     2486 |                      }
     2487 |                      hw_pixmap += ( 1 + ( RBY_CDD_BLIT_MAX_W - 1 ) / 8 );
     2488 |                  }
     2489 | 
     2490 |                 p_se_bottom = (RBY_CDD_blit_SE_bottom_t *) ddf->RBY_pixmap;
     2491 |                 bottom_len  = CDD_BLIT_h( cmd );
     2491 +                 bottom_len  = ( (cmd) -> height );
     2492 | 
     2493 |         }
     2494 |         else
     2495 |         if ( (CDD_BLIT_format( cmd ) == CDD_BLIT_ALIGN_WORD )
     2495 +         if ( (( (cmd) -> PixelFormat ) == CDD_BLIT_ALIGN_WORD )
     2496 |            && ( sizeof(ulong) == ( 1 + ( RBY_CDD_BLIT_MAX_W - 1 ) / 8 ) ) )
     2497 |         {
     2498 |                 /*-------------------------------------
     2499 |                 | word aligned does not require conversion
     2500 |                 |-------------------------------------*/
     2501 |                 p_se_bottom = (RBY_CDD_blit_SE_bottom_t *)CDD_BLIT_pixel_ptr( cmd );
     2501 +                 p_se_bottom = (RBY_CDD_blit_SE_bottom_t *)( (cmd) -> p_PixelData );
     2502 |     /*     bottom_len  = ( pixmap_len / sizeof(ulong) );        */
     2503 | 
     2504 |                 bottom_len  = CDD_BLIT_h( cmd ); /* PM HAK      */
     2504 +                 bottom_len  = ( (cmd) -> height ); /* PM HAK      */
     2505 | 
     2506 |         }
     2507 |         else
     2508 |                 /*-----------------------------------------
     2509 |                 | check some error cases
     2510 |                 |------------------------------------------*/
     2511 | 
     2512 |         if ( ( sizeof(ulong) != ( 1 + ( RBY_CDD_BLIT_MAX_W - 1 ) / 8 ) ) )
     2513 |                 return( CDD_rc( cdd ) = E_CDD_INTERNAL_SW_ERROR );
     2513 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_INTERNAL_SW_ERROR );
     2514 |         else
     2515 |                 return( CDD_rc( cdd ) = E_CDD_CMD_BLIT );
     2515 +                 return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_CMD_BLIT );
     2516 | 
     2517 |         /*-----------------------------------------------
     2518 |         |  Passing through to here means we think we have
     2519 |         |  a valid blit command and valid cdd support structures.
     2520 |         |
     2521 |         |  Now set up the structure element needed
     2522 |         |  to pass pixel data to the hardware
     2523 |         |-------------------------------------------------------*/
     2524 |         se_length = ( bottom_len + RBY_CDD_BLIT_LEN_TOP);
     2525 |         RBY_SE_OP( &se )  = RBY_CDD_BLIT_OP;
     2525 +         ( (&se)->hdr.halfword.op )  = RBY_CDD_BLIT_OP;
     2526 | 
     2527 |         RBY_SE_LEN( &se )   = se_length;
     2527 +         ( (&se)->hdr.halfword.length )   = se_length;
     2528 | 
     2529 |         se.dx  = CDD_BLIT_x( cmd );
     2529 +         se.dx  = ( (cmd) -> dest_x );
     2530 |         /* convert lower left y to upper left GTO only
     2531 |         se.dy  = (0x3ff - (CDD_BLIT_y( cmd )));   */
     2532 |         se.dy  = CDD_BLIT_y( cmd );
     2532 +         se.dy  = ( (cmd) -> dest_y );
     2533 |         se.dw  = CDD_BLIT_w( cmd );
     2533 +         se.dw  = ( (cmd) -> width );
     2534 |         se.dh  = CDD_BLIT_h( cmd );           
     2534 +         se.dh  = ( (cmd) -> height );           
     2535 | 
     2536 | /*
     2537 |         se.len = (CDD_BLIT_w( cmd ) * CDD_BLIT_h( cmd )) / 4;
     2538 | */
     2539 | 
     2540 |         /*---------------------------------------------------------
     2541 |         | Write BLIT command and data to the adapter
     2542 |         | This is done on three(2) steps. In the first, we write
     2543 |         | 1) write the fixed part of the structure element
     2544 |         | 2) write the variable length BLIT data
     2545 |         | 3) write the command to start the BLIT
     2546 |         |--------------------------------------------------------*/
     2547 | 
     2548 |         /*-------------------------------------------------------
     2549 |         | Check diag status word on adapter before sending blit data
     2550 |         |------------------------------------------------------*/
     2551 |         do{
     2552 |         RBY_ddf->RBY_rc = CDD_busgetl( RBY_ddf->RBY_cdd,
     2552 +         RBY_ddf->RBY_rc = 
     2553 |                                        RBY_ddf->RBY_seg,
     2554 |                                        RBY_PTR_ERROR_WORD,
     2555 |                                        &(data));
     2555 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_get_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010004 )),(&(data)));
     2556 |         RETURN_ON_EXCEPTION;
     2556 +         if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2557 |         
     2558 |         if (data & ERROR_FLAGS)
     2558 +         if (data & 0x30000000)
     2559 |          {
     2560 | /*        
     2561 |           cdd->p_cdd_command_attrs->product_SRN[0] = '9';
     2562 |           cdd->p_cdd_command_attrs->product_SRN[1] = '0';
     2563 |           cdd->p_cdd_command_attrs->product_SRN[2] = '8';
     2564 |           cdd->p_cdd_command_attrs->product_SRN[3] = ((data & 0x00000f00) >> 8) + '0';
     2565 |           cdd->p_cdd_command_attrs->product_SRN[4] = ((data & 0x000000f0) >> 4) + '0';
     2566 |           cdd->p_cdd_command_attrs->product_SRN[5] = (data & 0x0000000f) + '0';
     2567 |           cdd->p_cdd_command_attrs->product_SRN[6] = '\0';
     2568 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     2569 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     2570 |           cdd->p_cdd_command_attrs->component_loc[0] = '0';
     2571 |           cdd->p_cdd_command_attrs->component_loc[0] = '\0';
     2572 | */
     2573 |           CDD_rc( cdd ) = E_CDD_BAD_HW_OP;
     2573 +           (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_BAD_HW_OP;
     2574 |           return( E_CDD_BAD_HW_OP );
     2575 |          }
     2576 |         }while (data != RCV_RDY);
     2576 +         }while (data != 0xC0000000);
     2577 | 
     2578 | 
     2579 |         RBY_WR_WORDS ( (ulong *) &se.dx, RBY_PTR_MAILBOX_OUT + 4,
     2579 +         
     2580 |                                          RBY_CDD_BLIT_LEN_TOP - 1 );
     2580 + { ulong _mac_num_words = (RBY_CDD_BLIT_LEN_TOP - 1); ulong * _src_ptr = ( ulong * ) ((ulong *) &se.dx); ulong * _tgt_ptr = ( ulong * ) ((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010124 ) + 4); while (_mac_num_words > 0) { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_l ))((RBY_ddf->RBY_seg),(_tgt_ptr),(*(_src_ptr))); if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); }; _src_ptr += 1; _tgt_ptr += 1; _mac_num_words -= 1; } };
     2581 | 
     2582 |         RBY_WR_WORDS ( (ulong *) p_se_bottom, (RBY_PTR_MAILBOX_OUT + 12),
     2582 +         
     2583 |                                          bottom_len );
     2583 + { ulong _mac_num_words = (bottom_len); ulong * _src_ptr = ( ulong * ) ((ulong *) p_se_bottom); ulong * _tgt_ptr = ( ulong * ) (((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010124 ) + 12)); while (_mac_num_words > 0) { RBY_ddf->RBY_rc = (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_l ))((RBY_ddf->RBY_seg),(_tgt_ptr),(*(_src_ptr))); if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); }; _src_ptr += 1; _tgt_ptr += 1; _mac_num_words -= 1; } };
     2584 | 
     2585 |         /*-------------------------------------------------
     2586 |         | Write BLIT command and length to start operation
     2587 |         |-------------------------------------------------*/
     2588 |          RBY_ddf->RBY_rc = CDD_busputl( RBY_ddf->RBY_cdd,
     2588 +          RBY_ddf->RBY_rc = 
     2589 |                                         RBY_ddf->RBY_seg,
     2590 |                                         RBY_PTR_MAILBOX_OUT,
     2591 |                                         se.hdr );
     2591 + (*( ((RBY_ddf->RBY_cdd)->p_cdd_svcs)->bus_put_l ))((RBY_ddf->RBY_seg),((ulong)( (( RBY_ddf -> RBY_base )) + 0x00010124 )),(se.hdr));
     2592 |          RETURN_ON_EXCEPTION;
     2592 +          if ( RBY_ddf->RBY_rc != 0 ) { (((RBY_ddf->RBY_cdd)->p_cdd_device_attrs)->exception_code) = RBY_ddf->RBY_rc; (((RBY_ddf->RBY_cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_IO_EXCEPTION; return (E_CDD_IO_EXCEPTION); };
     2593 | 
     2594 |         /*---------------------------------------------------------
     2595 |         |
     2596 |         | If we fall through to here, we are done.  The blit is
     2597 |         | now written into the hardware!!
     2598 |         |
     2599 |         |---------------------------------------------------------*/
     2600 | 
     2601 |         return( CDD_rc( cdd ) = E_CDD_PASS );
     2601 +         return( (((cdd)->p_cdd_command_attrs)->rc_out) = E_CDD_PASS );
     2602 | 
     2603 | }
     2604 | 

>>>>> OPTIONS SECTION <<<<<

C Set ++ for AIX Compiler Version 3.1 --- 
***   Command Line Invocation ***
***   Options In Effect   ***

NOA                 NOAE                NOANSIALIAS         NOBROWSE           
NOCOMPACT           NOCPLUSCMT          NODBCS              NODBXEXTRA         
NODIGRAPH           DOLLAR              EXTCHK              NOFULLPATH         
NOG                 NOGENPCOMP          NOGRAPHICS          NOHD               
IDIRFIRST           NOIGNERRNO          NOINLGLUE           NOLIBANSI          
LINEDIR             NOLIST              LISTOPT             NOMA               
NOMACPSTR           NOMBCS              NOOFFSET            NOONCE             
NOP                 NOPASCAL            NOPDF1              NOPDF2             
NOPHSINFO           PRINT               NOPROTO             NOPT               
NORO                NOROCONST           NORWVFTABLE         NOSHOWINC          
SOURCE              NOSRCMSG            NOSTATSYM           NOSTDINC           
STRICT              NOTOCDATA           NOUPCONV            USEPCOMP           
NOVOLATILEPARMS     NOXCALL             NOXCOFF             NOXPH2             

OPTIMIZE=2
INLINE THRESHOLD=20
ALIGN=POWER
ARCH=COMMON
ASSERT=NOTYPEPTR:NOALLPTRS:NOADDRTAKEN
ATTR
CHARS=UNSIGNED
CHECK=BOUNDS
CHECK=DIVZERO
CHECK=NULLPTR
DATAIMPORTED
ENUM=INT
FLAG=W:W
FLOAT=NOHSFLT:NORNDSNG:NOHSSNGLE:MAF:NORSQRT:NORRM:FOLD:NOSPNANS:NOFLTINT
FLTTRAP=NOOV:NOUND:NOZERO:NOINV:NOINEX:NOEN:NOIMP
NOGENPROTO
HALT=S
INFO=NOPRO
LANGLVL=EXTENDED
MAXMEM=-1
PROCUNKNOWN
SPILL=512
TUNE=DEFAULT
UNROLL=0
XFLAG=TRUE
XREF
YN (ROUND NEAR)
PROCLOCAL=i_disable
PROCLOCAL=disable_lock
PROCLOCAL=i_enable
PROCLOCAL=unlock_enable
PROCLOCAL=simple_lock
PROCLOCAL=simple_unlock
PROCLOCAL=fetch_and_add



>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<

CDD_ADDR_CHK                     enumeration constant: int
                                 67-93.9$  0-883.40   

CDD_ADDR_INCR                    enumeration constant: int
                                 67-94.9$  0-884.40   

CDD_BLIT_ALIGN_BYTE              enumeration constant: int
                                 67-278.9$  0-2475.40   

CDD_BLIT_ALIGN_WORD              enumeration constant: int
                                 67-279.9$  0-2494.41   

CDD_BUS_IO_MASK                  enumeration constant: int
                                 67-96.9$  0-398.18   0-600.18   0-1082.16   0-1447.17   
                                 0-1915.17   

CDD_BUSx                         enumeration constant: int
                                 67-81.9$  0-398.18   0-398.18   0-400.18   0-400.18   
                                 0-600.18   0-600.18   0-602.18   0-602.18   0-881.40   
                                 0-1082.16   0-1082.16   0-1447.17   0-1447.17   0-1449.17   
                                 0-1449.17   0-1915.17   0-1915.17   0-1917.17   0-1917.17   

CDD_BYPASS_TCW                   enumeration constant: int
                                 67-92.9$  0-885.40   

CDD_CHK_ALL                      enumeration constant: int
                                 69-140.9$  0-378.42   0-580.42   0-1036.42   0-1398.42   
                                 0-1882.42   0-2397.42   

CDD_CHK_DEV_ARGS                 enumeration constant: int
                                 69-137.9$  0-2186.22   

CDD_CHK_PROCS                    enumeration constant: int
                                 69-138.9$  0-2204.22   

CDD_CHK_SVCS                     enumeration constant: int
                                 69-139.9$  0-2215.22   

CDD_CMD_BLIT                     enumeration constant: int
                                 67-273.9$  0-202.14   

CDD_CMD_DISABLE                  enumeration constant: int
                                 67-266.9$  0-214.14   

CDD_CMD_ENABLE                   enumeration constant: int
                                 67-260.9$  0-210.14   

CDD_CMD_INIT                     enumeration constant: int
                                 67-220.9$  0-206.14   0-829.32   

CDD_CMD_LOAD_UCODE               enumeration constant: int
                                 67-285.9$  0-218.14   

CDD_CMD_QVPD                     enumeration constant: int
                                 67-297.9$  0-226.14   0-1408.33   

CDD_CMD_SET_POS                  enumeration constant: int
                                 67-311.9$  0-222.14   

CDD_CURRENT_SW_VERSION           enumeration constant: int
                                 67-158.9$  0-796.36   0-2162.37   

CDD_IOCC_0_BID                   enumeration constant: int
                                 67-100.9$  0-892.40   

CDD_IOCC_BASE                    enumeration constant: int
                                 67-105.9$  0-400.18   0-602.18   0-894.40   0-1449.17   
                                 0-1917.17   

CDD_IOCC_SELECT                  enumeration constant: int
                                 67-91.9$  0-398.18   0-400.18   0-400.18   0-600.18   
                                 0-602.18   0-602.18   0-1082.16   0-1447.17   0-1449.17   
                                 0-1449.17   0-1915.17   0-1917.17   0-1917.17   

CDD_IOCC_TOP                     enumeration constant: int
                                 67-106.9$  0-400.18   0-602.18   0-1449.17   0-1917.17   

CDD_MAXNAMELEN                   enumeration constant: int
                                 67-162.9$  67-566.23   

CDD_MAX_60x_BUID_REGS            enumeration constant: int
                                 67-319.10$  67-493.35   67-687.35   

CDD_MAX_BUSMEM_RANGES            enumeration constant: int
                                 67-313.9$  67-486.40   67-487.46   67-654.40   67-655.46   
                                 0-875.22   

CDD_ORIGIN_UL                    enumeration constant: int
                                 67-275.9$  0-904.36   

CDD_ROS_COMPONENT_LOC_SIZE       enumeration constant: int
                                 67-168.9$  67-538.40   

CDD_ROS_PRODUCT_NAME_SIZE        enumeration constant: int
                                 67-171.9$  67-681.39   

CDD_ROS_PRODUCT_SRN_SIZE         enumeration constant: int
                                 67-169.9$  67-546.38   

CDD_SEG_T_BIT                    enumeration constant: int
                                 67-90.9$  0-398.18   0-398.18   0-400.18   0-400.18   
                                 0-600.18   0-600.18   0-602.18   0-602.18   0-882.40   
                                 0-1082.16   0-1082.16   0-1447.17   0-1447.17   0-1449.17   
                                 0-1449.17   0-1915.17   0-1915.17   0-1917.17   0-1917.17   

CDD_VPD_MAX_LEN                  enumeration constant: int
                                 67-299.9$  67-362.25   0-1482.46   

CDD_VPD_MAX_SLOTS                enumeration constant: int
                                 67-301.9$  67-370.32   

CDD_VPD_VERSION_LENGTH           enumeration constant: int
                                 67-303.9$  67-364.30   

DomainLock                       struct tag
                                 14-105.16$  14-105.27{  14-108.9}  15-487.12   

E_CDD_BAD_CMD                    enumeration constant: int
                                 67-197.9$  0-231.22   

E_CDD_BAD_HW_OP                  enumeration constant: int
                                 67-206.9$  0-1224.27   0-1225.19   0-1515.27   0-1516.19   
                                 0-2572.27   0-2573.19   

E_CDD_CMD_ARGS                   enumeration constant: int
                                 67-191.9$  0-837.33   0-838.25   0-1051.34   0-1052.25   
                                 0-1415.38   0-1416.25   0-1893.41   

E_CDD_CMD_BLIT                   enumeration constant: int
                                 67-199.9$  0-2411.38   0-2412.25   0-2444.38   0-2445.25   
                                 0-2514.41   

E_CDD_CMD_QVPD                   enumeration constant: int
                                 67-203.9$  0-1434.38   0-1435.25   

E_CDD_CMD_SET_POS                enumeration constant: int
                                 67-201.9$  0-1904.41   

E_CDD_DEV_ARGS                   enumeration constant: int
                                 67-192.9$  0-404.41   0-605.41   0-817.25   0-1085.33   
                                 0-1086.25   0-1452.38   0-1453.25   0-1924.41   0-2194.33   

E_CDD_FAIL                       enumeration constant: int
                                 67-187.9$  0-790.25   0-2154.25   

E_CDD_HDR                        enumeration constant: int
                                 67-190.9$  0-175.25   0-184.25   0-806.25   0-2176.25   

E_CDD_INTERNAL_SW_ERROR          enumeration constant: int
                                 67-207.9$  0-2512.41   

E_CDD_IO_EXCEPTION               enumeration constant: int
                                 67-198.9$  0-437.9   0-437.9   0-440.9   0-440.9   
                                 0-636.9   0-636.9   0-639.9   0-639.9   0-1125.9   
                                 0-1125.9   0-1128.9   0-1128.9   0-1138.13   0-1138.13   
                                 0-1147.13   0-1147.13   0-1154.9   0-1154.9   0-1157.9   
                                 0-1157.9   0-1170.13   0-1170.13   0-1184.13   0-1184.13   
                                 0-1190.13   0-1190.13   0-1497.13   0-1497.13   0-1544.10   
                                 0-1544.10   0-1576.11   0-1576.11   0-1582.11   0-1582.11   
                                 0-1591.11   0-1591.11   0-1597.11   0-1597.11   0-1611.12   
                                 0-1611.12   0-1635.11   0-1635.11   0-1641.11   0-1641.11   
                                 0-1650.11   0-1650.11   0-1656.11   0-1656.11   0-1670.12   
                                 0-1670.12   0-1701.11   0-1701.11   0-1707.11   0-1707.11   
                                 0-1716.11   0-1716.11   0-1722.11   0-1722.11   0-1736.12   
                                 0-1736.12   0-1957.9   0-1957.9   0-1963.9   0-1963.9   
                                 0-1966.9   0-1966.9   0-1976.9   0-1976.9   0-1993.11   
                                 0-1993.11   0-2003.11   0-2003.11   0-2013.9   0-2013.9   
                                 0-2019.9   0-2019.9   0-2025.9   0-2025.9   0-2031.9   
                                 0-2031.9   0-2040.9   0-2040.9   0-2046.9   0-2046.9   
                                 0-2049.9   0-2049.9   0-2055.9   0-2055.9   0-2555.9   
                                 0-2555.9   0-2578.9   0-2578.9   0-2581.9   0-2581.9   
                                 0-2591.10   0-2591.10   

E_CDD_PASS                       enumeration constant: int
                                 67-186.9$  0-380.20   0-452.43   0-457.17   0-582.20   
                                 0-651.43   0-657.17   0-944.25   0-950.17   0-1038.20   
                                 0-1269.32   0-1276.17   0-1400.20   0-1754.30   0-1756.15   
                                 0-1883.20   0-2067.34   0-2073.17   0-2239.17   0-2398.20   
                                 0-2458.43   0-2459.25   0-2600.33   

E_CDD_PROCS                      enumeration constant: int
                                 67-193.9$  0-2206.29   

E_CDD_SVCS                       enumeration constant: int
                                 67-194.9$  0-2229.33   

E_CDD_VERSION                    enumeration constant: int
                                 67-196.9$  0-797.25   0-2163.25   

PixelDataLength                  unsigned short in struct at offset 4
                                 67-798.25$  0-2425.22   

PixelFormat                      unsigned long in struct at offset 8
                                 67-799.25$  0-2475.14   0-2494.15   

RBY_CDD_BLIT_LEN_TOP             enumeration constant: int
                                 69-78.9$  0-2523.36   0-2579.42   

RBY_CDD_BLIT_MAX_H               enumeration constant: int
                                 69-86.9$  69-225.37   0-902.36   0-903.58   0-2442.40   

RBY_CDD_BLIT_MAX_W               enumeration constant: int
                                 69-85.9$  0-901.36   0-903.37   0-2441.40   0-2486.43   
                                 0-2495.42   0-2511.41   

RBY_CDD_BLIT_MAX_WORDS           enumeration constant: int
                                 69-80.9$  0-2433.32   

RBY_CDD_BLIT_MAX_X               enumeration constant: int
                                 69-82.9$  0-1255.43   0-2439.40   

RBY_CDD_BLIT_MAX_Y               enumeration constant: int
                                 69-83.9$  0-1257.43   0-2440.40   

RBY_CDD_BLIT_OP                  enumeration constant: int
                                 69-72.9$  0-2524.29   

RBY_CDD_INIT_OP                  enumeration constant: int
                                 69-70.9$  0-1236.40   

RBY_DEFAULT_BUSMEM_BASE          enumeration constant: int
                                 69-90.9$  0-872.44   

RBY_DEFAULT_BUSMEM_LEN           enumeration constant: int
                                 69-91.9$  0-873.44   

RBY_base                         unsigned long in struct at offset 16
                                 69-219.25$  0-422.12#  0-622.12#  0-1103.12#  0-1168.46   
                                 0-1235.40   0-1471.12#  0-1495.44   0-1542.41   0-1570.21   
                                 0-1941.12#  0-1990.30   0-1999.30   0-2024.27   0-2553.40   
                                 0-2578.42   0-2581.48   0-2589.41   

RBY_cdd                          pointer to struct with no tag in struct at offset 4
                                 69-216.22$  0-420.12#  0-436.9   0-437.9   0-437.9   
                                 0-439.9   0-440.9   0-440.9   0-620.12#  0-635.9   
                                 0-636.9   0-636.9   0-638.9   0-639.9   0-639.9   
                                 0-1101.12#  0-1124.9   0-1125.9   0-1125.9   0-1127.9   
                                 0-1128.9   0-1128.9   0-1137.13   0-1138.13   0-1138.13   
                                 0-1142.29   0-1146.13   0-1147.13   0-1147.13   0-1153.9   
                                 0-1154.9   0-1154.9   0-1156.9   0-1157.9   0-1157.9   
                                 0-1166.33   0-1170.13   0-1170.13   0-1183.13   0-1184.13   
                                 0-1184.13   0-1185.31   0-1189.13   0-1190.13   0-1190.13   
                                 0-1233.27   0-1469.12#  0-1493.31   0-1497.13   0-1497.13   
                                 0-1540.28   0-1544.10   0-1544.10   0-1572.29   0-1576.11   
                                 0-1576.11   0-1578.29   0-1582.11   0-1582.11   0-1587.29   
                                 0-1591.11   0-1591.11   0-1593.29   0-1597.11   0-1597.11   
                                 0-1607.33   0-1611.12   0-1611.12   0-1631.29   0-1635.11   
                                 0-1635.11   0-1637.29   0-1641.11   0-1641.11   0-1646.29   
                                 0-1650.11   0-1650.11   0-1652.29   0-1656.11   0-1656.11   
                                 0-1666.33   0-1670.12   0-1670.12   0-1697.29   0-1701.11   
                                 0-1701.11   0-1703.29   0-1707.11   0-1707.11   0-1712.29   
                                 0-1716.11   0-1716.11   0-1718.29   0-1722.11   0-1722.11   
                                 0-1732.33   0-1736.12   0-1736.12   0-1939.12#  0-1956.9   
                                 0-1957.9   0-1957.9   0-1962.9   0-1963.9   0-1963.9   
                                 0-1965.9   0-1966.9   0-1966.9   0-1972.9   0-1976.9   
                                 0-1976.9   0-1989.11   0-1993.11   0-1993.11   0-1998.11   
                                 0-2003.11   0-2003.11   0-2009.9   0-2013.9   0-2013.9   
                                 0-2018.9   0-2019.9   0-2019.9   0-2024.9   0-2025.9   
                                 0-2025.9   0-2030.9   0-2031.9   0-2031.9   0-2036.9   
                                 0-2040.9   0-2040.9   0-2045.9   0-2046.9   0-2046.9   
                                 0-2048.9   0-2049.9   0-2049.9   0-2054.9   0-2055.9   
                                 0-2055.9   0-2551.27   0-2555.9   0-2555.9   0-2578.9   
                                 0-2578.9   0-2578.9   0-2581.9   0-2581.9   0-2581.9   
                                 0-2587.28   0-2591.10   0-2591.10   

RBY_ddf                          auto pointer to struct with no tag in function cdd_disable
                                 0-561.32$  0-618.9#  0-635.9   0-635.9   0-635.9   
                                 0-635.9   0-635.9   0-636.9   0-636.9   0-636.9   
                                 0-636.9   0-638.9   0-638.9   0-638.9   0-638.9   
                                 0-638.9   0-639.9   0-639.9   0-639.9   0-639.9   

RBY_ddf                          auto pointer to struct with no tag in function cdd_load_ucode
                                 0-1025.21$  0-1099.9#  0-1124.9   0-1124.9   0-1124.9   
                                 0-1124.9   0-1124.9   0-1125.9   0-1125.9   0-1125.9   
                                 0-1125.9   0-1127.9   0-1127.9   0-1127.9   0-1127.9   
                                 0-1127.9   0-1128.9   0-1128.9   0-1128.9   0-1128.9   
                                 0-1137.13   0-1137.13   0-1137.13   0-1137.13   0-1137.13   
                                 0-1138.13   0-1138.13   0-1138.13   0-1138.13   0-1143.40   
                                 0-1142.42   0-1142.11   0-1146.13   0-1146.13   0-1146.13   
                                 0-1146.13   0-1146.13   0-1147.13   0-1147.13   0-1147.13   
                                 0-1147.13   0-1153.9   0-1153.9   0-1153.9   0-1153.9   
                                 0-1153.9   0-1154.9   0-1154.9   0-1154.9   0-1154.9   
                                 0-1156.9   0-1156.9   0-1156.9   0-1156.9   0-1156.9   
                                 0-1157.9   0-1157.9   0-1157.9   0-1157.9   0-1167.46   
                                 0-1168.46   0-1166.46   0-1166.15   0-1170.13   0-1170.13   
                                 0-1170.13   0-1170.13   0-1183.13   0-1183.13   0-1183.13   
                                 0-1183.13   0-1183.13   0-1184.13   0-1184.13   0-1184.13   
                                 0-1184.13   0-1186.40   0-1185.44   0-1185.13   0-1189.13   
                                 0-1189.13   0-1189.13   0-1189.13   0-1189.13   0-1190.13   
                                 0-1190.13   0-1190.13   0-1190.13   0-1234.40   0-1235.40   
                                 0-1233.40   0-1233.9   

RBY_ddf                          auto pointer to struct with no tag in function cdd_qvpd
                                 0-1369.21$  0-1467.9#  0-1494.44   0-1495.44   0-1493.44   
                                 0-1493.13   0-1497.13   0-1497.13   0-1497.13   0-1497.13   
                                 0-1541.41   0-1542.41   0-1540.41   0-1540.10   0-1544.10   
                                 0-1544.10   0-1544.10   0-1544.10   0-1570.21   0-1573.41   
                                 0-1572.42   0-1572.11   0-1576.11   0-1576.11   0-1576.11   
                                 0-1576.11   0-1579.41   0-1578.42   0-1578.11   0-1582.11   
                                 0-1582.11   0-1582.11   0-1582.11   0-1588.41   0-1587.42   
                                 0-1587.11   0-1591.11   0-1591.11   0-1591.11   0-1591.11   
                                 0-1594.41   0-1593.42   0-1593.11   0-1597.11   0-1597.11   
                                 0-1597.11   0-1597.11   0-1608.44   0-1607.46   0-1607.15   
                                 0-1611.12   0-1611.12   0-1611.12   0-1611.12   0-1632.41   
                                 0-1631.42   0-1631.11   0-1635.11   0-1635.11   0-1635.11   
                                 0-1635.11   0-1638.41   0-1637.42   0-1637.11   0-1641.11   
                                 0-1641.11   0-1641.11   0-1641.11   0-1647.41   0-1646.42   
                                 0-1646.11   0-1650.11   0-1650.11   0-1650.11   0-1650.11   
                                 0-1653.41   0-1652.42   0-1652.11   0-1656.11   0-1656.11   
                                 0-1656.11   0-1656.11   0-1667.44   0-1666.46   0-1666.15   
                                 0-1670.12   0-1670.12   0-1670.12   0-1670.12   0-1698.41   
                                 0-1697.42   0-1697.11   0-1701.11   0-1701.11   0-1701.11   
                                 0-1701.11   0-1704.41   0-1703.42   0-1703.11   0-1707.11   
                                 0-1707.11   0-1707.11   0-1707.11   0-1713.41   0-1712.42   
                                 0-1712.11   0-1716.11   0-1716.11   0-1716.11   0-1716.11   
                                 0-1719.41   0-1718.42   0-1718.11   0-1722.11   0-1722.11   
                                 0-1722.11   0-1722.11   0-1733.44   0-1732.46   0-1732.15   
                                 0-1736.12   0-1736.12   0-1736.12   0-1736.12   

RBY_ddf                          auto pointer to struct with no tag in function cdd_set_POS
                                 0-1863.21$  0-1937.9#  0-1956.9   0-1956.9   0-1956.9   
                                 0-1956.9   0-1956.9   0-1957.9   0-1957.9   0-1957.9   
                                 0-1957.9   0-1962.9   0-1962.9   0-1962.9   0-1962.9   
                                 0-1962.9   0-1963.9   0-1963.9   0-1963.9   0-1963.9   
                                 0-1965.9   0-1965.9   0-1965.9   0-1965.9   0-1965.9   
                                 0-1966.9   0-1966.9   0-1966.9   0-1966.9   0-1972.9   
                                 0-1972.9   0-1972.9   0-1972.9   0-1972.9   0-1976.9   
                                 0-1976.9   0-1976.9   0-1976.9   0-1989.11   0-1989.11   
                                 0-1989.11   0-1989.11   0-1989.11   0-1993.11   0-1993.11   
                                 0-1993.11   0-1993.11   0-1998.11   0-1998.11   0-1998.11   
                                 0-1998.11   0-1998.11   0-2003.11   0-2003.11   0-2003.11   
                                 0-2003.11   0-2009.9   0-2009.9   0-2009.9   0-2009.9   
                                 0-2009.9   0-2013.9   0-2013.9   0-2013.9   0-2013.9   
                                 0-2018.9   0-2018.9   0-2018.9   0-2018.9   0-2018.9   
                                 0-2019.9   0-2019.9   0-2019.9   0-2019.9   0-2024.9   
                                 0-2024.9   0-2024.9   0-2024.9   0-2024.9   0-2025.9   
                                 0-2025.9   0-2025.9   0-2025.9   0-2030.9   0-2030.9   
                                 0-2030.9   0-2030.9   0-2030.9   0-2031.9   0-2031.9   
                                 0-2031.9   0-2031.9   0-2036.9   0-2036.9   0-2036.9   
                                 0-2036.9   0-2036.9   0-2040.9   0-2040.9   0-2040.9   
                                 0-2040.9   0-2045.9   0-2045.9   0-2045.9   0-2045.9   
                                 0-2045.9   0-2046.9   0-2046.9   0-2046.9   0-2046.9   
                                 0-2048.9   0-2048.9   0-2048.9   0-2048.9   0-2048.9   
                                 0-2049.9   0-2049.9   0-2049.9   0-2049.9   0-2054.9   
                                 0-2054.9   0-2054.9   0-2054.9   0-2054.9   0-2055.9   
                                 0-2055.9   0-2055.9   0-2055.9   

RBY_ddf                          auto pointer to struct with no tag in function cdd_blit
                                 0-2373.17$  0-2427.9#  0-2552.40   0-2553.40   0-2551.40   
                                 0-2551.9   0-2555.9   0-2555.9   0-2555.9   0-2555.9   
                                 0-2578.42   0-2578.9   0-2578.9   0-2578.9   0-2578.9   
                                 0-2578.9   0-2578.9   0-2578.9   0-2581.48   0-2581.9   
                                 0-2581.9   0-2581.9   0-2581.9   0-2581.9   0-2581.9   
                                 0-2581.9   0-2588.41   0-2589.41   0-2587.41   0-2587.10   
                                 0-2591.10   0-2591.10   0-2591.10   0-2591.10   

RBY_ddf                          auto pointer to struct with no tag in function cdd_enable
                                 0-359.31$  0-417.9#  0-436.9   0-436.9   0-436.9   
                                 0-436.9   0-436.9   0-437.9   0-437.9   0-437.9   
                                 0-437.9   0-439.9   0-439.9   0-439.9   0-439.9   
                                 0-439.9   0-440.9   0-440.9   0-440.9   0-440.9   

RBY_hw_state                     int in struct at offset 36
                                 69-224.25$  0-1106.12#  0-1228.12#  0-1238.12#  0-1475.12#  
                                 0-1945.12#  0-1951.12#  0-2057.12#  

RBY_hw_state_is_halted           enumeration constant: int
                                 69-130.9$  0-2057.29   

RBY_hw_state_is_pending_reset    enumeration constant: int
                                 69-129.9$  0-1951.29   

RBY_hw_state_is_reset            enumeration constant: int
                                 69-123.9$  0-1228.29   

RBY_hw_state_is_reset_and_CCM    enumeration constant: int
                                 69-124.9$  0-1238.29   

RBY_hw_state_is_unknown          enumeration constant: int
                                 69-122.9$  0-1106.31   0-1475.30   0-1945.31   

RBY_iocc_base                    unsigned long in struct at offset 20
                                 69-220.25$  0-424.12#  0-436.9   0-439.9   0-624.12#  
                                 0-635.9   0-638.9   0-1124.9   0-1127.9   0-1137.13   
                                 0-1146.13   0-1153.9   0-1156.9   0-1183.13   0-1189.13   
                                 0-1473.12#  0-1943.12#  0-1956.9   0-1962.9   0-1965.9   
                                 0-1972.9   0-1989.11   0-1998.11   0-2009.9   0-2018.9   
                                 0-2024.9   0-2030.9   0-2036.9   0-2045.9   0-2048.9   
                                 0-2054.9   

RBY_iocc_seg                     unsigned long in struct at offset 12
                                 69-218.25$  0-423.12#  0-436.9   0-439.9   0-623.12#  
                                 0-635.9   0-638.9   0-1124.9   0-1127.9   0-1137.13   
                                 0-1142.29   0-1146.13   0-1153.9   0-1156.9   0-1183.13   
                                 0-1185.31   0-1189.13   0-1472.12#  0-1942.12#  0-1956.9   
                                 0-1962.9   0-1965.9   0-1972.9   0-1989.11   0-1998.11   
                                 0-2009.9   0-2018.9   0-2024.9   0-2030.9   0-2036.9   
                                 0-2045.9   0-2048.9   0-2054.9   

RBY_len_ucode                    unsigned long in struct at offset 28
                                 69-222.25$  0-1104.12#  

RBY_p_ucode                      pointer to unsigned char in struct at offset 32
                                 69-223.14$  0-1105.12#  

RBY_pixmap                       array[64] of unsigned long in struct at offset 40
                                 69-225.25$  0-2477.42   0-2489.63   

RBY_rc                           int in struct at offset 0
                                 69-215.25$  0-419.12#  0-436.9#  0-437.9   0-437.9   
                                 0-439.9#  0-440.9   0-440.9   0-619.12#  0-635.9#  
                                 0-636.9   0-636.9   0-638.9#  0-639.9   0-639.9   
                                 0-1100.12#  0-1124.9#  0-1125.9   0-1125.9   0-1127.9#  
                                 0-1128.9   0-1128.9   0-1137.13#  0-1138.13   0-1138.13   
                                 0-1142.18#  0-1146.13#  0-1147.13   0-1147.13   0-1153.9#  
                                 0-1154.9   0-1154.9   0-1156.9#  0-1157.9   0-1157.9   
                                 0-1166.22#  0-1170.13   0-1170.13   0-1183.13#  0-1184.13   
                                 0-1184.13   0-1185.20#  0-1189.13#  0-1190.13   0-1190.13   
                                 0-1233.16#  0-1468.12#  0-1493.20#  0-1497.13   0-1497.13   
                                 0-1540.17#  0-1544.10   0-1544.10   0-1572.18#  0-1576.11   
                                 0-1576.11   0-1578.18#  0-1582.11   0-1582.11   0-1587.18#  
                                 0-1591.11   0-1591.11   0-1593.18#  0-1597.11   0-1597.11   
                                 0-1607.22#  0-1611.12   0-1611.12   0-1631.18#  0-1635.11   
                                 0-1635.11   0-1637.18#  0-1641.11   0-1641.11   0-1646.18#  
                                 0-1650.11   0-1650.11   0-1652.18#  0-1656.11   0-1656.11   
                                 0-1666.22#  0-1670.12   0-1670.12   0-1697.18#  0-1701.11   
                                 0-1701.11   0-1703.18#  0-1707.11   0-1707.11   0-1712.18#  
                                 0-1716.11   0-1716.11   0-1718.18#  0-1722.11   0-1722.11   
                                 0-1732.22#  0-1736.12   0-1736.12   0-1938.12#  0-1956.9#  
                                 0-1957.9   0-1957.9   0-1962.9#  0-1963.9   0-1963.9   
                                 0-1965.9#  0-1966.9   0-1966.9   0-1972.9#  0-1976.9   
                                 0-1976.9   0-1989.11#  0-1993.11   0-1993.11   0-1998.11#  
                                 0-2003.11   0-2003.11   0-2009.9#  0-2013.9   0-2013.9   
                                 0-2018.9#  0-2019.9   0-2019.9   0-2024.9#  0-2025.9   
                                 0-2025.9   0-2030.9#  0-2031.9   0-2031.9   0-2036.9#  
                                 0-2040.9   0-2040.9   0-2045.9#  0-2046.9   0-2046.9   
                                 0-2048.9#  0-2049.9   0-2049.9   0-2054.9#  0-2055.9   
                                 0-2055.9   0-2551.16#  0-2555.9   0-2555.9   0-2578.9#  
                                 0-2578.9   0-2578.9   0-2581.9#  0-2581.9   0-2581.9   
                                 0-2587.17#  0-2591.10   0-2591.10   

RBY_seg                          unsigned long in struct at offset 8
                                 69-217.25$  0-421.12#  0-621.12#  0-1102.12#  0-1166.33   
                                 0-1233.27   0-1470.12#  0-1493.31   0-1540.28   0-1572.29   
                                 0-1578.29   0-1587.29   0-1593.29   0-1607.33   0-1631.29   
                                 0-1637.29   0-1646.29   0-1652.29   0-1666.33   0-1697.29   
                                 0-1703.29   0-1712.29   0-1718.29   0-1732.33   0-1940.12#  
                                 0-2551.27   0-2578.9   0-2581.9   0-2587.28   

RBY_slot                         unsigned long in struct at offset 24
                                 69-221.25$  0-425.12#  0-436.9   0-439.9   0-625.12#  
                                 0-635.9   0-638.9   0-1124.9   0-1127.9   0-1137.13   
                                 0-1146.13   0-1153.9   0-1156.9   0-1183.13   0-1189.13   
                                 0-1474.12#  0-1944.12#  0-1956.9   0-1962.9   0-1965.9   
                                 0-1972.9   0-1989.11   0-1998.11   0-2009.9   0-2018.9   
                                 0-2024.9   0-2030.9   0-2036.9   0-2045.9   0-2048.9   
                                 0-2054.9   

_aixCharInfo                     struct tag
                                 4-99.16$  4-99.29{  4-109.1}  4-166.16   

_aixFontInfo                     struct tag
                                 4-111.16$  4-111.29{  4-138.1}  4-164.16   

_aixFontProp                     struct tag
                                 4-93.16$  4-93.29{  4-97.2}  4-165.16   

_bmr                             struct tag
                                 12-43.8$  12-43.13{  12-47.1}  12-130.16   

_complex_lock                    union tag
                                 25-142.7$  25-142.20{  25-145.1}  25-148.15   

_gWinGroup                       struct tag
                                 13-142.11$  13-143.11   

_gscDev                          struct tag
                                 15-47.16$  15-314.24{  15-350.1}  12-90.16   

_gscdma                          struct tag
                                 14-430.16$  14-430.24{  14-458.1}  15-394.16   

_mac_num_words                   auto unsigned long in function cdd_blit
                                 0-2581.9&  0-2581.9#  0-2581.9   0-2581.9   0-2581.9#  
                                 0-2581.9   

_mac_num_words                   auto unsigned long in function cdd_blit
                                 0-2578.9&  0-2578.9#  0-2578.9   0-2578.9   0-2578.9#  
                                 0-2578.9   

_partList                        struct tag
                                 15-412.16$  15-414.20   15-413.9{  15-417.9}  

_rcxp                            struct tag
                                 15-53.16$  15-138.12   15-571.22{  15-583.1}  15-585.16   

_simple_lock                     union tag
                                 25-136.7$  25-136.19{  25-139.1}  25-147.15   

_src_ptr                         auto pointer to unsigned long in function cdd_blit
                                 0-2581.9&  0-2581.9#  0-2581.9   0-2581.9   0-2581.9#  

_src_ptr                         auto pointer to unsigned long in function cdd_blit
                                 0-2578.9&  0-2578.9#  0-2578.9   0-2578.9   0-2578.9#  

_tgt_ptr                         auto pointer to unsigned long in function cdd_blit
                                 0-2581.9&  0-2581.9#  0-2581.9   0-2581.9   0-2581.9#  

_tgt_ptr                         auto pointer to unsigned long in function cdd_blit
                                 0-2578.9&  0-2578.9#  0-2578.9   0-2578.9   0-2578.9#  

address_space_length             array[8] of unsigned long in struct at offset 64
                                 67-487.25$  0-394.17   0-596.16   0-1081.15   0-1443.16   
                                 0-1911.16   

address_space_length             array[8] of unsigned long in struct at offset 56
                                 67-655.25$  0-873.9   0-877.17   

bottom_len                       auto unsigned short in function cdd_blit
                                 0-2384.16$  0-2490.17#  0-2503.17#  0-2523.23   0-2581.9   

buf                              auto pointer to unsigned char in function cdd_qvpd
                                 0-1372.15$  0-1480.9#  0-1550.9#  0-1604.18   0-1613.19   
                                 0-1605.50   0-1605.50   0-1605.50#  0-1621.9#  0-1663.18   
                                 0-1672.19   0-1664.50   0-1664.50   0-1664.50#  0-1688.14#  
                                 0-1729.18   0-1738.19   0-1730.51   0-1730.51   0-1730.51#  

buf_length                       unsigned long in struct at offset 0
                                 67-361.17$  0-1482.9#  0-1585.11#  0-1644.11#  0-1710.11#  

buffer                           array[256] of unsigned char in struct at offset 4
                                 67-362.17$  0-1480.19   0-1550.19   0-1621.19   0-1688.24   

bus_cpy                          pointer to function returning int in struct at offset 44
                                 67-432.25$  0-2227.24   

bus_get_c                        pointer to function returning int in struct at offset 28
                                 67-428.25$  0-436.9   0-635.9   0-1137.13   0-1146.13   
                                 0-1183.13   0-1189.13   0-2223.24   

bus_get_l                        pointer to function returning int in struct at offset 20
                                 67-426.25$  0-1166.33   0-1493.31   0-1540.28   0-1572.29   
                                 0-1578.29   0-1587.29   0-1593.29   0-1607.33   0-1631.29   
                                 0-1637.29   0-1646.29   0-1652.29   0-1666.33   0-1697.29   
                                 0-1703.29   0-1712.29   0-1718.29   0-1732.33   0-2221.24   
                                 0-2551.27   

bus_get_s                        pointer to function returning int in struct at offset 24
                                 67-427.25$  0-2222.24   

bus_put_c                        pointer to function returning int in struct at offset 40
                                 67-431.25$  0-439.9   0-638.9   0-1124.9   0-1127.9   
                                 0-1142.29   0-1153.9   0-1156.9   0-1185.31   0-1956.9   
                                 0-1962.9   0-1965.9   0-1972.9   0-1989.11   0-1998.11   
                                 0-2009.9   0-2018.9   0-2024.9   0-2030.9   0-2036.9   
                                 0-2045.9   0-2048.9   0-2054.9   0-2226.24   

bus_put_l                        pointer to function returning int in struct at offset 32
                                 67-429.25$  0-1233.27   0-2224.24   0-2578.9   0-2581.9   
                                 0-2587.28   

bus_put_s                        pointer to function returning int in struct at offset 36
                                 67-430.25$  0-2225.24   

busmem_att                       unsigned long in struct at offset 16
                                 67-475.25$  0-395.17   0-398.18   0-398.18   0-398.18   
                                 0-421.30   0-597.16   0-600.18   0-600.18   0-600.18   
                                 0-621.30   0-1082.16   0-1082.16   0-1082.16   0-1102.31   
                                 0-1444.16   0-1447.17   0-1447.17   0-1447.17   0-1470.30   
                                 0-1912.16   0-1915.17   0-1915.17   0-1915.17   0-1940.31   
                                 0-2189.25   

busmem_att                       unsigned long in struct at offset 16
                                 67-652.25$  0-881.9#  

busmem_hw_base                   array[8] of unsigned long in struct at offset 32
                                 67-486.25$  0-393.16   0-399.22   0-422.30   0-595.16   
                                 0-601.31   0-622.30   0-1080.15   0-1083.13   0-1103.31   
                                 0-1442.16   0-1448.17   0-1471.30   0-1910.16   0-1916.18   
                                 0-1941.31   

busmem_hw_base                   array[8] of unsigned long in struct at offset 24
                                 67-654.25$  0-872.9   0-878.17   

busmem_key                       struct tag
                                 15-175.8$  15-176.9{  15-182.9}  15-219.12   

byte                             auto int in function cdd_blit
                                 0-2379.12$  0-2482.27#  0-2482.37   0-2484.44   0-2482.55   
                                 0-2482.55   0-2482.55#  0-2482.37   

can_run_in_polled_mode           unsigned char in struct at offset 93
                                 67-664.25$  0-917.9#  

cdd                              auto pointer to struct with no tag in function cdd_enable
                                 0-353.24$  0-378.36   0-393.16   0-394.17   0-395.17   
                                 0-396.17   0-397.17   0-398.39   0-398.39   0-398.39   
                                 0-399.22   0-400.39   0-400.39   0-400.39   0-401.34   
                                 0-401.34   0-404.25   0-416.49   0-420.30   0-421.30   
                                 0-422.30   0-423.30   0-424.30   0-425.30   0-450.9   
                                 0-452.9   

cdd                              auto pointer to struct with no tag in function cdd_disable
                                 0-555.25$  0-580.36   0-595.16   0-596.16   0-597.16   
                                 0-598.17   0-599.17   0-600.39   0-600.39   0-600.39   
                                 0-601.31   0-602.36   0-602.36   0-602.36   0-603.34   
                                 0-603.34   0-605.25   0-617.49   0-620.30   0-621.30   
                                 0-622.30   0-623.30   0-624.30   0-625.30   0-649.9   
                                 0-651.9   

cdd                              auto pointer to struct with no tag in function cdd_init
                                 0-761.23$  0-781.36   0-789.15   0-796.15   0-803.15   
                                 0-804.26   0-814.15   0-815.18   0-819.15   0-820.19   
                                 0-829.14   0-830.14   0-837.17   0-849.36   0-942.9   
                                 0-944.9   

cdd                              auto pointer to struct with no tag in function cdd_load_ucode
                                 0-1014.28$  0-1036.36   0-1048.14   0-1049.14   0-1051.17   
                                 0-1060.42   0-1061.42   0-1080.15   0-1081.15   0-1082.37   
                                 0-1082.37   0-1082.37   0-1083.13   0-1085.17   0-1098.49   
                                 0-1101.31   0-1102.31   0-1103.31   0-1200.12   0-1201.12   
                                 0-1202.12   0-1206.13   0-1207.13   0-1208.13   0-1212.13   
                                 0-1213.13   0-1214.13   0-1217.12   0-1218.12   0-1219.12   
                                 0-1220.12   0-1221.12   0-1224.11   0-1250.28   0-1251.28   
                                 0-1267.9   0-1269.9   

cdd                              auto pointer to struct with no tag in function cdd_qvpd
                                 0-1354.22$  0-1398.36   0-1408.15   0-1409.15   0-1410.15   
                                 0-1411.15   0-1412.15   0-1415.17   0-1424.36   0-1425.36   
                                 0-1434.17   0-1442.16   0-1443.16   0-1444.16   0-1445.16   
                                 0-1446.16   0-1447.38   0-1447.38   0-1447.38   0-1448.17   
                                 0-1449.35   0-1449.35   0-1449.35   0-1450.13   0-1450.13   
                                 0-1452.17   0-1466.49   0-1469.30   0-1470.30   0-1471.30   
                                 0-1472.30   0-1473.30   0-1515.11   0-1752.7   0-1754.7   

cdd                              auto pointer to struct with no tag in function cdd_set_POS
                                 0-1848.25$  0-1882.36   0-1892.14   0-1893.25   0-1901.38   
                                 0-1904.25   0-1910.16   0-1911.16   0-1912.16   0-1913.16   
                                 0-1914.16   0-1915.38   0-1915.38   0-1915.38   0-1916.18   
                                 0-1917.35   0-1917.35   0-1917.35   0-1918.13   0-1918.13   
                                 0-1924.25   0-1936.50   0-1939.31   0-1940.31   0-1941.31   
                                 0-1942.31   0-1943.31   0-1944.31   0-1984.28   0-1985.28   
                                 0-2065.9   0-2067.9   

cdd                              auto pointer to struct with no tag in function check_cdd_structures
                                 0-2144.34$  0-2153.15   0-2162.15   0-2171.16   0-2172.16   
                                 0-2173.16   0-2174.16   0-2188.24   0-2189.25   0-2190.25   
                                 0-2191.25   0-2192.25   0-2205.20   0-2217.25   0-2218.25   
                                 0-2219.25   0-2220.25   0-2221.25   0-2222.25   0-2223.25   
                                 0-2224.25   0-2225.25   0-2226.25   0-2227.25   

cdd                              auto pointer to struct with no tag in function cdd_blit
                                 0-2365.22$  0-2397.36   0-2409.15   0-2411.17   0-2423.41   
                                 0-2426.40   0-2444.17   0-2457.17   0-2458.17   0-2512.25   
                                 0-2514.25   0-2572.11   0-2600.17   

cdd                              auto pointer to struct with no tag in function cdd_entry
                                 0-147.16$  0-174.15   0-183.15   0-193.15   0-203.32   
                                 0-207.32   0-211.34   0-215.35   0-219.38   0-223.35   
                                 0-227.32   

cdd_blit                         static function returning int
                                 0-203.22X  0-203.22Z  0-2365.12Y  

cdd_disable                      static function returning int
                                 0-215.22X  0-215.22Z  0-555.12Y  

cdd_enable                       static function returning int
                                 0-211.22X  0-211.22Z  0-353.12Y  

cdd_entry                        extern function returning int
                                 0-147.5Y  

cdd_exts                         struct tag
                                 67-568.12$  67-569.12   

cdd_flags                        unsigned long in struct at offset 0
                                 67-618.17$  0-923.22   

cdd_flags                        unsigned long in struct at offset 12
                                 67-756.17$  0-1063.22   

cdd_init                         static function returning int
                                 0-207.22X  0-207.22Z  0-761.12Y  

cdd_load_ucode                   static function returning int
                                 0-219.22X  0-219.22Z  0-1014.12Y  

cdd_qvpd                         static function returning int
                                 0-227.22X  0-227.22Z  0-1354.12Y  

cdd_set_POS                      static function returning int
                                 0-223.22X  0-223.22Z  0-1848.12Y  

char_data                        array[4] of unsigned char in union at offset 0
                                 0-1380.20$  0-1613.26   0-1672.26   0-1738.26   

check_cdd_structures             static function returning int
                                 0-378.14X  0-378.14Z  0-580.14Z  0-1036.14Z  0-1398.14Z  
                                 0-1882.14Z  0-2144.12Y  0-2397.14Z  

cmd                              auto pointer to struct with no tag in function cdd_set_POS
                                 0-1857.27$  0-1901.9#  0-1903.14   

cmd                              auto pointer to struct with no tag in function cdd_blit
                                 0-2368.20$  0-2423.9#  0-2424.31   0-2425.22   0-2435.20   
                                 0-2436.20   0-2437.20   0-2438.20   0-2439.20   0-2440.20   
                                 0-2441.20   0-2442.20   0-2454.19   0-2455.19   0-2475.14   
                                 0-2478.37   0-2480.37   0-2480.37   0-2490.31   0-2494.15   
                                 0-2500.59   0-2503.31   0-2528.18   0-2531.18   0-2532.18   
                                 0-2533.18   

cmd                              auto unsigned long in function cdd_entry
                                 0-158.18$  0-193.9#  0-195.17   

command                          unsigned long in struct at offset 0
                                 67-517.25$  0-193.15   0-829.14   0-1408.15   

complex_lock_data                struct tag
                                 25-71.8$  25-71.26{  25-75.9}  25-87.32   25-143.16   

component_loc                    array[5] of unsigned char in struct at offset 24
                                 67-538.25$  0-1218.36   0-1219.36   0-1220.36   0-1221.36   

configuration                    auto unsigned long in function cdd_qvpd
                                 0-1376.17$  0-1538.10#  0-1543.42   0-1568.14   0-1628.14   
                                 0-1682.14   

crc                              auto unsigned short in function cdd_qvpd
                                 0-1366.16$  0-1598.11#  0-1657.11#  0-1723.11#  

crc1                             auto int in function cdd_qvpd
                                 0-1364.42$  0-1590.42   0-1598.27   0-1649.42   0-1657.27   
                                 0-1715.42   0-1723.27   

crc2                             auto int in function cdd_qvpd
                                 0-1364.48$  0-1596.42   0-1598.40   0-1655.42   0-1657.40   
                                 0-1721.42   0-1723.40   

data                             auto int in function cdd_qvpd
                                 0-1374.15$  0-1490.9#  0-1496.45   0-1500.13   0-1518.17   

data                             auto unsigned long in function cdd_blit
                                 0-2386.15$  0-2554.41   0-2557.13   0-2575.17   

data                             auto int in function cdd_load_ucode
                                 0-1019.17$  0-1169.47   0-1171.18   0-1171.42   0-1196.13   
                                 0-1206.58   0-1207.58   0-1208.57   

ddf                              auto pointer to struct with no tag in function cdd_disable
                                 0-560.32$  0-617.9#  0-618.30   0-619.9   0-620.9   
                                 0-621.9   0-622.9   0-623.9   0-624.9   0-625.9   

ddf                              auto pointer to struct with no tag in function cdd_init
                                 0-772.21$  0-819.9#  0-855.38   

ddf                              auto pointer to struct with no tag in function cdd_load_ucode
                                 0-1024.21$  0-1098.9#  0-1099.31   0-1100.9   0-1101.9   
                                 0-1102.9   0-1103.9   0-1104.9   0-1105.9   0-1106.9   
                                 0-1228.9   0-1238.9   

ddf                              auto pointer to struct with no tag in function cdd_qvpd
                                 0-1368.21$  0-1466.9#  0-1467.30   0-1468.9   0-1469.9   
                                 0-1470.9   0-1471.9   0-1472.9   0-1473.9   0-1474.9   
                                 0-1475.9   

ddf                              auto pointer to struct with no tag in function cdd_set_POS
                                 0-1862.22$  0-1936.9#  0-1937.31   0-1938.9   0-1939.9   
                                 0-1940.9   0-1941.9   0-1942.9   0-1943.9   0-1944.9   
                                 0-1945.9   0-1951.9   0-1990.27   0-1999.27   0-2024.28   
                                 0-2057.9   

ddf                              auto pointer to struct with no tag in function cdd_blit
                                 0-2372.17$  0-2426.9#  0-2427.22   0-2477.39   0-2489.60   

ddf                              auto pointer to struct with no tag in function cdd_enable
                                 0-358.31$  0-416.9#  0-417.30   0-419.9   0-420.9   
                                 0-421.9   0-422.9   0-423.9   0-424.9   0-425.9   

ddf_len                          unsigned long in struct at offset 4
                                 67-462.33$  0-815.18   0-820.19   0-2192.25   

ddf_len                          auto unsigned long in function cdd_init
                                 0-773.15$  0-820.9#  

ddf_scratchpad                   pointer to void in struct at offset 0
                                 67-461.14$  0-416.49   0-617.49   0-814.15   0-819.15   
                                 0-1098.49   0-1466.49   0-1936.50   0-2188.24   0-2426.40   

dest_x                           short in struct at offset 12
                                 67-800.25$  0-2435.20   0-2439.20   0-2528.18   

dest_y                           short in struct at offset 14
                                 67-801.25$  0-2436.20   0-2440.20   0-2531.18   

devdesc                          struct tag
                                 50-186.8$  50-186.16{  50-200.1}  50-219.12   

dflt_dma_arb_level               unsigned long in struct at offset 104
                                 67-670.25$  0-915.9#  

dflt_int_level                   unsigned long in struct at offset 96
                                 67-666.25$  0-913.9#  

dflt_int_priority                int in struct at offset 100
                                 67-668.25$  0-914.9#  

dh                               unsigned short in struct at offset 10
                                 69-190.26$  0-2533.11#  

diacritic                        struct tag
                                 44-73.8$  44-76.18   44-73.18{  44-82.1}  42-39.16   

direct                           struct tag
                                 49-28.8$  49-28.15{  49-33.1}  49-35.16   

dirent                           struct tag
                                 46-55.9$  46-55.16{  46-63.1}  46-155.41   46-156.29   
                                 46-156.47   

display_info                     struct tag
                                 12-51.9$  12-51.22{  12-80.1}  12-95.16   

dma_bufs                         struct tag
                                 12-37.8$  12-37.17{  12-40.1}  12-121.16   

drv_desc                         struct tag
                                 50-202.8$  50-202.17{  50-209.1}  50-222.12   50-223.12   

dsc_disk                         struct tag
                                 50-144.8$  50-144.17{  50-146.1}  50-190.16   

dsc_exp                          struct tag
                                 50-153.8$  50-153.16{  50-156.1}  50-192.16   

dsc_general                      struct tag
                                 50-182.8$  50-182.20{  50-184.1}  50-197.16   

dsc_native                       struct tag
                                 50-148.8$  50-148.19{  50-151.1}  50-191.16   

dsc_pvid                         struct tag
                                 50-158.8$  50-158.17{  50-160.1}  50-193.16   

dsc_pvscsi                       struct tag
                                 50-172.8$  50-172.19{  50-176.1}  50-195.16   

dsc_scsi                         struct tag
                                 50-162.8$  50-162.17{  50-170.1}  50-175.12   50-194.16   

dsc_sla                          struct tag
                                 50-178.8$  50-178.16{  50-180.1}  50-196.16   

dw                               unsigned short in struct at offset 8
                                 69-189.26$  0-2532.11#  

dx                               unsigned short in struct at offset 4
                                 69-184.26$  0-2528.11#  0-2578.37   

dy                               unsigned short in struct at offset 6
                                 69-185.26$  0-2531.11#  

eflock                           struct tag
                                 63-60.9$  63-60.17{  63-75.1}  63-91.16   63-120.17   

entry_point                      pointer to function returning int in struct at offset 0
                                 67-396.17$  0-2205.19   

exception_code                   long in struct at offset 28
                                 67-482.25$  0-437.9#  0-440.9#  0-450.9#  0-636.9#  
                                 0-639.9#  0-649.9#  0-942.9#  0-1125.9#  0-1128.9#  
                                 0-1138.13#  0-1147.13#  0-1154.9#  0-1157.9#  0-1170.13#  
                                 0-1184.13#  0-1190.13#  0-1267.9#  0-1497.13#  0-1544.10#  
                                 0-1576.11#  0-1582.11#  0-1591.11#  0-1597.11#  0-1611.12#  
                                 0-1635.11#  0-1641.11#  0-1650.11#  0-1656.11#  0-1670.12#  
                                 0-1701.11#  0-1707.11#  0-1716.11#  0-1722.11#  0-1736.12#  
                                 0-1752.7#  0-1957.9#  0-1963.9#  0-1966.9#  0-1976.9#  
                                 0-1993.11#  0-2003.11#  0-2013.9#  0-2019.9#  0-2025.9#  
                                 0-2031.9#  0-2040.9#  0-2046.9#  0-2049.9#  0-2055.9#  
                                 0-2065.9#  0-2457.17#  0-2555.9#  0-2578.9#  0-2581.9#  
                                 0-2591.10#  

fhandle                          struct tag
                                 1-226.8$  1-226.16{  1-228.1}  1-233.16   

fid                              struct tag
                                 1-212.8$  1-212.12{  1-215.1}  1-216.16   

file                             struct tag
                                 42-38.16$  42-52.16   51-40.24   51-33.14{  51-62.1}  
                                 51-75.15   51-76.15   

fileid                           struct tag
                                 1-218.8$  1-218.15{  1-223.1}  1-231.16   

filock                           struct tag
                                 63-119.9$  63-127.16   63-130.16   63-131.16   63-119.17{  
                                 63-133.1}  63-149.15   

flags                            auto int in function cdd_load_ucode
                                 0-1021.19$  0-1063.9#  0-1198.16   0-1252.14   

flags                            auto unsigned long in function check_cdd_structures
                                 0-2144.54$  0-2186.14   0-2204.14   0-2215.14   

flags                            auto int in function cdd_init
                                 0-771.20$  0-923.9#  0-924.14   

flckinfo                         struct tag
                                 63-137.8$  63-137.17{  63-142.1}  63-148.15   

font_data                        struct tag
                                 12-113.16$  41-25.18{  41-36.1}  41-38.13   40-166.16   
                                 5-46.16   

fsid                             struct tag
                                 1-201.8$  1-201.13{  1-203.1}  1-204.16   

gsc_DispBuff_values              enum tag
                                 13-168.6$  13-168.26{  13-185.30}  13-189.9   

gsc_MultBuff_values              enum tag
                                 13-158.6$  13-158.26{  13-160.34}  13-164.9   

halfword                         struct with no tag in union at offset 0
                                 69-173.11$  0-2524.9   0-2526.9   

has_intr_handler                 unsigned char in struct at offset 92
                                 67-663.25$  0-916.9#  

hdr                              union with no tag in struct at offset 0
                                 69-183.25$  0-2524.9   0-2526.9   0-2587.28   

height                           unsigned short in struct at offset 18
                                 67-803.25$  0-2438.20   0-2442.20   0-2455.19   0-2480.37   
                                 0-2480.37   0-2490.31   0-2503.31   0-2533.18   

hw_pixmap                        auto pointer to unsigned char in function cdd_blit
                                 0-2376.10$  0-2477.17#  0-2484.32   0-2486.22   0-2486.22#  

i                                auto int in function cdd_load_ucode
                                 0-1026.42$  0-1140.14#  0-1140.21   0-1140.56   0-1140.56   
                                 0-1140.56#  0-1140.21   0-1164.16#  0-1164.23   0-1164.37   
                                 0-1164.37   0-1164.37#  0-1164.23   

i                                auto int in function cdd_qvpd
                                 0-1364.19$  0-1605.17#  0-1605.22   0-1605.36   0-1605.45   
                                 0-1605.45   0-1605.45#  0-1605.22   0-1605.36   0-1664.17#  
                                 0-1664.22   0-1664.36   0-1664.45   0-1664.45   0-1664.45#  
                                 0-1664.22   0-1664.36   0-1730.17#  0-1730.22   0-1730.36   
                                 0-1730.46   0-1730.46   0-1730.46#  0-1730.22   0-1730.36   

i                                auto int in function cdd_init
                                 0-771.17$  0-855.15#  0-856.13   0-857.13   0-857.13   
                                 0-857.13#  0-856.13   0-875.15#  0-875.20   0-877.17   
                                 0-878.17   0-875.45   0-875.45   0-875.45#  0-875.20   

i_disable                        pointer to function returning int in struct at offset 8
                                 67-414.25$  0-2218.24   

i_enable                         pointer to function returning void in struct at offset 12
                                 67-415.25$  0-2217.24   

int_data                         unsigned int in union at offset 0
                                 0-1379.20$  0-1610.45   0-1669.45   0-1735.45   

intr                             struct tag
                                 7-45.8$  7-47.16   7-46.1{  7-55.1}  7-203.20   
                                 7-208.22   7-213.19   7-220.21   7-225.21   12-85.20   

iocc_addr_base                   unsigned long in struct at offset 96
                                 67-488.25$  0-397.17   0-400.18   0-400.18   0-424.30   
                                 0-599.17   0-602.18   0-602.18   0-624.30   0-1446.16   
                                 0-1449.17   0-1449.17   0-1473.30   0-1914.16   0-1917.17   
                                 0-1917.17   0-1943.31   0-2191.25   

iocc_addr_base                   unsigned long in struct at offset 88
                                 67-656.25$  0-894.9#  

iocc_att                         unsigned long in struct at offset 20
                                 67-476.25$  0-396.17   0-400.18   0-400.18   0-400.18   
                                 0-423.30   0-598.17   0-602.18   0-602.18   0-602.18   
                                 0-623.30   0-1445.16   0-1449.17   0-1449.17   0-1449.17   
                                 0-1472.30   0-1913.16   0-1917.17   0-1917.17   0-1917.17   
                                 0-1942.31   0-2190.25   

iocc_att                         unsigned long in struct at offset 20
                                 67-653.25$  0-892.9#  

itimerstruc_t                    struct tag
                                 29-134.8$  29-134.22{  29-137.1}  28-150.16   

label_t                          struct tag
                                 3-21.16$  3-22.16   3-21.24{  3-29.1}  

len1                             auto int in function cdd_qvpd
                                 0-1364.30$  0-1575.42   0-1583.21   0-1634.42   0-1642.21   
                                 0-1700.42   0-1708.21   

len2                             auto int in function cdd_qvpd
                                 0-1364.36$  0-1581.42   0-1583.34   0-1640.42   0-1642.34   
                                 0-1706.42   0-1708.34   

length                           unsigned short in struct at offset 0
                                 69-171.25$  0-2526.9#  

length                           auto int in function cdd_qvpd
                                 0-1364.22$  0-1583.11#  0-1585.44   0-1605.26   0-1605.26   
                                 0-1642.11#  0-1644.44   0-1664.26   0-1664.26   0-1708.11#  
                                 0-1710.44   0-1730.26   0-1730.26   

length_in                        unsigned long in struct at offset 12
                                 67-524.25$  0-1410.15   

length_of_ucode                  unsigned long in struct at offset 0
                                 67-753.17$  0-1104.37   

length_out                       unsigned long in struct at offset 16
                                 67-525.25$  0-1412.15   

lock_data_instrumented           struct tag
                                 25-83.8$  25-88.32   25-83.31{  25-112.9}  25-138.16   
                                 25-144.16   

lockl                            pointer to function returning int in struct at offset 0
                                 67-412.25$  0-1250.27   0-1984.27   0-2219.24   

max_area                         unsigned long in struct at offset 8
                                 67-643.17$  0-903.9#  

max_height                       unsigned long in struct at offset 4
                                 67-642.17$  0-902.9#  

max_width                        unsigned long in struct at offset 0
                                 67-641.17$  0-901.9#  

min_ucode_lvl                    unsigned long in struct at offset 260
                                 67-363.17$  0-1483.9#  0-1552.9#  0-1623.9#  0-1690.14#  

mstsave                          struct tag
                                 22-38.8$  22-40.16   22-38.17{  22-89.1}  22-129.44   
                                 22-130.16   21-271.16   

num_bytes                        auto int in function cdd_blit
                                 0-2380.12$  0-2478.17#  0-2482.44   0-2482.44   

num_valid_units                  unsigned long in struct at offset 0
                                 67-350.17$  0-1481.9#  0-1551.9#  0-1622.9#  0-1689.14#  

op                               unsigned short in struct at offset 2
                                 69-172.25$  0-2524.9#  

origin_type                      unsigned long in struct at offset 12
                                 67-644.17$  0-904.9#  

pDataIn                          pointer to void in struct at offset 4
                                 67-522.10$  0-781.36   0-1048.14   0-1060.42   0-1409.15   
                                 0-1424.36   0-1892.14   0-1901.38   0-2409.15   0-2423.41   

pDataOut                         pointer to void in struct at offset 8
                                 67-523.10$  0-830.14   0-849.36   0-1049.14   0-1061.42   
                                 0-1411.15   0-1425.36   

p_PixelData                      pointer to unsigned long in struct at offset 0
                                 67-797.15$  0-2424.31   0-2500.59   

p_cdd_command_attrs              pointer to struct with no tag in struct at offset 0
                                 67-593.25$  0-183.15   0-193.15   0-404.25   0-437.9   
                                 0-440.9   0-452.9   0-605.25   0-636.9   0-639.9   
                                 0-651.9   0-781.36   0-803.15   0-829.14   0-830.14   
                                 0-837.17   0-849.36   0-944.9   0-1048.14   0-1049.14   
                                 0-1051.17   0-1060.42   0-1061.42   0-1085.17   0-1125.9   
                                 0-1128.9   0-1138.13   0-1147.13   0-1154.9   0-1157.9   
                                 0-1170.13   0-1184.13   0-1190.13   0-1200.15   0-1201.15   
                                 0-1202.15   0-1206.16   0-1207.16   0-1208.16   0-1212.16   
                                 0-1213.16   0-1214.16   0-1217.15   0-1218.15   0-1219.15   
                                 0-1220.15   0-1221.15   0-1224.11   0-1269.9   0-1408.15   
                                 0-1409.15   0-1410.15   0-1411.15   0-1412.15   0-1415.17   
                                 0-1424.36   0-1425.36   0-1434.17   0-1452.17   0-1497.13   
                                 0-1515.11   0-1544.10   0-1576.11   0-1582.11   0-1591.11   
                                 0-1597.11   0-1611.12   0-1635.11   0-1641.11   0-1650.11   
                                 0-1656.11   0-1670.12   0-1701.11   0-1707.11   0-1716.11   
                                 0-1722.11   0-1736.12   0-1754.7   0-1892.14   0-1893.25   
                                 0-1901.38   0-1904.25   0-1924.25   0-1957.9   0-1963.9   
                                 0-1966.9   0-1976.9   0-1993.11   0-2003.11   0-2013.9   
                                 0-2019.9   0-2025.9   0-2031.9   0-2040.9   0-2046.9   
                                 0-2049.9   0-2055.9   0-2067.9   0-2171.16   0-2409.15   
                                 0-2411.17   0-2423.41   0-2444.17   0-2458.17   0-2512.25   
                                 0-2514.25   0-2555.9   0-2572.11   0-2578.9   0-2581.9   
                                 0-2591.10   0-2600.17   

p_cdd_device_attrs               pointer to struct with no tag in struct at offset 4
                                 67-594.25$  0-393.16   0-394.17   0-395.17   0-396.17   
                                 0-397.17   0-398.39   0-398.39   0-398.39   0-399.22   
                                 0-400.39   0-400.39   0-400.39   0-401.34   0-401.34   
                                 0-416.49   0-421.30   0-422.30   0-423.30   0-424.30   
                                 0-425.30   0-437.9   0-440.9   0-450.9   0-595.16   
                                 0-596.16   0-597.16   0-598.17   0-599.17   0-600.39   
                                 0-600.39   0-600.39   0-601.31   0-602.36   0-602.36   
                                 0-602.36   0-603.34   0-603.34   0-617.49   0-621.30   
                                 0-622.30   0-623.30   0-624.30   0-625.30   0-636.9   
                                 0-639.9   0-649.9   0-804.26   0-814.15   0-815.18   
                                 0-819.15   0-820.19   0-942.9   0-1080.15   0-1081.15   
                                 0-1082.37   0-1082.37   0-1082.37   0-1083.13   0-1098.49   
                                 0-1102.31   0-1103.31   0-1125.9   0-1128.9   0-1138.13   
                                 0-1147.13   0-1154.9   0-1157.9   0-1170.13   0-1184.13   
                                 0-1190.13   0-1267.9   0-1442.16   0-1443.16   0-1444.16   
                                 0-1445.16   0-1446.16   0-1447.38   0-1447.38   0-1447.38   
                                 0-1448.17   0-1449.35   0-1449.35   0-1449.35   0-1450.13   
                                 0-1450.13   0-1466.49   0-1470.30   0-1471.30   0-1472.30   
                                 0-1473.30   0-1497.13   0-1544.10   0-1576.11   0-1582.11   
                                 0-1591.11   0-1597.11   0-1611.12   0-1635.11   0-1641.11   
                                 0-1650.11   0-1656.11   0-1670.12   0-1701.11   0-1707.11   
                                 0-1716.11   0-1722.11   0-1736.12   0-1752.7   0-1910.16   
                                 0-1911.16   0-1912.16   0-1913.16   0-1914.16   0-1915.38   
                                 0-1915.38   0-1915.38   0-1916.18   0-1917.35   0-1917.35   
                                 0-1917.35   0-1918.13   0-1918.13   0-1936.50   0-1940.31   
                                 0-1941.31   0-1942.31   0-1943.31   0-1944.31   0-1957.9   
                                 0-1963.9   0-1966.9   0-1976.9   0-1993.11   0-2003.11   
                                 0-2013.9   0-2019.9   0-2025.9   0-2031.9   0-2040.9   
                                 0-2046.9   0-2049.9   0-2055.9   0-2065.9   0-2172.16   
                                 0-2188.24   0-2189.25   0-2190.25   0-2191.25   0-2192.25   
                                 0-2426.40   0-2457.17   0-2555.9   0-2578.9   0-2581.9   
                                 0-2591.10   

p_cdd_procs                      pointer to struct with no tag in struct at offset 8
                                 67-595.25$  0-2174.16   0-2205.20   

p_cdd_svcs                       pointer to struct with no tag in struct at offset 12
                                 67-596.25$  0-436.9   0-439.9   0-635.9   0-638.9   
                                 0-1124.9   0-1127.9   0-1137.13   0-1142.29   0-1146.13   
                                 0-1153.9   0-1156.9   0-1166.33   0-1183.13   0-1185.31   
                                 0-1189.13   0-1233.27   0-1250.28   0-1251.28   0-1493.31   
                                 0-1540.28   0-1572.29   0-1578.29   0-1587.29   0-1593.29   
                                 0-1607.33   0-1631.29   0-1637.29   0-1646.29   0-1652.29   
                                 0-1666.33   0-1697.29   0-1703.29   0-1712.29   0-1718.29   
                                 0-1732.33   0-1956.9   0-1962.9   0-1965.9   0-1972.9   
                                 0-1984.28   0-1985.28   0-1989.11   0-1998.11   0-2009.9   
                                 0-2018.9   0-2024.9   0-2030.9   0-2036.9   0-2045.9   
                                 0-2048.9   0-2054.9   0-2173.16   0-2217.25   0-2218.25   
                                 0-2219.25   0-2220.25   0-2221.25   0-2222.25   0-2223.25   
                                 0-2224.25   0-2225.25   0-2226.25   0-2227.25   0-2551.27   
                                 0-2578.9   0-2581.9   0-2587.28   

p_cdd_vpd                        pointer to struct with no tag in struct at offset 0
                                 67-783.19$  0-1432.24   0-1465.36   

p_cmd                            auto pointer to struct with no tag in function cdd_load_ucode
                                 0-1017.30$  0-1060.9#  0-1063.17   0-1104.31   0-1105.31   

p_cmd                            auto pointer to struct with no tag in function cdd_qvpd
                                 0-1360.24$  0-1424.9#  0-1431.16   0-1474.30   

p_cmd                            auto pointer to struct with no tag in function cdd_init
                                 0-776.24$  0-781.9#  0-923.17   

p_out                            auto pointer to struct with no tag in function cdd_load_ucode
                                 0-1018.30$  0-1061.9#  0-1254.9   0-1255.9   0-1256.9   
                                 0-1257.9   

p_out                            auto pointer to struct with no tag in function cdd_qvpd
                                 0-1361.24$  0-1425.9#  0-1432.19   0-1465.30   

p_out                            auto pointer to struct with no tag in function cdd_init
                                 0-770.24$  0-849.9#  0-872.9   0-873.9   0-877.17   
                                 0-878.17   0-881.9   0-892.9   0-894.9   0-901.9   
                                 0-902.9   0-903.9   0-904.9   0-913.9   0-914.9   
                                 0-915.9   0-916.9   0-917.9   0-926.24   

p_se_bottom                      auto pointer to unsigned long in function cdd_blit
                                 0-2383.30$  0-2489.17#  0-2500.17#  0-2581.34   

p_ucode                          pointer to unsigned char in struct at offset 4
                                 67-754.14$  0-1105.37   

p_vpd                            auto pointer to struct with no tag in function cdd_qvpd
                                 0-1362.19$  0-1465.9#  0-1480.19   0-1481.9   0-1482.9   
                                 0-1483.9   0-1550.19   0-1551.9   0-1552.9   0-1585.11   
                                 0-1621.19   0-1622.9   0-1623.9   0-1644.11   0-1688.24   
                                 0-1689.14   0-1690.14   0-1710.11   

pce_id                           struct tag
                                 61-42.8$  61-43.1{  61-49.1}  61-68.16   

pcl_entry                        struct tag
                                 61-60.9$  61-61.1{  61-69.1}  61-105.17   

per_unit_data                    array[6] of struct with no tag in struct at offset 4
                                 67-370.17$  0-1480.19   0-1482.9   0-1483.9   0-1550.19   
                                 0-1552.9   0-1585.11   0-1621.19   0-1623.9   0-1644.11   
                                 0-1688.24   0-1690.14   0-1710.11   

phys_displays                    struct tag
                                 15-331.16$  12-88.16   12-89.16   12-83.22{  12-268.1}  
                                 9-191.17   9-210.17   40-159.16   

pixmap                           auto pointer to unsigned char in function cdd_blit
                                 0-2370.10$  0-2424.9#  0-2434.21   0-2484.53   0-2482.63   
                                 0-2482.63   0-2482.63#  

pixmap_len                       auto unsigned short in function cdd_blit
                                 0-2369.22$  0-2425.9#  0-2433.16   0-2453.16   

pos_val                          auto unsigned char in function cdd_disable
                                 0-562.27$  0-635.9   0-638.28   

pos_val                          auto unsigned char in function cdd_enable
                                 0-360.26$  0-435.9#  0-436.9   0-439.28   

posbyte                          auto unsigned char in function cdd_load_ucode
                                 0-1020.15$  0-1137.13   0-1140.39   0-1146.13   0-1140.39   
                                 0-1162.14   0-1183.13   0-1189.13   0-1204.16   

priv                             struct tag
                                 58-22.8$  58-23.1{  58-25.1}  58-26.16   

proc                             struct tag
                                 21-61.16$  20-116.16   19-66.16   19-67.16   19-68.16   
                                 19-69.16   19-106.16   19-110.16   19-120.16   19-121.16   
                                 19-141.16   19-142.16   19-57.14{  19-149.1}  19-253.15   

proch                            struct tag
                                 19-294.8$  19-296.17   19-295.1{  19-298.1}  15-116.12   

product_SRN                      array[7] of unsigned char in struct at offset 29
                                 67-546.25$  0-1200.36   0-1201.36   0-1202.36   0-1206.37   
                                 0-1207.37   0-1208.37   0-1212.37   0-1213.37   0-1214.37   
                                 0-1217.36   

product_name                     array[41] of unsigned char in struct at offset 108
                                 67-681.25$  0-926.24   

product_name                     auto pointer to unsigned char in function cdd_init
                                 0-775.14$  0-926.9#  0-927.10   0-927.10   0-927.10#  
                                 0-928.10   0-928.10   0-928.10#  0-929.10   0-929.10   
                                 0-929.10#  0-930.10   0-930.10   0-930.10#  0-931.10   
                                 0-931.10   0-931.10#  0-932.10   0-932.10   0-932.10#  
                                 0-933.10   0-933.10   0-933.10#  0-934.10   

ptipc                            struct tag
                                 20-114.8$  20-114.14{  20-124.1}  19-119.16   

ptr                              auto pointer to unsigned char in function cdd_init
                                 0-774.14$  0-855.23#  0-859.18   0-857.19   0-857.19   
                                 0-857.19#  

rc                               auto int in function cdd_enable
                                 0-356.25$  0-378.9#  0-380.14   0-380.40   

rc                               auto int in function cdd_disable
                                 0-558.26$  0-580.9#  0-582.14   0-582.40   

rc                               auto int in function cdd_load_ucode
                                 0-1019.13$  0-1036.9#  0-1038.14   0-1039.24   

rc                               auto int in function cdd_qvpd
                                 0-1364.15$  0-1398.9#  0-1400.14   0-1401.21   

rc                               auto int in function cdd_set_POS
                                 0-1859.14$  0-1882.9#  0-1883.14   0-1884.22   

rc                               auto int in function cdd_blit
                                 0-2375.10$  0-2397.9#  0-2398.14   0-2399.23   

rc                               auto int in function cdd_entry
                                 0-157.18$  0-203.17#  0-207.17#  0-211.17#  0-215.17#  
                                 0-219.17#  0-223.17#  0-227.17#  0-231.17#  0-238.15   

rc_out                           int in struct at offset 20
                                 67-529.25$  0-404.25#  0-437.9#  0-440.9#  0-452.9#  
                                 0-605.25#  0-636.9#  0-639.9#  0-651.9#  0-837.17#  
                                 0-944.9#  0-1051.17#  0-1085.17#  0-1125.9#  0-1128.9#  
                                 0-1138.13#  0-1147.13#  0-1154.9#  0-1157.9#  0-1170.13#  
                                 0-1184.13#  0-1190.13#  0-1224.11#  0-1269.9#  0-1415.17#  
                                 0-1434.17#  0-1452.17#  0-1497.13#  0-1515.11#  0-1544.10#  
                                 0-1576.11#  0-1582.11#  0-1591.11#  0-1597.11#  0-1611.12#  
                                 0-1635.11#  0-1641.11#  0-1650.11#  0-1656.11#  0-1670.12#  
                                 0-1701.11#  0-1707.11#  0-1716.11#  0-1722.11#  0-1736.12#  
                                 0-1754.7#  0-1893.25#  0-1904.25#  0-1924.25#  0-1957.9#  
                                 0-1963.9#  0-1966.9#  0-1976.9#  0-1993.11#  0-2003.11#  
                                 0-2013.9#  0-2019.9#  0-2025.9#  0-2031.9#  0-2040.9#  
                                 0-2046.9#  0-2049.9#  0-2055.9#  0-2067.9#  0-2411.17#  
                                 0-2444.17#  0-2458.17#  0-2512.25#  0-2514.25#  0-2555.9#  
                                 0-2572.11#  0-2578.9#  0-2581.9#  0-2591.10#  0-2600.17#  

row                              auto int in function cdd_blit
                                 0-2378.12$  0-2480.22#  0-2480.31   0-2480.56   0-2480.56   
                                 0-2480.56#  0-2480.31   

rusage                           struct tag
                                 30-53.9$  30-53.16{  30-72.1}  19-129.16   

se                               auto struct with no tag in function cdd_blit
                                 0-2382.24$  0-2524.21   0-2526.22   0-2528.9   0-2531.9   
                                 0-2532.9   0-2533.9   0-2578.35   0-2590.41   

se_length                        auto unsigned short in function cdd_blit
                                 0-2385.15$  0-2523.9#  0-2526.31   

segreg                           struct tag
                                 15-203.8$  15-205.21   15-204.9{  15-210.9}  15-221.12   
                                 15-405.16   

slot                             unsigned long in struct at offset 24
                                 67-479.25$  0-425.30   0-625.30   0-1944.31   

start_slot                       unsigned char in struct at offset 0
                                 67-776.25$  0-1431.21   0-1474.30   

strlft                           struct tag
                                 5-38.17$  5-39.17   

temp                             auto pointer to unsigned char in function cdd_qvpd
                                 0-1372.22$  0-1604.11#  0-1663.11#  0-1729.11#  

temp1                            auto unsigned int in function cdd_set_POS
                                 0-1860.14$  0-1984.9#  0-1986.14   

temp1                            auto unsigned int in function cdd_load_ucode
                                 0-1022.14$  0-1250.9#  0-1252.24   

temp2                            auto unsigned int in function cdd_set_POS
                                 0-1860.21$  0-1985.9#  0-1986.23   

temp2                            auto unsigned int in function cdd_load_ucode
                                 0-1022.21$  0-1251.9#  0-1252.33   

thread                           struct tag
                                 21-52.9$  21-69.20   21-70.20   21-81.16   21-86.16   
                                 21-91.16   21-92.16   21-93.16   21-130.16   21-52.16{  
                                 21-137.1}  21-245.15   19-72.16   19-91.16   

timestruc_t                      struct tag
                                 29-116.8$  29-116.20{  29-119.1}  29-135.17   29-136.17   
                                 29-160.15   

timeval                          struct tag
                                 29-126.8$  29-126.16{  29-129.1}  29-140.25   29-274.25   
                                 29-275.25   30-54.16   30-55.16   

trb                              struct tag
                                 28-141.9$  28-142.16   28-143.16   28-144.16   28-141.14{  
                                 28-164.1}  28-191.15   15-273.12   

tstate                           struct tag
                                 21-128.16$  21-270.15{  21-281.1}  21-316.39   21-316.56   

u                                auto union with no tag in function cdd_qvpd
                                 0-1381.11$  0-1610.46   0-1613.25   0-1669.46   0-1672.25   
                                 0-1735.46   0-1738.25   

ucred                            struct tag
                                 57-34.8$  57-34.14{  57-75.1}  57-82.20   57-83.8   
                                 57-84.8   57-85.8   57-85.29   57-86.8   57-86.28   
                                 57-87.19   57-88.20   51-50.16   

uexcepth                         struct tag
                                 17-26.9$  17-27.17   17-26.18{  17-29.1}  15-133.12   

unique_id                        struct tag
                                 1-241.8$  1-241.18{  1-246.1}  1-247.16   50-159.12   
                                 50-173.12   

unlockl                          pointer to function returning void in struct at offset 4
                                 67-413.25$  0-1251.27   0-1985.27   0-2220.24   

use_polled_mode                  unsigned char in struct at offset 0
                                 67-723.25$  0-1903.14   

usrbuf                           struct tag
                                 15-193.16$  15-195.20   15-194.9{  15-201.9}  15-222.12   
                                 15-340.16   

var                              struct tag
                                 26-45.8$  26-45.12{  26-76.1}  26-79.15   

var_hdr                          struct tag
                                 26-30.8$  26-31.1{  26-38.1}  26-46.16   

version                          unsigned long in struct at offset 20
                                 67-598.33$  0-796.15   0-2162.15   

vpd_ptr                          auto pointer to unsigned int in function cdd_qvpd
                                 0-1365.14$  0-1570.11#  0-1571.11   0-1571.11#  0-1574.41   
                                 0-1574.41   0-1574.41#  0-1580.41   0-1580.41   0-1580.41#  
                                 0-1589.41   0-1589.41   0-1589.41#  0-1595.41   0-1595.41   
                                 0-1595.41#  0-1607.33   0-1612.18   0-1612.18   0-1612.18#  
                                 0-1630.11   0-1630.11#  0-1633.41   0-1633.41   0-1633.41#  
                                 0-1639.41   0-1639.41   0-1639.41#  0-1648.41   0-1648.41   
                                 0-1648.41#  0-1654.41   0-1654.41   0-1654.41#  0-1666.33   
                                 0-1671.18   0-1671.18   0-1671.18#  0-1696.11   0-1696.11#  
                                 0-1699.41   0-1699.41   0-1699.41#  0-1705.41   0-1705.41   
                                 0-1705.41#  0-1714.41   0-1714.41   0-1714.41#  0-1720.41   
                                 0-1720.41   0-1720.41#  0-1732.33   0-1737.18   0-1737.18   
                                 0-1737.18#  

vtmstruc                         struct tag
                                 12-115.16$  40-158.17{  40-168.1}  42-55.16   

vtt_cp_parms                     struct tag
                                 40-96.8$  40-96.21{  40-104.1}  40-160.16   

vtt_cursor                       struct tag
                                 40-87.8$  40-87.19{  40-90.1}  40-103.16   

watchdog                         struct tag
                                 38-30.8$  38-31.16   38-32.16   38-30.17{  38-36.1}  
                                 38-43.19   38-49.20   38-55.21   38-57.20   37-52.16   

width                            unsigned short in struct at offset 16
                                 67-802.25$  0-2437.20   0-2441.20   0-2454.19   0-2478.37   
                                 0-2532.18   

x_max                            unsigned long in struct at offset 4
                                 67-762.32$  0-1255.9#  

x_min                            unsigned long in struct at offset 0
                                 67-762.25$  0-1254.9#  

xmem                             struct tag
                                 11-45.8$  11-46.1{  11-66.1}  15-200.20   15-400.16   
                                 15-486.12   15-580.12   15-610.17   15-611.17   9-196.12   
                                 9-215.12   

y_max                            unsigned long in struct at offset 12
                                 67-763.32$  0-1257.9#  

y_min                            unsigned long in struct at offset 8
                                 67-763.25$  0-1256.9#  


>>>>> FILE TABLE SECTION <<<<<

                                       FILE CREATION        FROM
FILE NO   FILENAME                    DATE       TIME       FILE    LINE
     0    ../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c
                                      07/27/94   21:36:26
     1    /aix/V4/rsc/41J/export/power/kernel/include/sys/types.h
                                      07/27/94   19:43:29      0      34
     2    /aix/V4/rsc/41J/src/bos/usr/include/standards.h
                                      07/27/94   19:37:54      1      29
     3    /aix/V4/rsc/41J/export/power/kernel/include/sys/m_types.h
                                      07/27/94   19:24:45      1     148
     4    /aix/V4/rsc/41J/export/power/kernel/include/sys/aixfont.h
                                      07/27/94   21:18:15      0      35
     5    /aix/V4/rsc/41J/export/power/kernel/include/lft.h
                                      07/27/94   21:19:02      0      36
     6    /aix/V4/rsc/41J/export/power/kernel/include/fkproc.h
                                      07/27/94   21:18:19      5      33
     7    /aix/V4/rsc/41J/export/power/kernel/include/sys/intr.h
                                      01/20/95   16:01:35      6      27
     8    /aix/V4/rsc/41J/export/power/kernel/include/sys/m_intr.h
                                      07/27/94   19:24:33      7      34
     9    /aix/V4/rsc/41J/export/power/kernel/include/fkprocFont.h
                                      07/27/94   21:18:14      6      28
    10    /aix/V4/rsc/41J/export/power/kernel/include/sys/errno.h
                                      09/24/94   19:17:15      9      23
    11    /aix/V4/rsc/41J/export/power/kernel/include/sys/xmem.h
                                      07/27/94   19:48:27      9      24
    12    /aix/V4/rsc/41J/export/power/kernel/include/sys/display.h
                                      03/29/95   12:18:01      9      25
    13    /aix/V4/rsc/41J/export/power/kernel/include/sys/rcm_win.h
                                      05/13/95   10:50:14     12      31
    14    /aix/V4/rsc/41J/export/power/kernel/include/sys/aixgsc.h
                                      01/20/95   16:08:31     12      32
    15    /aix/V4/rsc/41J/export/power/kernel/include/sys/rcm.h
                                      03/29/95   12:18:07     12      33
    16    /aix/V4/rsc/41J/export/power/kernel/include/sys/systemcfg.h
                                      07/27/94   20:04:43     15      21
    17    /aix/V4/rsc/41J/export/power/kernel/include/sys/except.h
                                      07/27/94   19:12:09     15      22
    18    /aix/V4/rsc/41J/export/power/kernel/include/sys/m_except.h
                                      07/27/94   19:24:28     17      21
    19    /aix/V4/rsc/41J/export/power/kernel/include/sys/proc.h
                                      03/22/95   12:44:35     15      23
    20    /aix/V4/rsc/41J/export/power/kernel/include/sys/ptrace.h
                                      07/27/94   19:31:50     19      30
    21    /aix/V4/rsc/41J/export/power/kernel/include/sys/thread.h
                                      04/14/95   17:18:21     20      24
    22    /aix/V4/rsc/41J/export/power/kernel/include/sys/mstsave.h
                                      11/12/94   11:59:45     21      28
    23    /aix/V4/rsc/41J/export/power/kernel/include/sys/m_param.h
                                      07/27/94   19:24:36     22      34
    24    /aix/V4/rsc/41J/export/power/kernel/include/sys/processor.h
                                      02/09/95   16:05:21     21      29
    25    /aix/V4/rsc/41J/export/power/kernel/include/sys/lock_def.h
                                      09/20/94   09:34:47     21      30
    26    /aix/V4/rsc/41J/export/power/kernel/include/sys/var.h
                                      07/27/94   19:45:37     21      31
    27    /aix/V4/rsc/41J/export/power/kernel/include/sys/atomic_op.h
                                      07/27/94   20:46:12     21      32
    28    /aix/V4/rsc/41J/export/power/kernel/include/sys/timer.h
                                      09/20/94   09:34:47     19      31
    29    /aix/V4/rsc/41J/export/power/kernel/include/sys/time.h
                                      07/27/94   19:41:42     28     124
    30    /aix/V4/rsc/41J/export/power/kernel/include/sys/resource.h
                                      07/27/94   19:33:27     19      32
    31    /aix/V4/rsc/41J/export/power/kernel/include/sys/pri.h
                                      07/27/94   19:31:09     19      34
    32    /aix/V4/rsc/41J/export/power/kernel/include/sys/proc.h
                                      03/22/95   12:44:35     31      29
    33    /aix/V4/rsc/41J/export/power/kernel/include/sys/lockl.h
                                      07/27/94   19:23:24     19      35
    34    /aix/V4/rsc/41J/export/power/kernel/include/sys/limits.h
                                      09/29/94   12:36:46     19      36
    35    /aix/V4/rsc/41J/src/bos/usr/include/float.h
                                      09/13/94   13:46:58     34     178
    36    /aix/V4/rsc/41J/export/power/kernel/include/sys/rcm_wg.h
                                      07/27/94   21:25:15     15      28
    37    /aix/V4/rsc/41J/export/power/kernel/include/sys/pwr_mgr.h
                                      09/03/94   08:46:01     12      34
    38    /aix/V4/rsc/41J/export/power/kernel/include/sys/watchdog.h
                                      07/27/94   19:47:05     37      21
    39    /aix/V4/rsc/41J/export/power/kernel/include/lft_swkbd.h
                                      07/27/94   21:19:05      5      34
    40    /aix/V4/rsc/41J/export/power/kernel/include/vt.h
                                      07/27/94   21:18:13      5      35
    41    /aix/V4/rsc/41J/export/power/kernel/include/sys/font.h
                                      07/27/94   21:18:16     40      17
    42    /aix/V4/rsc/41J/export/power/kernel/include/lft_dds.h
                                      04/23/95   14:59:00      5      36
    43    /aix/V4/rsc/41J/export/power/kernel/include/sys/cfgdb.h
                                      07/27/94   18:58:20     42      23
    44    /aix/V4/rsc/41J/export/power/kernel/include/kks.h
                                      07/27/94   21:19:10     42      24
    45    /aix/V4/rsc/41J/export/power/kernel/include/lftras.h
                                      07/27/94   21:19:09      5      37
    46    /aix/V4/rsc/41J/export/power/kernel/include/sys/dir.h
                                      07/27/94   19:08:03      0      37
    47    /aix/V4/rsc/41J/export/power/kernel/include/sys/lkup.h
                                      07/27/94   19:23:05     46     161
    48    /aix/V4/rsc/41J/src/bos/usr/include/limits.h
                                      07/27/94   19:22:45     46     165
    49    /aix/V4/rsc/41J/src/bos/usr/include/jfs/dir.h
                                      08/22/94   15:41:13     46     217
    50    /aix/V4/rsc/41J/export/power/kernel/include/sys/mdio.h
                                      04/12/95   14:23:27      0      38
    51    /aix/V4/rsc/41J/export/power/kernel/include/sys/file.h
                                      07/27/94   19:13:31      0      39
    52    /aix/V4/rsc/41J/export/power/kernel/include/sys/param.h
                                      07/27/94   19:29:23     51      21
    53    /aix/V4/rsc/41J/src/bos/usr/include/jfs/fsparam.h
                                      07/27/94   19:14:47     52      23
    54    /aix/V4/rsc/41J/export/power/kernel/include/sys/sysmacros.h
                                      07/27/94   19:40:20     52     173
    55    /aix/V4/rsc/41J/export/power/kernel/include/sys/param.h
                                      07/27/94   19:29:23     54      18
    56    /aix/V4/rsc/41J/export/power/kernel/include/sys/access.h
                                      07/27/94   18:51:12     51      22
    57    /aix/V4/rsc/41J/export/power/kernel/include/sys/cred.h
                                      07/27/94   19:03:31     51      24
    58    /aix/V4/rsc/41J/export/power/kernel/include/sys/priv.h
                                      07/27/94   19:31:21     57      29
    59    /aix/V4/rsc/41J/export/power/kernel/include/sys/mode.h
                                      07/27/94   19:26:28     58      19
    60    /aix/V4/rsc/41J/export/power/kernel/include/sys/tcb.h
                                      07/27/94   19:41:04     58      20
    61    /aix/V4/rsc/41J/export/power/kernel/include/sys/pcl.h
                                      07/27/94   19:29:49     58      28
    62    /aix/V4/rsc/41J/src/bos/usr/include/fcntl.h
                                      07/27/94   19:12:59     51      25
    63    /aix/V4/rsc/41J/export/power/kernel/include/sys/flock.h
                                      09/24/94   17:41:23     62      38
    64    /aix/V4/rsc/41J/src/bos/usr/include/unistd.h
                                      07/27/94   19:44:21     62      90
    65    /aix/V4/rsc/41J/export/power/kernel/include/sys/lockf.h
                                      07/27/94   19:23:23     64     353
    66    /aix/V4/rsc/41J/export/power/kernel/include/sys/stat.h
                                      07/27/94   19:38:01     62      94
    67    /aix/V4/rsc/41J/export/power/kernel/include/cdd.h
                                      07/27/94   21:20:48      0      66
    68    /aix/V4/rsc/41J/export/power/kernel/include/cdd_macros.h
                                      07/27/94   21:20:51      0      67
    69    /aix/V4/rsc/41J/src/bos/kernext/disp/rby/cdd/rby_cdd_hw_defs.h
                                      07/27/94   21:36:26      0      69


>>>>> COMPILATION EPILOGUE SECTION <<<<<

C Set ++ for AIX Summary of Diagnosed Conditions

TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
   19           0         0           0         19            0


Source records read.........................................   15306

1501-008  Compilation successful for file ../../../../../../../src/bos/kernext/disp/rby/cdd/cdd_entry.c.  Object file created.
