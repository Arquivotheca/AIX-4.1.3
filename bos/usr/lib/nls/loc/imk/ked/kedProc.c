static char sccsid[] = "@(#)73  1.5  src/bos/usr/lib/nls/loc/imk/ked/kedProc.c, libkr, bos411, 9428A410j 4/11/93 14:05:01";
/*
 * COMPONENT_NAME :	(libkr) - AIX Input Method
 *
 * FUNCTIONS :		kedProc.c
 *
 * ORIGINS :		27
 *
 * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 * combined with the aggregated modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp.  1991
 * All Rights Reserved
 * Licensed Materials - Property of IBM
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/******************************************************************
 *
 *  Component:    Korean IM ED  
 *
 *  Module:       kedProc.c 
 *
 *  Description:  Processes keystroke input 
 *
 *  Functions:	  kedProcess()
 *		  hjunique_kProcess();
 *		  enter_kProcess();
 *		  func2_kProcess();
 *		  mode_kProcess();
 *		  char_kProcess();
 *		  update_echobuf_to_string()
 *		  update_auxbuf_to_string()
 *		  update_echobuf_to_singcand()
 *		  update_echobuf_to_savech()
 *		  update_auxbuf_to_cands()
 *		  update_echobuf_to_multicand()
 *
 ******************************************************************/
/*-------------------------------*
*	Include files
*-------------------------------*/
#include <stdio.h>
#include <sys/types.h>
#include <ctype.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/keysymdef.h>

#include <im.h>
#include <imP.h>
#include "kedconst.h"
#include "x2keysym.h"
#include "ked.h"

/* Temporary KS codes are assigned to missing interim chars in KS code from 0xada1 to 0xada5 */
#define		Mchar_1stB		0xad
#define		Mchar_2ndB_Start	0xa1
#define		Missing_Char_Num	5

/*-----------------------------------------*
*	macro definition
*-----------------------------------------*/
#define         isHangeulInterim(x)     (((x) >= HG_ST_INTERIM) ? TRUE : FALSE)
#define         isHangeulInitial(x)     (((x) == HG_ST_INIT) ? TRUE : FALSE)
#define         isHangeulFinal(x)       (((x) == HG_ST_FINAL) ? TRUE : FALSE)
#define         isHanjaOn(x)            (((x) == MD_HJON)  ? TRUE : FALSE)
#define         isHanjaOff(x)           (((x) == MD_HJOFF) ? TRUE : FALSE)

int     isdelkey_fg; /* for support deletion by sum-so */

/*--------------------------------------------------------
*	editor process() :
* 		return value is one of
*		KP_UP, KP_DOWN, KP_USED, KP_NOTUSED
*--------------------------------------------------------*/
int kedFilter(kimed, immap, keysym, shift, imb)
KIMED    *kimed;
IMKeymap *immap;
KeySym keysym;
int shift;
IMBuffer *imb ;
{
	int hjunique_kProcess();
	int enter_kProcess();
	int func2_kProcess();
	int mode_kProcess();
	int char_kProcess();
	static int keycategory();
	unsigned char *htoi();

	uint	modifier;
	uchar	str[256];	/* pointer to char str generated by IMSimpleMapping */
	int	len;	/* length of above string */
	int	keytype;

	/*
	*  sets all trigger flags 'off'
	*/
	isdelkey_fg = OFF ;
	kimed->echochfg.flag = OFF ;
	kimed->echochfg.chtoppos = 0;
	kimed->echochfg.chlenbytes = 0;
	kimed->auxchfg  = OFF ;
	kimed->indchfg  = OFF ;
	kimed->eccrpsch = OFF ;
	kimed->axcrpsch = OFF ;
	kimed->curadv = 0;
	kimed->isbeep = OFF;
	kimed->missing_char_flag = FALSE ;   /*** for missing interim char in KS code ***/

	len = 0;
	modifier = shift;
	if (kimed->imode.basemode == MD_HAN || kimed->imode.basemode == MD_JAMO)
		modifier |= 0x20;
	if (kimed->imode.sizemode == MD_JEONJA)
		modifier |= 0x40;

	_IMSimpleMapping(immap, keysym, modifier, imb);
        memcpy(&str[0], imb->data, imb->len) ;
        len = imb->len ; 
	memset(imb->data, NULL, imb->len);  
	imb->len = 0 ;
#ifdef SHIFT
	fprintf(stderr, "shift=%d\n", modifier);
#endif

#ifdef STRING
	show_result(str, len);
#endif

	if ((shift == shift_ALT) || (shift == shift_CAPS_ALT))
	{
        	if (keysym == XK_Hangul)
                	keysym = XK_Hangul_Jamo ;
        	else if (keysym == XK_Hangul_Conversion)
                	keysym = XK_Hangul_MultipleCandidate ;
        	else if ((keysym == XK_Caps_Lock) || (keysym == XK_Hangul_Caps_Lock))
                	keysym = XK_Hangul_Jeonja ;
        	else if (keysym == XK_Hangul_Hanja)
                	keysym = XK_Hangul_Codeinput ;
	}
	if ((shift == shift_CTRL) && (keysym == XK_Hangul_Hanja))
		keysym = XK_Hangul_Codeinput ;

	keytype = keycategory(keysym, str, len);

#ifdef KEYTYPE
	show_keytype(keytype);
#endif

	switch(keytype)
	{
	case KEY_FN1:
		/* if echo buffer is empty */
		if (kimed->echoacsz == 0)
		{
			if (kimed->interstate == ST_CODEINP)
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			else
			{
			  switch(keysym)
			    {
				case XK_Tab :
		/*		case XK_BackTab :   */
				default :return KP_NOTUSED;
			     }
			}
		}
		else if (keysym ==XK_Escape)  /* for convenience of Korean vi users */
		{
			switch (kimed->interstate)
			{
			case ST_HAN :
			case ST_JAMO:
			     if (isHangeulInitial(kimed->hgstate))
                             {
                                kimed->isbeep = ON ;
                                return KP_USED ;
                             }
                             else if (isHangeulInterim(kimed->hgstate))
                             {
                                finalize_hg(kimed) ;
                                kimed->echocrps += 2;
                                if (kimed->echocrps >= kimed->echosize)
                                {
                                        kimed->isbeep = ON ;
                                        kimed->echocrps -= 2;
                                }
                                kimed->eccrpsch = ON;
                             }
                             else if (kimed->echosvchsp >= 0)
                             		change_attr_to_under(kimed);
                             kimed->imode.basemode = MD_ENG;
			     if (kimed->imode.sizemode == MD_JEONJA)
				kimed->imode.sizemode = MD_BANJA;
                             kimed->indchfg = ON;
                             kimed->interstate = ST_ENG;
                             placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                             initialize_buf_n_flag(kimed);
                             return KP_NOTUSED ;
                	case ST_MULTI :
                        /*
                         * Abandon hanja conversion, updates echobuf into echosvch.
                         */
        		  {
           		    int  i ;
           		    char  **aux_str ;

                            update_echobuf_to_savech(kimed);
                            kimed->interstate = curr_basemode(kimed);
                            kimed->auxuse = AUXBUF_NOTUSED ;

                            aux_str = kimed->auxbufs;
                            for(i=0;i<kimed->auxacsz.itemnum;i++)
                               memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize);
                            aux_str = kimed->auxbufa;
                            for(i=0;i<kimed->auxacsz.itemnum;i++)
                               memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize);
                            kimed->auxacsz.itemnum = 0 ;
                            kimed->auxacsz.itemsize = 0 ;
                            kimed->auxchfg = ON ;
                        /*
                         * Frees the memory allocated to candbuf.
                         */
                            free_candidates(kimed);
 			    if (kimed->acm == KP_ACMON)
/*
                            if ((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA))
*/
                            {
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                            };
                            return KP_USED;
         		  }
        		case ST_SING:
                	/*
                	* Abandon hanja conversion, updates echobuf into echosvch.
                	*/
                            update_echobuf_to_savech(kimed);
                            kimed->interstate = curr_basemode(kimed);
                            free_candidates(kimed);
 			    if (kimed->acm == KP_ACMON)
                            {
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                            };
                            return (KP_USED);
			}
			if ((kimed->interstate == ST_ENG) && ( kimed->imode.sizemode == MD_JEONJA))
			{
			     kimed->imode.sizemode = MD_BANJA;
			     kimed->indchfg = ON;
			     placestr(imb, kimed->echobufs, kimed->echoacsz) ;
			     initialize_buf_n_flag(kimed);
                             return KP_NOTUSED ;
			}
			else
			{
			      kimed->isbeep = ON;
			      return KP_USED;
			}
		}
		else if (keysym == XK_End)
		{
                       return KP_NOTUSED ;
		}
		else if ((keysym == XK_Home) || (keysym == XK_Prior) ||(keysym == XK_Next))
		{
		   switch (kimed->interstate)
                   {
                     case ST_HAN :
                     case ST_JAMO:
			if (isHangeulInitial(kimed->hgstate))
                        {
                                kimed->isbeep = ON ;
                                return KP_USED ;
                        }
                        else if (isHangeulInterim(kimed->hgstate))
                        {
                                finalize_hg(kimed) ;
                                kimed->echocrps += 2;
                                if (kimed->echocrps >= kimed->echosize)
                                {
                                        kimed->isbeep = ON ;
                                        kimed->echocrps -= 2;
                                }
                                kimed->eccrpsch = ON;
                         }
                         else if (kimed->echosvchsp >= 0)
                                 change_attr_to_under(kimed);
			 if (kimed->acm == KP_ACMON)
			 {
                         	placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                         	initialize_buf_n_flag(kimed);
			 }
                         return KP_NOTUSED ;
		    }
		    if (kimed->acm == KP_ACMON)
/*
		    if ((kimed->interstate == ST_ENG) && ( kimed->imode.sizemode == MD_JEONJA))
*/
                    {
                             placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                             initialize_buf_n_flag(kimed);
                             return KP_NOTUSED ;
                    }
                    else
                    {
                              kimed->isbeep = ON;
                              return KP_USED;
                    }
		}
		else
		{
		    kimed->isbeep = ON;
                    return KP_USED;
		}
		break;
	case KEY_SYSTEM:

		/* if echo buffer is empty */
		if (kimed->echoacsz == 0)
		{
			if (kimed->interstate == ST_CODEINP)
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			else
			{
			  switch(keysym)
			    {
				case XK_Print :
				case XK_Cancel :
		/*		case XK_Scroll_Lock :  */
		/* XK_Cancel is passwd instead of XK_Scroll_Lock */
				case XK_Pause :
				case XK_Execute :
				case XK_Num_Lock :
					return KP_NOTUSED;
				default :
					return KP_NOTUSED;
			     }
			}
		}
                else if (keysym == 0xff7f)   /* NumLock key */
                         return KP_NOTUSED ; 
		else
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
		break;
	/*----------------------------------------------------
	*	Mode, hjunique, and char keys may have
	*	special meanning with with shift key.
	*----------------------------------------------------*/
	case KEY_SHIFT: return KP_NOTUSED;
	case KEY_HJUNI: return hjunique_kProcess(kimed, keysym, str, len, imb);
	case KEY_ENTER: return enter_kProcess(kimed, keysym, str, len, imb);
	case KEY_FN2:	return func2_kProcess(kimed, keysym, str, len, imb);
	case KEY_MODE:	return mode_kProcess(kimed, keysym, str, len, imb);
	case KEY_CHAR:	return char_kProcess(kimed, keysym, str, len, imb);
	default :	/* there is no key type */
		kimed->isbeep = ON; 
		return KP_USED;
	}
}

/*---------------------------------------------------------------
*   keycategory():
*         This routine returns key type 
*                         according to received key stroke data
*         key type is as follows:
*                  KEY_FN1, KEY_SYSTEM, KEY_MODE, KEY_HJUNI,
*                  KEY_SHIFT, KEY_FN2, KEY_ENTER, KEY_CHAR
*---------------------------------------------------------------*/

static int keycategory(keysym, str, len)
KeySym keysym;
unsigned char *str;
int len;
{
	/* return type of key string data */

/*
*  XK_Hangul_G ~ XK_Hangul_AreAE
*  XK_exclam ~ XK_asciitilde
*  (include XK_0 ~ XK_9, XK_A ~ XK_Z, XK_a ~ XK_z, special character)
*  XK_KP_0 ~ XK_KP_9, XK_KP_Multiply ~ XK_KP_Divide( these are keypad char.)
*  XK_Korean_Won
*/
	if (((keysym >= XK_exclam) && (keysym <= XK_asciitilde)) ||
		((keysym >= XK_KP_0) && (keysym <= XK_KP_9)) ||
		((keysym >= XK_KP_Multiply) && (keysym <= XK_KP_Divide)) ||
		(keysym == XK_Korean_Won) || (keysym == XK_notsign) ||
		(keysym == XK_cent))
				return KEY_CHAR;

/*
*  XK_Return, XK_KP_Enter
*/
	else if ((keysym == XK_Return) || (keysym == XK_KP_Enter)) return KEY_ENTER;


/*
*  XK_Left, XK_Up, XK_Right, XK_Down, XK_BackSpace, XK_Delete, XK_space
*/
	else if	((keysym == XK_space) || (keysym == XK_BackSpace) || 
		((keysym >= XK_Left) && (keysym <= XK_Down)) ||
		(keysym == XK_Delete)) return KEY_FN2;

/*
*  XK_Hangul, XK_Hangul_Hanja, XK_Hangul_Jamo, , XK_Hangul_Codeinput,
*  XK_Hangul_Jeonja, XK_Hangul_Banja,
*  XK_Caps_Lock, XK_Insert
*/
	else if (((keysym >= XK_Hangul) && (keysym <= XK_Hangul_Jeonja)) ||
		 (keysym == XK_Caps_Lock) || (keysym == XK_Insert)) return KEY_MODE;

/*
*  XK_F1 ~ XK_F12, XK_Tab, XK_Home,
*  XK_End, XK_Prior, XK_Next, XK_Escape
*/
	else if ((keysym >= XK_F1) && (keysym <= XK_F12)||
		(keysym == XK_Tab) || (keysym == XK_Home) ||
		(keysym == XK_End) || (keysym == XK_Prior) ||
		(keysym == XK_Next) || (keysym == XK_Escape)) return KEY_FN1;


/*
*  XK_Hangul_SingleCandidate, XK_Hangul_MutlitpleCandidate,
*  XK_Hangul_PreviousCandidate
*/

	else if ((keysym == XK_Hangul_Conversion) || (keysym == XK_Hangul_NonConversion) || (keysym == XK_Hangul_MultipleCandidate))
			return KEY_HJUNI;

/*
*  XK_Shift_L, XK_Shift_R, XK_Control_L, XK_Control_R,
*  XK_Meta_L, XK_Meta_R, XK_Alt_L, XK_Alt_R
*/
	else if (((keysym >= XK_Shift_L) && (keysym <= XK_Control_R)) ||
		((keysym >= XK_Meta_L) && (keysym <= XK_Alt_R))) return KEY_SHIFT;
/*
* XK_Print, XK_Cancel, XK_Pause, XK_Execute, XK_Num_Lock 
*/
	else return KEY_SYSTEM;
}


int func2_kProcess(kimed, keysym, str, len, imb)
KIMED *kimed;
KeySym keysym;
char *str;
int len;
IMBuffer *imb ;
{

	switch (keysym)
	{
	case XK_BackSpace: return process_BackSpace(kimed, str, len, imb);
	case XK_Delete:	return process_Delete(kimed, str, len, imb);
	case XK_space:	return process_Space(kimed, str, len, imb);
	case XK_Left:	return process_Left(kimed, str, len, imb);
	case XK_Right:	return process_Right(kimed, str, len, imb);
	case XK_Up:	return process_Up(kimed, str, len, imb);
	case XK_Down:	return process_Down(kimed, str, len, imb);
	default:	return KP_NOTUSED;
	}
}

int process_BackSpace(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED ; 
	}

	switch (kimed->interstate)
	{
	case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
			finalize_hj(kimed);
                        free_candidates(kimed);
			backspace(kimed);
				/*
				*   After processing BackSpace key,
				*   if there is no reversed hanja,
				*   do change state to ST_HAN
				*/
			if (kimed->echosvchlen == 0)
			        kimed->interstate = curr_basemode(kimed);
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	case ST_MULTI:	kimed->isbeep = ON; break;
	case ST_CODEINP:backspace(kimed) ;
			break;
	case ST_HAN:	if (!isHangeulFinal(kimed->hgstate))
			{
				if (kimed->hg_status_ps > 0)
				{
				    kimed->hgstate = HG_ST_DELETE;
				    len = hg_composer(&(kimed->hgstate),str,str,kimed);
				    isdelkey_fg = ON ;
				    update_echobuf_to_string(kimed, str, len);
				    break;
				}
				else
				{
				    kimed->hgstate = HG_ST_FINAL ;
				    kimed->echocrps += 2;
				}
			}
			backspace(kimed);
			break;
	default:	backspace(kimed) ; 
	}
	return KP_USED;
}

int process_Delete(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED ;
	}

	switch (kimed->interstate)
	{
	case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
			finalize_hj(kimed);
                        free_candidates(kimed);
			kimed->echocrps -= 2;
			delete(kimed);
				/*
				*   After processing Delete key,
				*   if there is no reversed hanja,
				*   do change state to ST_HAN
				*/
			if (kimed->echosvchlen == 0)
			        kimed->interstate = curr_basemode(kimed);
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	case ST_MULTI:	kimed->isbeep = ON; break;
	case ST_CODEINP:delete(kimed) ; break;
	case ST_HAN:	if (!isHangeulFinal(kimed->hgstate))
			{
				kimed->hgstate = HG_ST_FINAL ;
			}
			delete(kimed);
			break;
	default:	delete(kimed) ;
	}
	return KP_USED;
}

process_Space(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->echoacsz == 0 &&
		kimed->interstate != ST_CODEINP &&
			kimed->imode.sizemode == MD_BANJA)
	{
		placestr(imb, str, len) ;
		return KP_USED ; 
	}

	switch (kimed->interstate)
	{
	case ST_SING:   if (is_over_bound(kimed, str, len))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
			finalize_hj(kimed) ;  
			free_candidates(kimed);
			if (kimed->echocrps >= kimed->echosize)
			{
				kimed->isbeep = ON ;
				kimed->echocrps -= 2 ;
			}
			else
				space(kimed);
			kimed->interstate = curr_basemode(kimed);
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	case ST_MULTI:	kimed->isbeep = ON; break;
	case ST_CODEINP:kimed->isbeep = ON; break;
	case ST_HAN:	if (is_over_bound(kimed, str, len))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			if (isHangeulInitial(kimed->hgstate)) 
			{
				kimed->isbeep = ON;
				return KP_USED ;
			}
			else if (isHangeulInterim(kimed->hgstate)) 
			{
				finalize_hg(kimed);
				kimed->echocrps += 2;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					kimed->echocrps -= 2 ;
					return KP_USED ;
				}
				kimed->eccrpsch = ON;
			}
			else
			{
		  	   if (kimed->echosvchsp >= 0)
				change_attr_to_under(kimed);
			}
			space(kimed) ;
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	default:    /* ST_JAMO, ST_ENG */
	               if (is_over_bound(kimed, str, len))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			space(kimed) ;
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
	}
	return KP_USED;
}

int process_Left(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED ;
	}

	switch (kimed->interstate)
	{
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
				finalize_hj(kimed) ;
				free_candidates(kimed);
				kimed->interstate = curr_basemode(kimed);
      				kimed->echocrps -= 2 ;
				move_cursor_left(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
         				return KP_NOTUSED ;
				}
				else
					break;
		case ST_MULTI:	kimed->isbeep = ON; return KP_USED;
		case ST_CODEINP:move_cursor_left(kimed);
			        break;
		case ST_HAN:	if (isHangeulInitial(kimed->hgstate))
				{
					kimed->isbeep = ON;
                                        return KP_USED ;
				}
				else if (isHangeulInterim(kimed->hgstate))
					finalize_hg(kimed);
				else
					change_attr_to_under(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                               		initialize_buf_n_flag(kimed);
         				return KP_NOTUSED ;
				}
				else
				{
					move_cursor_left(kimed);
					break;
				}
		default: 	if (kimed->echosvchsp >= 0)
					change_attr_to_under(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
         				return KP_NOTUSED ;
				}
				else
					move_cursor_left(kimed);
	}
	return KP_USED;
}


int process_Right(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED;
	}

	switch (kimed->interstate)
	{
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
	        		finalize_hj(kimed) ;
				free_candidates(kimed);
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					kimed->echocrps -= 2 ;
				}
				kimed->interstate = curr_basemode(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
                                	return KP_NOTUSED ;
				}
				else
					break;
		case ST_MULTI:	kimed->isbeep = ON; break;
		case ST_CODEINP:move_cursor_right(kimed) ;
				break;
		case ST_HAN:	if (isHangeulInitial(kimed->hgstate))
				{
					kimed->isbeep = ON;
					return KP_USED ;
				}
				else if (isHangeulInterim(kimed->hgstate))
					finalize_hg(kimed);
				else
					change_attr_to_under(kimed);

				if (kimed->acm == KP_ACMON)
				{
                                	placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
                                	return KP_NOTUSED ;
				}
				else
				{
					move_cursor_right(kimed);
					break;
				}
		default: 	if (kimed->echosvchsp >= 0)
					change_attr_to_under(kimed);
				if (kimed->acm == KP_ACMON)
				{
                                	placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
                                	return KP_NOTUSED ;
				}
				move_cursor_right(kimed);
	}
	return KP_USED;
}


int process_Up(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED;
	}

	switch (kimed->interstate) {
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
				finalize_hj(kimed);
				free_candidates(kimed);
				kimed->interstate = curr_basemode(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
					return KP_NOTUSED;
				}
				else
					return KP_UP;
		case ST_MULTI:	kimed->isbeep = ON; return KP_USED;
		case ST_CODEINP:kimed->isbeep = ON; return KP_USED;
		case ST_HAN:	if (isHangeulInitial(kimed->hgstate)) {
					kimed->isbeep = ON;
					return KP_USED;
				}
				else if (isHangeulInterim(kimed->hgstate)) 
				{
					finalize_hg(kimed);
					if (kimed->acm == KP_ACMON)
					{
                                		placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                		initialize_buf_n_flag(kimed);
                                		return KP_NOTUSED ;
					}
					else
					{
						kimed->echocrps += 2 ;
						kimed->eccrpsch = ON ;
						return KP_UP;
					}
				}
				else
				{
					change_attr_to_under(kimed);
					if (kimed->acm == KP_ACMON)
					{
                                		placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                		initialize_buf_n_flag(kimed);
                                		return KP_NOTUSED ;
					}
					else
						return KP_UP;
				}
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                                return KP_NOTUSED ;
		default: 	if (kimed->echosvchsp >= 0)
					change_attr_to_under(kimed);
				if (kimed->acm == KP_ACMON)
				{
                                	placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
                                	return KP_NOTUSED ;
				}
				else
					return KP_UP;
	}
}

int process_Down(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb;
{
	if (kimed->echoacsz == 0 && kimed->interstate != ST_CODEINP)
	{
		return KP_NOTUSED;
	}

	switch (kimed->interstate) {
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
				finalize_hj(kimed);
				free_candidates(kimed);
				kimed->interstate = curr_basemode(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
					return KP_NOTUSED;
				}
				else
					return KP_DOWN;
		case ST_MULTI:	kimed->isbeep = ON; 
				return KP_USED;
		case ST_CODEINP:kimed->isbeep = ON; 
				return KP_USED;
		case ST_HAN:	if (isHangeulInitial(kimed->hgstate)) {
					kimed->isbeep = ON;
					return KP_USED;
				}
				else if (isHangeulInterim(kimed->hgstate)) 
				{
					finalize_hg(kimed);
					if (kimed->acm == KP_ACMOFF)
					{
						kimed->echocrps += 2 ;
						kimed->eccrpsch = ON ;
						return KP_DOWN;
					}
					else
					{
                                		placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                		initialize_buf_n_flag(kimed);
                                		return KP_NOTUSED ;
					}
				}
				else
				{
					change_attr_to_under(kimed);
					if (kimed->acm == KP_ACMOFF)
						return KP_DOWN;
					else
					{
                                		placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                		initialize_buf_n_flag(kimed);
                                		return KP_NOTUSED ;
					}
				}
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                                return KP_NOTUSED ;
		default: 	if (kimed->echosvchsp >= 0)
					change_attr_to_under(kimed);
				if (kimed->acm == ON)
				{
                                	placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
                                	return KP_NOTUSED ;
				}
				else
					return KP_DOWN;
	}
}


int char_kProcess(kimed, keysym, str, len, imb)
KIMED *kimed;
KeySym keysym;
char *str;
int len ;
IMBuffer *imb ;
{
        int num ;
	int ishexnum();

	if (len == 0)
		return KP_NOTUSED ;
	if (kimed->echoacsz == 0 && len == 1
		 && kimed->interstate != ST_CODEINP
		 && kimed->imode.sizemode == MD_BANJA)
	{
		return KP_NOTUSED ; 
	}


	switch (kimed->interstate)
	{
	case ST_SING:
		if (is_over_bound(kimed, str, len))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
		if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
			put_it_MRU(kimed);
		finalize_hj(kimed) ; 
		free_candidates(kimed);
		if (kimed->echocrps >= kimed->echosize)
		{
			kimed->isbeep = ON ;
			kimed->echocrps -= 2 ;
			kimed->interstate = curr_basemode(kimed);
			return KP_USED;
		}
		kimed->interstate = curr_basemode(kimed);
		if (isHangeulJamo(str, len) && (kimed->interstate == ST_HAN))
		{
			len = hg_composer(&(kimed->hgstate),str,str,kimed);
			if(len == 0)
			{
				kimed->isbeep = ON ;
				return KP_USED;
			}
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed) ;
			}
			if ((len == 2) && (kimed->imode.hjmode == ON) &&
				(isHangeulInitial(kimed->hgstate)))
			{
				kimed->echosvchsp = kimed->echocrps ;
				kimed->echosvchlen = 0;
			}
			update_echobuf_to_string(kimed, str, len);
		}
		else
		{
                	if (isNumericJeonja(str, len) && isHanjaOn(kimed->imode.hjmode))
		   	{
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed) ;
				}
				if (!is_there_echosvch(kimed))
			   	{ 
					kimed->echosvchsp = kimed->echocrps ;
					kimed->echosvchlen = 0 ;
			   	}
				kimed->curadv = len ;
				update_echobuf_to_string(kimed, str, len);
                    	}
			else
			{
				kimed->curadv = len ;
				update_echobuf_to_string(kimed, str, len);
				if (kimed->acm == KP_ACMON)
				{
				   placestr(imb, kimed->echobufs, kimed->echoacsz) ;
				   initialize_buf_n_flag(kimed) ;
				}
			}
		}
		break;
	case ST_MULTI:	
		if ((num = isvalidnum(kimed, str, len)) != -1)
		{
                  int  i ;
                  char  **aux_str ;

			update_echobuf_to_multicand(kimed, num) ;
			if ((kimed->isbeep == ON) && (kimed->eccrpsch == OFF))
			   	return KP_USED ;   
                        kimed->auxuse = AUXBUF_NOTUSED ;

	  		aux_str = kimed->auxbufs;
   			for(i=0;i<kimed->auxacsz.itemnum;i++) 
            	 	   memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize); 
			aux_str = kimed->auxbufa;
   			for(i=0;i<kimed->auxacsz.itemnum;i++) 
            		   memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize); 
			kimed->auxacsz.itemnum = 0 ;
			kimed->auxacsz.itemsize = 0 ;
			kimed->auxchfg = ON ;
			free_candidates(kimed);
			kimed->interstate = curr_basemode(kimed);
			if (kimed->acm == KP_ACMON)
/*
			if ((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA))
*/
                        {
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                        };
		}
		else
		{
			kimed->isbeep = ON; 
		}
		break;
	case ST_CODEINP:
		if (ishexnum(str, len))
		{
			update_auxbuf_to_string(kimed, str, len);
		}
		else
		{
			kimed->isbeep = ON;
		}
		break;
	case ST_JAMO:
	case ST_ENG:
		if (is_over_bound(kimed, str, len))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
                if (isNumericJeonja(str, len) && isHanjaOn(kimed->imode.hjmode))
		   {
			if (!is_there_echosvch(kimed))
			   { 
				kimed->echosvchsp = kimed->echocrps ;
				kimed->echosvchlen = 0 ;
			   }
			if (kimed->echosvchlen >= MAXEUMLEN)
			   {
				kimed->isbeep = ON ;
				return KP_USED ;
			   }
			kimed->curadv = len ;
			update_echobuf_to_string(kimed, str, len); 
                    }
		else
		   {
                        if (is_there_echosvch(kimed))
                           change_attr_to_under(kimed) ;   
			kimed->curadv = len ;
			update_echobuf_to_string(kimed, str, len); 
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                		initialize_buf_n_flag(kimed);
			}
                    }

		break;
	case ST_HAN:
		if (isHangeulJamo(str, len))
		{
		  int  old_hgstate ;

			old_hgstate = kimed->hgstate ;	
			len = hg_composer(&(kimed->hgstate),str,str,kimed); 
   			if (isHanjaOn(kimed->imode.hjmode) && kimed->echosvchlen >= MAXEUMLEN && !isNumericJeonja(kimed->echobufs + kimed->echosvchsp, 2) && (len == 4 || old_hgstate == HG_ST_FINAL))
			{
				kimed->isbeep = ON ;
				kimed->hgstate = old_hgstate ;
				return KP_USED ;
			}
			if (is_over_bound(kimed, str, len))
			{
				kimed->isbeep = ON;
				kimed->hgstate = HG_ST_FINAL;
				return KP_USED;
			}
#ifdef	AUTOMATA
	fprintf(stderr, "returned len of hangul automata = %d\n", len);
#endif
			switch(len)
			{
			case 0 :
				kimed->isbeep = ON ;
				return KP_USED ;
			case 4 :

				kimed->curadv = 2 ;
				/**********/
				/* Missing interim char in KS code would be displayed as bouble byte space */
				if ((str[0] == Mchar_1stB) && (str[1] >= Mchar_2ndB_Start) && (str[1] <= (Mchar_2ndB_Start + Missing_Char_Num - 1)))
				{
					str[0] = 0xa1 ;
					str[1] = 0xa1 ;
					kimed->missing_char_flag = TRUE ;
				}
				if ((str[2] == Mchar_1stB) && (str[3] >= Mchar_2ndB_Start) && (str[1] <= (Mchar_2ndB_Start + Missing_Char_Num - 1)))
				{
					str[2] = 0xa1 ;
					str[3] = 0xa1 ;
					kimed->missing_char_flag = TRUE ;
				}
   			        if ((kimed->acm == KP_ACMON) && (isHanjaOff(kimed->imode.hjmode))) 
                                {
					int i;

                                 	placestr(imb, str, 2) ;
                                        memcpy(kimed->echobufs + kimed->echocrps, str+2, 2) ;
                                        kimed->echochfg.flag = ON;
              			       /* Display only second character in interim state to 
                                          return string to application by character. The first
                                          character which has been finalized will be displayed
                                          by application after returning to the application. */ 
                                        kimed->echochfg.chtoppos = 0 ;
                                        kimed->echochfg.chlenbytes = 2 ;
					return KP_USED;
                                 }
                                       
				break ;
			case 2 :
				/**********/
				/* Missing interim char in KS code would be displayed as bouble byte space */
				if ((str[0] == Mchar_1stB) && (str[1] >= Mchar_2ndB_Start) && (str[1] <= (Mchar_2ndB_Start + Missing_Char_Num - 1)))
				{
					str[0] = 0xa1 ;
					str[1] = 0xa1 ;
					kimed->missing_char_flag = TRUE ;
				}
				/**********/

				if (isHanjaOn(kimed->imode.hjmode) &&
					isHangeulInitial(kimed->hgstate))
					if (is_there_echosvch(kimed))
				/* if there exists echo save character */
					{
 					    if (isNumericJeonja(kimed->echobufs+kimed->echosvchsp, 2))

 					     {	
                           		       change_attr_to_under(kimed) ;   
					       kimed->echosvchsp = kimed->echocrps ;
					       kimed->echosvchlen = 0;
					      }
					    break ;
					}
				/* if there exists no echo save character */
					else
					{
					kimed->echosvchsp = kimed->echocrps ;
					kimed->echosvchlen = 0;
					break ;
					}
			default : break;
			}
		} 
	/* when other character than hangeuljamo comes */
		else
		{
			if (is_over_bound(kimed, str, len))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}

		/* On composing hangeul */
			if (isHangeulInitial(kimed->hgstate))
			{
				kimed->isbeep = ON ;
				return KP_USED ;
			}
			else if (isHangeulInterim(kimed->hgstate))
			{
				finalize_hg(kimed) ; 
				kimed->echocrps += 2;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					kimed->echocrps -= 2;
					return KP_USED ;
				}
				kimed->eccrpsch = ON;
			}
                        if (isNumericJeonja(str, len) && isHanjaOn(kimed->imode.hjmode))
		   	{
				if (!is_there_echosvch(kimed))
			   	{ 
					if (kimed->acm == KP_ACMON)
					{
					   placestr(imb, kimed->echobufs, kimed->echoacsz);
					   initialize_buf_n_flag(kimed);
					}
					kimed->echosvchsp = kimed->echocrps ;
					kimed->echosvchlen = 0 ;
			   	}
				else
				{
				if (!isNumericJeonja(kimed->echobufs+kimed->echosvchsp, 2))
				   {
					change_attr_to_under(kimed) ;
					kimed->echosvchsp = kimed->echocrps ;
					kimed->echosvchlen = 0 ;
				   }
				else if (kimed->echosvchlen >= MAXEUMLEN)
				   	{
						kimed->isbeep = ON ;
						return KP_USED ;
					}
				}
			  	kimed->curadv = len ;
				update_echobuf_to_string(kimed, str, len) ;
				return KP_USED ;
                    	}
                        else if (is_there_echosvch(kimed))
                           	change_attr_to_under(kimed) ;   
			if (kimed->acm == KP_ACMON)
			{
				kimed->curadv = len ;
				update_echobuf_to_string(kimed, str, len) ;
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
				return KP_USED;
			}
		/* On the other state */
			kimed->curadv = len ;
		}
		update_echobuf_to_string(kimed, str, len) ;
		break;
	default : break;
	}
	return KP_USED;
}

/* enter key process */

int enter_kProcess(kimed, keysym, str, len, imb)
KIMED *kimed;
KeySym keysym;
char *str ;
int len;
IMBuffer *imb ;
{

	/* send ENTER key string data to the caller */

	if ((kimed->echoacsz == 0) && (kimed->interstate != ST_CODEINP))
	{
		return KP_NOTUSED ; 
	}
	else
	{
		int hexcodetoint();

		switch (kimed->interstate)
		{
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
				finalize_hj(kimed) ;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					kimed->echocrps -= 2 ;
				}
                        	kimed->interstate = curr_basemode(kimed);
				free_candidates(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
				}
				return KP_USED;
		case ST_MULTI :
        {
           int  i ;
           char  **aux_str ;
			if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
			put_it_MRU(kimed);
			finalize_hj(kimed) ;
                        kimed->interstate = curr_basemode(kimed);
                        kimed->auxuse = AUXBUF_NOTUSED ;

			aux_str = kimed->auxbufs;
   			for(i=0;i<kimed->auxacsz.itemnum;i++) 
            		   memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize); 
			aux_str = kimed->auxbufa;
   			for(i=0;i<kimed->auxacsz.itemnum;i++) 
            		   memset(*(aux_str)++, NULL, kimed->auxacsz.itemsize); 
                        kimed->auxacsz.itemnum = 0 ;
                        kimed->auxacsz.itemsize = 0 ;
                        kimed->auxchfg = ON ;
			/*
			 * Frees the memory allocated to candbuf.
		   	 */ 
			free_candidates(kimed);
			if (((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA)) || (kimed->acm == ON))
                        {
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                        };
                        return KP_USED;
         }
		case ST_CODEINP :
			len = kimed->auxacsz.itemsize;
			hexcodetoint(str, kimed->auxbufs[0], &len);
			if (len == 0 || !isvalidcode(str, len))
			{
			kimed->isbeep = ON;
			memcpy(kimed->auxbufs[0], CLEAR_CODEINPUT, sizeof(CLEAR_CODEINPUT) -1) ;
			kimed->auxacsz.itemnum = 1;
			kimed->auxacsz.itemsize = 0;
			kimed->auxchfg = ON;
			kimed->auxcrps.colpos = 0;
			kimed->auxcrps.rowpos = 0;
			kimed->axcrpsch = ON;
			return KP_USED;
			}
			if (len == 1 && kimed->echoacsz == 0)
			{
				placestr(imb, str, len) ;
				memcpy(kimed->auxbufs[0], CLEAR_CODEINPUT, sizeof(CLEAR_CODEINPUT) -1) ;
				kimed->auxacsz.itemnum = 1;
				kimed->auxacsz.itemsize = 0;
				kimed->auxchfg = ON;
				kimed->auxcrps.colpos = 0;
				kimed->auxcrps.rowpos = 0;
				kimed->axcrpsch = ON;
				return KP_USED ; 
			}
			kimed->curadv = len;
			update_echobuf_to_string(kimed, str, len);
			memcpy(kimed->auxbufs[0], CLEAR_CODEINPUT, sizeof(CLEAR_CODEINPUT) -1) ;
			kimed->auxacsz.itemnum = 1;
			kimed->auxacsz.itemsize = 0;
			kimed->auxchfg = ON;
			kimed->auxcrps.colpos = 0;
			kimed->auxcrps.rowpos = 0;
			kimed->axcrpsch = ON;
			return KP_USED;
		case ST_HAN :
		/* On composing hangeul */
			if (isHangeulInitial(kimed->hgstate))
			{
				kimed->isbeep = ON ;
				return KP_USED ;
			}
			else if (isHangeulInterim(kimed->hgstate))
			{
				if (kimed->echosvchlen > 0)
				{
					finalize_hg(kimed) ; 
					if (kimed->echocrps +2 >= kimed->echosize)
						kimed->isbeep = ON ;
					else
					{
						kimed->echocrps += 2 ;
						kimed->eccrpsch = ON;
					}
					if (kimed->acm == KP_ACMON)
					{
					   placestr(imb, kimed->echobufs, kimed->echoacsz) ;
					   initialize_buf_n_flag(kimed);
					}
					return KP_USED ;
				}
				finalize_hg(kimed) ; 
				if (kimed->echocrps + 2 >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					return KP_USED ;
				}
				kimed->echocrps += 2;
				kimed->eccrpsch = ON;
			}    
			else if (kimed->echosvchlen > 0)
			{
				change_attr_to_under(kimed) ;
				if (kimed->acm == KP_ACMON)
				{
				   placestr(imb, kimed->echobufs, kimed->echoacsz) ;
				   initialize_buf_n_flag(kimed);
				}
				return KP_USED ;
			}
			placestr(imb, kimed->echobufs, kimed->echoacsz) ;
			initialize_buf_n_flag(kimed);
			if (kimed->acm == KP_ACMON)
                        	return KP_NOTUSED ;
			else
				return KP_USED;
		default :
			if (kimed->echosvchlen > 0)
			{
				change_attr_to_under(kimed) ;
				if (kimed->acm == KP_ACMON)
				{
				   placestr(imb, kimed->echobufs, kimed->echoacsz) ;
				   initialize_buf_n_flag(kimed);
				}
				return KP_USED ;
			}
			placestr(imb, kimed->echobufs, kimed->echoacsz) ;
			initialize_buf_n_flag(kimed);
			if (kimed->acm == KP_ACMON)
                        	return KP_NOTUSED ;
			else
				return KP_USED;
		}
	}
}

/* (@) hj_Process.c */

#define		FIRST_OF_CANDLIST		0
#define		NEXTCANDS_SIZE			10
/*
*	candidates retreive mode.
*/
#define		FORWARD		1
#define		BACKWARD	0

 
int	hjunique_kProcess (kimed, keysym, str, len, imb)
KIMED	*kimed;
KeySym	keysym;
char    *str ;
int     len ;
IMBuffer *imb ;
{
	int	process_Conversion(),
		process_Noconversion(),
		process_Allcandidate();
		

	switch (keysym) {
	case XK_Hangul_Conversion: 
		return process_Conversion(kimed, str, len, imb);

	case XK_Hangul_NonConversion: 					
		return process_Noconversion(kimed, str, len, imb);

	case XK_Hangul_MultipleCandidate:
		return process_Allcandidate(kimed, str, len);	
	}
}


/*---------------------------------------------------------
		All candidates Process
----------------------------------------------------------*/
int	process_Allcandidate(kimed, str, len)
KIMED	*kimed;
{
	register int	status;
	int	update_auxbuf_to_cands(),
		finalize_hg(),
		get_candidates();

	if (isHanjaOff(kimed->imode.hjmode) || !is_there_echosvch(kimed) ||
		(!is_cursor_on_echosv_lstch(kimed) && 
                      !isNumericJeonja(kimed->echobufs+kimed->echosvchsp,2)))
	{
		kimed->isbeep = ON;
		return KP_USED;
	}

	switch (kimed->interstate)
	{
	case ST_SING: 
		if (!is_there_echosvch(kimed) ||
			!is_cursor_on_echosv_lstch(kimed))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
		kimed->interstate = ST_MULTI;
                kimed->auxuse = MULTICAND_USED ;
		/* 
		 * Inserts current pos candidates from candbufs into auxbuf.
		 */
		kimed->candgetfg = FORWARD;
		update_auxbuf_to_cands(kimed);
		return (KP_USED);
	case ST_MULTI:
		if (!is_there_echosvch(kimed) ||
			!is_cursor_on_echosv_lstch(kimed))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
		/*
		 * Increments candcrpos by next candidates size(i.e.10).
		 */
		kimed->candcrpos += NEXTCANDS_SIZE;
		kimed->candgetfg = FORWARD;
		update_auxbuf_to_cands(kimed);
		return (KP_USED);
	case ST_HAN:
		/* 
		 * Cannot converts this case, Beep required.
		 */
		if ((isHangeulInitial(kimed->hgstate))||isHanjaOff(kimed->imode.hjmode))
		{
			kimed->isbeep = ON;
			return (KP_USED);
		}
		else
		{
		/* 
		 * HanJa On. Here first conversion window needs. 
		 */
      		if (is_there_echosvch(kimed) && isNumericJeonja(kimed->echobufs+kimed->echosvchsp, 2))
		   {
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */

				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp,kimed->echosvchlen) ; 
			/* 
			* Get candidates from dictionary and inserts 
			* them into candbufs.  
			*/
				status = get_candidates(kimed);
				if (status > 1)
				{	/* success */
					kimed->candgetfg = FORWARD;
					kimed->interstate = ST_MULTI;
                                        kimed->auxuse = MULTICAND_USED ;
					kimed->candcrpos = FIRST_OF_CANDLIST;
				/* in case echobuf is full and numeric char is at the end of echobuf and it has reverse attribute for hj conversion... this case happens when some char is entered at the end of echobuf & cursor is not advanced with beep sound */
					if ((kimed->echocrps-kimed->echosvchsp) == kimed->echosvchlen)
						kimed->echocrps -= 2 ;
					update_auxbuf_to_cands(kimed);
				}
				else
					kimed->isbeep = ON;
				return (KP_USED);
		     }

			if (!is_there_echosvch(kimed) ||
				!is_cursor_on_echosv_lstch(kimed))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			if (kimed->echosvchsp == -1)
			{
				kimed->isbeep = ON;
				return (KP_USED);
			}
			else
			{
			        kimed->hgstate = HG_ST_FINAL ;
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */
				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp, kimed->echosvchlen) ;
				status = get_candidates(kimed);
				if (status > 1)
				{
					kimed->candgetfg = FORWARD;
					kimed->interstate = ST_MULTI;
                                        kimed->auxuse = MULTICAND_USED ;
					kimed->candcrpos = FIRST_OF_CANDLIST;
					update_auxbuf_to_cands(kimed);
				}
				else
				{
				
					kimed->hgstate = HG_ST_FINAL;
					kimed->echocrps += 2;
					if (kimed->echocrps >= kimed->echosize)
						kimed->echocrps -= 2 ;
					kimed->eccrpsch = ON;
					kimed->isbeep = ON;
				}
				return KP_USED;
			}
		}
		break;
	case ST_CODEINP:
			kimed->isbeep = ON;
			return (KP_USED);
	case ST_JAMO:
	default:
			if (kimed->echosvchsp == -1)
			{
				kimed->isbeep = ON;
				return (KP_USED);
			}
			else
			{
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */
				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp, kimed->echosvchlen) ;
				status = get_candidates(kimed);
				if (status > 1)
				{
					kimed->candgetfg = FORWARD;
					kimed->interstate = ST_MULTI;
                                        kimed->auxuse = MULTICAND_USED ;
					kimed->candcrpos = FIRST_OF_CANDLIST;
				/* in case echobuf is full and numeric char is at the end of echobuf and it has reverse attribute for hj conversion... this case happens when some char is entered at the end of echobuf & cursor is not advanced with beep sound */
					if ((kimed->echocrps-kimed->echosvchsp) == kimed->echosvchlen)
						kimed->echocrps -= 2 ;
					update_auxbuf_to_cands(kimed);
				}
				else
				{
				
					kimed->isbeep = ON;
				}
				return KP_USED;
			}
	} /* switch */
}					


/*------------------------------------------------
	conversion key process
-------------------------------------------------*/
int	process_Conversion(kimed, str, len, imb)
KIMED	*kimed;
char    *str ;
int     len ;
IMBuffer *imb ;
{
	register int	status;
	extern int 	get_candidates();
	int	update_echobuf_to_singcand(),
		finalize_hg(),
		update_auxbuf_to_cands();

	if (kimed->echoacsz == 0 &&
		kimed->interstate != ST_CODEINP &&
			kimed->imode.sizemode == MD_BANJA)
	{
		placestr(imb, " ", 1) ;
		return KP_USED ; 
	}

	switch (kimed->interstate)
	{
	case ST_SING:         
		/* 
		* Get the forward next candidate from candbufs and then
		* copy it to echobufs.
		*/

		if (!is_there_echosvch(kimed) ||
			!is_cursor_on_echosv_lstch(kimed))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}

		/* 
		* (kimed->candsize-2) means actual end of 
		* array index of candbufs.
		*/
		if (kimed->candcrpos >= (kimed->candsize-1))
			kimed->candcrpos = FIRST_OF_CANDLIST;
		else kimed->candcrpos++;
		update_echobuf_to_singcand(kimed);
		return (KP_USED);
	case ST_MULTI:         
		/* 
		* Next 10 candidates needs.
		*/

		if (!is_there_echosvch(kimed) ||
			!is_cursor_on_echosv_lstch(kimed))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}

		kimed->candcrpos += NEXTCANDS_SIZE;
		kimed->candgetfg = FORWARD;
		update_auxbuf_to_cands(kimed);
		return (KP_USED);
	case ST_CODEINP:
		kimed->isbeep = ON ;
		return KP_USED ;
	case ST_ENG:               
	case ST_JAMO:             
			if (kimed->echosvchsp == -1)
			{
				space(kimed);
				return (KP_USED);
			}
			else if (kimed->echosvchlen == 0)
			{
				kimed->echosvchsp = -1;
				space(kimed); 
				return KP_USED ;
			}
			else
			{
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */
				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp,kimed->echosvchlen) ; 
			/* 
			* Get candidates from dictionary and inserts 
			* them into candbufs.  
			*/
				status = get_candidates(kimed);
				if (status > 1)
				{	/* success */
					kimed->interstate = ST_SING;
					kimed->candcrpos = FIRST_OF_CANDLIST;
			/*
			* Copy the current pos candbuf to echobufs.
			*/
				/* in case echobuf is full and numeric char is at the end of echobuf and it has reverse attribute for hj conversion... this case happens when some char is entered at the end of echobuf & cursor is not advanced with beep sound */
					if ((kimed->echocrps-kimed->echosvchsp) == kimed->echosvchlen)
                                        	kimed->echocrps -= 2 ;
					update_echobuf_to_singcand(kimed);
					return (KP_USED);
				}
				else
					kimed->isbeep = ON;
				return KP_USED;
			}
	case ST_HAN:   
      		if (is_there_echosvch(kimed) && isNumericJeonja(kimed->echobufs+kimed->echosvchsp, 2))
		   {
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */
				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp,kimed->echosvchlen) ; 
			/* 
			* Get candidates from dictionary and inserts 
			* them into candbufs.  
			*/
				status = get_candidates(kimed);
				if (status > 1)
				{	/* success */
					kimed->interstate = ST_SING;
					kimed->candcrpos = FIRST_OF_CANDLIST;
			/*
			* Copy the current pos candbuf to echobufs.
			*/
				/* in case echobuf is full and numeric char is at the end of echobuf and it has reverse attribute for hj conversion... this case happens when some char is entered at the end of echobuf & cursor is not advanced with beep sound */
					if ((kimed->echocrps-kimed->echosvchsp) == kimed->echosvchlen)
						kimed->echocrps -= 2 ;
					update_echobuf_to_singcand(kimed);
				}
				else
					kimed->isbeep = ON;
				return (KP_USED);
		     }

		if (isHanjaOn(kimed->imode.hjmode) &&
			(!is_there_echosvch(kimed) ||
				!is_cursor_on_echosv_lstch(kimed)))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}

		if (isHangeulInitial(kimed->hgstate))
		{
		/*
		* Cannot converts this state.
		*/
			kimed->isbeep = ON;
			return (KP_USED);
		}
		if (isHanjaOff(kimed->imode.hjmode))
		{
			if (isHangeulInterim(kimed->hgstate))
			{
				finalize_hg(kimed);
				kimed->echocrps += 2;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->echocrps -= 2 ;
					kimed->isbeep = ON ;
					return KP_USED ;
				}
				kimed->eccrpsch = ON;
				space(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                             		initialize_buf_n_flag(kimed);
				}
				return (KP_USED);
			}
			else
			{
				space(kimed) ;
				return KP_USED ;
			} 
		}
		else
		{
		/*
		************************************************
		* Hanja ON; needs single candidate conversion.
		************************************************
		*/
			/*
			* if exists no echo save char.
			*/
			if (kimed->echosvchsp == -1)
			{
				space(kimed);
				return (KP_USED);
			}
			else if (kimed->echosvchlen == 0)
			{
				kimed->echosvchsp = -1 ;
				space(kimed);
				return (KP_USED);
			}
			else
			{
				kimed->hgstate = HG_ST_FINAL ;
			/* set echosvchlen and allocate memory for hangeul-hanja conversion */
				memset(kimed->echosvch, NULL, MAXEUMLEN);
				memcpy(kimed->echosvch, kimed->echobufs+kimed->echosvchsp,kimed->echosvchlen) ; 
			/* 
			* Get candidates from dictionary and inserts 
			* them into candbufs.  
			*/
				status = get_candidates(kimed);
				if (status > 1)
				{	/* success */
					kimed->interstate = ST_SING;
					kimed->candcrpos = FIRST_OF_CANDLIST;
			/*
			* Copy the current pos candbuf to echobufs.
			*/
					update_echobuf_to_singcand(kimed);
					return (KP_USED);
				}
				else
				{
					kimed->echocrps += 2;
					if (kimed->echocrps >= kimed->echosize)
						kimed->echocrps -= 2 ;
					kimed->eccrpsch = ON;
					kimed->isbeep = ON;
				}
				return KP_USED;
			}
		}         /* else */
	}	/* switch */
}


/*-----------------------------------------------------------
	Non-conversion key processing routine.
------------------------------------------------------------*/
int	process_Noconversion (kimed, str, len, imb)
KIMED	*kimed;
char    *str ;    
int     len ;
IMBuffer *imb ;
{
	int	update_auxbuf_to_cands(),
		finalize_hg();

	if (kimed->echoacsz == 0 &&
		kimed->interstate != ST_CODEINP &&
			kimed->imode.sizemode == MD_BANJA)
	{
		placestr(imb, " ", 1) ;
		return KP_USED ; 
	}
	switch (kimed->interstate)
	{
	case ST_SING: 
		/* design spec is changed to keep consistency with GUI */
			if (kimed->candcrpos == FIRST_OF_CANDLIST)
				kimed->candcrpos = kimed->candsize-1 ;
                	else kimed->candcrpos--;
                	update_echobuf_to_singcand(kimed);
		/*
		* Abandon hanja conversion, updates echobuf into echosvch.
			update_echobuf_to_savech(kimed);
			kimed->interstate = curr_basemode(kimed);
			free_candidates(kimed);
		*/
			return (KP_USED);
	case ST_MULTI:           
		if (!is_there_echosvch(kimed) ||
			!is_cursor_on_echosv_lstch(kimed))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
		if (kimed->candcrpos == FIRST_OF_CANDLIST)
		{
		/*
		* Shows rest candidates here.
		*/
			kimed->candcrpos=(kimed->candsize)-(kimed->candsize%NEXTCANDS_SIZE);		
			if (kimed->candcrpos == kimed->candsize)
                            kimed->candcrpos -= NEXTCANDS_SIZE ;
			kimed->candgetfg = FORWARD;
		} else 
			kimed->candgetfg = BACKWARD;
		/*
		* The candcrpos is updated in update_auxbuf_to_cands().
		*/
		update_auxbuf_to_cands(kimed);
		return (KP_USED);

	case ST_CODEINP:
			kimed->isbeep = ON;
			return (KP_USED);

	case ST_HAN:
			if (isHangeulInitial(kimed->hgstate))
			{
				kimed->isbeep = ON;
				return (KP_USED);
			}

			if (isHangeulInterim(kimed->hgstate)) {
				if (is_there_echosvch(kimed))
				{
					finalize_hg(kimed);
					kimed->echocrps += 2;
					if (kimed->echocrps >= kimed->echosize)
					{
						kimed->echocrps -= 2 ;
						kimed->isbeep = ON ;
						return KP_USED ;
					}
					kimed->eccrpsch = ON;
					if (kimed->acm == KP_ACMON)
					{
						placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                             			initialize_buf_n_flag(kimed);
					}
					return (KP_USED); 
				}
				else
				{
					finalize_hg(kimed);
					kimed->echocrps += 2;
					if (kimed->echocrps >= kimed->echosize)
					{
						kimed->echocrps -= 2 ;
						kimed->isbeep = ON ;
						return KP_USED ;
					}
					kimed->eccrpsch = ON;
					space(kimed);
					if (kimed->acm == KP_ACMON)
					{
						placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                             			initialize_buf_n_flag(kimed);
					}
					return (KP_USED); 
				}
			}

	case ST_ENG:
	case ST_JAMO:
	default:
		  	if (kimed->echosvchsp >= 0)
                                change_attr_to_under(kimed);
			else
				space(kimed);
			if (kimed->acm == KP_ACMON)
			{
                                placestr(imb, kimed->echobufs, kimed->echoacsz)
 ;
                                initialize_buf_n_flag(kimed);
			}
			return (KP_USED);
	}
}


int mode_kProcess(kimed, keysym, str, len, imb)
KIMED *kimed;
KeySym keysym;
char *str;
int len;
IMBuffer *imb ;
{
	switch (keysym) {
		case XK_Hangul_Codeinput : return process_Codeinp(kimed, str, len,imb);
		case XK_Hangul_Hanja : return process_Hanja(kimed, str, len, imb);
		case XK_Hangul_Jeonja : return process_BanJeon(kimed, str, len, imb);
		case XK_Insert  : return process_Insert(kimed, str, len, imb);
		case XK_Hangul_Jamo : return process_Jamo(kimed, str, len, imb);
		case XK_Hangul : return process_HgEng(kimed, str, len, imb);
		case XK_Caps_Lock : 
		default :	return KP_NOTUSED;
	}
}


int process_Codeinp(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	int i, auxsize, auxnum;
	char **aux_str, *firstaux;

	switch (kimed->interstate)
	{
	case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
			finalize_hj(kimed);
			free_candidates(kimed);
			if (kimed->echocrps >= kimed->echosize)
			{
				kimed->isbeep = ON;
				kimed->echocrps -= 2 ;
			}
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	case ST_MULTI :	kimed->isbeep = ON; return KP_USED;
	case ST_CODEINP:kimed->interstate = curr_basemode(kimed); 
			auxsize = kimed->auxsize.itemsize;
			firstaux = kimed->auxbufs[0];
			memset(firstaux, NULL, auxsize);
			firstaux = kimed->auxbufa[0];
			memset(firstaux, NULL, auxsize);
                        kimed->auxuse = AUXBUF_NOTUSED ;
			kimed->auxacsz.itemnum = 0;
			kimed->auxacsz.itemsize = 0;
			kimed->auxcrps.colpos = -1 ;
			kimed->auxcrps.rowpos = -1 ;
			kimed->axcrpsch = ON;
			kimed->auxchfg = ON;
			if ((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA))
                        {
                                placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                initialize_buf_n_flag(kimed);
                        };
			return KP_USED;
	case ST_ENG :	
	case ST_JAMO :
			if (kimed->echosvchsp >= 0)
                                change_attr_to_under(kimed);
			if (kimed->acm == KP_ACMON)
                        {
                                placestr(imb, kimed->echobufs, kimed->echoacsz)
 ;
                                initialize_buf_n_flag(kimed);
                        }
                        break ;
	case ST_HAN :
		/* On composing hangeul */
			if (isHangeulInitial(kimed->hgstate))
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			else if (isHangeulInterim(kimed->hgstate))
			{
				if (kimed->echocrps + 2 >= kimed->echosize)
				    /* buffer bound test */
				{
					kimed->isbeep = ON;
					return KP_USED;
				}
				finalize_hg(kimed);
				kimed->echocrps += 2;
				kimed->eccrpsch = ON;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->echocrps -= 2 ;
					kimed->isbeep = ON ;
				}
			}  
			else
			{
				change_attr_to_under(kimed);
			}
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	default :	kimed->isbeep = ON; return KP_USED;
	}

	kimed->interstate = ST_CODEINP;
        kimed->auxuse = CODEINPUT_USED ;
	auxsize = kimed->auxsize.itemsize;
	auxnum = kimed->auxsize.itemnum;

	aux_str = kimed->auxbufs;
	for(i=0;i<auxnum;i++)
		memset(*(aux_str)++, NULL, auxsize);

	aux_str = kimed->auxbufa;
	for(i=0;i<auxnum;i++)
		memset(*(aux_str)++, NULL, auxsize);

	kimed->auxchfg = ON ; 
	kimed->auxacsz.itemnum = 1;
	kimed->auxacsz.itemsize = 0;
	kimed->auxcrps.colpos = 0;
	kimed->auxcrps.rowpos = 0;
	kimed->axcrpsch = ON;
	return KP_USED;
}

int process_Hanja(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb;
{
	switch (kimed->interstate) {
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
					put_it_MRU(kimed);
				finalize_hj(kimed);
				free_candidates(kimed);
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON;
					kimed->echocrps -= 2 ;
				}
				kimed->interstate = curr_basemode(kimed);
				kimed->imode.hjmode = MD_HJOFF;
                                kimed->indchfg = ON ;
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
				}
				break;
		case ST_CODEINP :
		case ST_MULTI :	kimed->isbeep = ON;
				break;
                case ST_HAN   : if (isHangeulInitial(kimed->hgstate))
				{
					kimed->isbeep = ON ;
					return KP_USED ;
                                }
                                else if (isHangeulInterim(kimed->hgstate))
				{
					if (kimed->echocrps + 2 >= kimed->echosize)
					{
						kimed->isbeep = ON;
						return KP_USED;
					}
					finalize_hg(kimed) ;
					if (kimed->echocrps + 2 >= kimed->echosize)
						kimed->isbeep = ON;
					else
						kimed->echocrps += 2;
					kimed->eccrpsch = ON;

				}
				else
				{
					change_attr_to_under(kimed);
				}
		default :	if (kimed->imode.hjmode == MD_HJON)
				{
					kimed->imode.hjmode = MD_HJOFF;
					change_attr_to_under(kimed);
				}
				else
				{
					kimed->imode.hjmode = MD_HJON;
					kimed->imode.basemode = MD_HAN;
					kimed->interstate = ST_HAN;
				}
				kimed->indchfg = ON;
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
				}
	}
	return KP_USED;
}

int process_BanJeon(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	if (kimed->imode.sizemode == MD_BANJA)
		kimed->imode.sizemode = MD_JEONJA;
	else 
	{
	    if ((kimed->interstate == ST_ENG) && (kimed->echoacsz > 0))
            {
                 placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                 initialize_buf_n_flag(kimed);
             };
	     kimed->imode.sizemode = MD_BANJA;
	}
	kimed->indchfg = ON;
	return KP_USED;
}

int process_Insert(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb;
{
	if ((kimed->echoacsz == 0) && (kimed->interstate != ST_CODEINP))
	{
		return KP_NOTUSED ; 
	}
	switch (kimed->interstate)
	{
	case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
			finalize_hj(kimed);
			free_candidates(kimed);
			if (kimed->echocrps >= kimed->echosize)
			{
				kimed->isbeep = ON;
				kimed->echocrps -= 2 ;
			}
			kimed->interstate = curr_basemode(kimed);
			if (kimed->imode.insrepmode == MD_INSERT)
				kimed->imode.insrepmode = MD_REPLACE;
			else kimed->imode.insrepmode = MD_INSERT;
			kimed->indchfg = ON;
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
			break;
	case ST_MULTI :	kimed->isbeep = ON; break;
	case ST_HAN :

	/* In case Hangeul Initial consonant */
		if (isHangeulInitial(kimed->hgstate))
		{
			kimed->isbeep = ON;
			return KP_USED;
		}
	/* In case Hangeul Interim consonant */
		else if (isHangeulInterim(kimed->hgstate))
		{
			if (kimed->echocrps + 2 >= kimed->echosize)
				/* buffer bound test */
			{
				kimed->isbeep = ON;
				return KP_USED;
			}
			finalize_hg(kimed);
			if (kimed->echocrps + 2 >= kimed->echosize)
				kimed->isbeep = ON ;
			else
				kimed->echocrps += 2;
			kimed->eccrpsch = ON;
			if (kimed->imode.insrepmode == MD_INSERT)
				kimed->imode.insrepmode = MD_REPLACE;
			else kimed->imode.insrepmode = MD_INSERT;
			kimed->indchfg = ON;
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
		}
	/* In the other case */
		else
		{
			change_attr_to_under(kimed);
			if (kimed->imode.insrepmode == MD_INSERT)
				kimed->imode.insrepmode = MD_REPLACE;
			else kimed->imode.insrepmode = MD_INSERT;
			kimed->indchfg = ON;
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
		}
		break;
	default :	if (kimed->imode.insrepmode == MD_INSERT)
				kimed->imode.insrepmode = MD_REPLACE;
			else kimed->imode.insrepmode = MD_INSERT;
			kimed->indchfg = ON;
	}
	return KP_USED;
}

int process_Jamo(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb;
{
	switch (kimed->interstate) {
		case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
					put_it_MRU(kimed);
				finalize_hj(kimed);
				free_candidates(kimed);
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON;
					kimed->echocrps -= 2 ;
				}
                                if (kimed->imode.basemode == MD_JAMO)
				{
					kimed->interstate = ST_JAMO;
  	                                       break ;
				}
				else kimed->prevhemode = kimed->imode.basemode;

				kimed->imode.basemode = MD_JAMO;
				kimed->interstate = ST_JAMO;
				kimed->indchfg = ON;
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
				}
				break;
		case ST_CODEINP :
		case ST_MULTI :	if (kimed->imode.basemode == MD_JAMO)
                                         break ;
				else kimed->prevhemode = kimed->imode.basemode;
				kimed->imode.basemode = MD_JAMO;
				kimed->indchfg = ON;
				break;
		case ST_JAMO :	break;
		case ST_ENG  :  if (kimed->echosvchsp >= 0)
					change_attr_to_under(kimed);
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                                	initialize_buf_n_flag(kimed);
				}
				kimed->prevhemode = MD_ENG;
				kimed->imode.basemode = MD_JAMO;
				kimed->interstate = ST_JAMO;
				kimed->indchfg = ON;
				break;
		case ST_HAN :	if (isHangeulInitial(kimed->hgstate))
					kimed->isbeep = ON;
				else if (isHangeulInterim(kimed->hgstate))
				{
					finalize_hg(kimed);
					if (kimed->echocrps + 2 >= kimed->echosize)
						kimed->isbeep = ON ;
					else
						kimed->echocrps += 2;
					kimed->eccrpsch = ON;
					kimed->prevhemode = MD_HAN;
					kimed->imode.basemode = MD_JAMO;
					kimed->interstate = ST_JAMO;
					kimed->indchfg = ON;
				}
				else
				{
				  	if (kimed->echosvchsp >= 0)
						change_attr_to_under(kimed);
					kimed->prevhemode = MD_HAN;
					kimed->imode.basemode = MD_JAMO;
					kimed->interstate = ST_JAMO;
					kimed->indchfg = ON;
				}
				if (kimed->acm == KP_ACMON)
				{
					placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        		initialize_buf_n_flag(kimed);
				}
		}
		return KP_USED;
}

int process_HgEng(kimed, str, len, imb)
KIMED *kimed;
char *str;
int len;
IMBuffer *imb ;
{
	switch (kimed->interstate)
	{
	case ST_SING:	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
				put_it_MRU(kimed);
        		finalize_hj(kimed);
			free_candidates(kimed);
			if (kimed->echocrps >= kimed->echosize)
			{
				kimed->isbeep = ON;
				kimed->echocrps -= 2 ;
			}
			switch (kimed->imode.basemode)
			{
			case MD_ENG:
				kimed->imode.basemode = MD_HAN;
				kimed->indchfg = ON;
				break;
			case MD_HAN :
				kimed->imode.basemode = MD_ENG;
				kimed->indchfg = ON;
				break;
			case MD_JAMO :
				kimed->imode.basemode = kimed->prevhemode;
				kimed->indchfg = ON;
			}
	        	kimed->interstate = curr_basemode(kimed);
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			};
			break;
	case ST_MULTI :	
	case ST_CODEINP :
		switch (kimed->imode.basemode)
		{
		case MD_ENG:
			kimed->imode.basemode = MD_HAN;
			kimed->indchfg = ON;
			break;
		case MD_HAN :
			kimed->imode.basemode = MD_ENG;
			kimed->indchfg = ON;
			break;
		case MD_JAMO :
			kimed->imode.basemode = kimed->prevhemode;
			kimed->indchfg = ON;
		}
		break;
	case ST_JAMO :	kimed->imode.basemode = kimed->prevhemode;
			kimed->interstate = prevhestate(kimed);
		  	if (kimed->echosvchsp >= 0)
				change_attr_to_under(kimed);
			
			kimed->indchfg = ON;
/*
			if (((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA)) || (kimed->acm == KP_ACMON))
*/
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			};
			break ;
	case ST_HAN :	if (isHangeulInitial(kimed->hgstate))
			{
				kimed->isbeep = ON ;
				return KP_USED ;
			}
			else if (isHangeulInterim(kimed->hgstate))
			{
				finalize_hg(kimed) ;
				kimed->echocrps += 2;
				if (kimed->echocrps >= kimed->echosize)
				{
					kimed->isbeep = ON ;
					kimed->echocrps -= 2;
				}
				kimed->eccrpsch = ON;
			}
			else
			{
		  	   if (kimed->echosvchsp >= 0)
				change_attr_to_under(kimed);
			}
                        kimed->imode.basemode = MD_ENG;
			kimed->interstate = ST_ENG;
			kimed->indchfg = ON;
/*
			if ((kimed->interstate == ST_ENG) && (kimed->imode.sizemode == MD_BANJA))
*/
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			};
			break;
	case ST_ENG :	kimed->imode.basemode = MD_HAN;
			kimed->interstate = ST_HAN;
			kimed->indchfg = ON;
		  	if (kimed->echosvchsp >= 0)
				change_attr_to_under(kimed);
			if (kimed->acm == KP_ACMON)
			{
				placestr(imb, kimed->echobufs, kimed->echoacsz) ;
                        	initialize_buf_n_flag(kimed);
			}
	}
	return KP_USED;
}


/***********************************************************/
/*             buf manipulation functions                  */
/***********************************************************/

update_echobuf_to_string(kimed, str, len)
KIMED *kimed;
char *str;
int len;
{
	int lastch, postcrsz;
	char *poststr ;
        char *postbegin ;
        int  postfg ;

        postfg = OFF ;
        postcrsz = 0 ;

/* In case the string is appended to the last byte of echobufs */
/* occurred in (hgstate = initial and len = 2) or (hgstate = final) */
	if (kimed->echoacsz == kimed->echocrps)
	{
		int i, lastps;
		lastps = kimed->echocrps + len - 1;

                if ((kimed->echoacsz + len) > kimed->echosize)
		   {
			kimed->isbeep = ON ;
                        return ;
                    }
	/* update echo buffer string */
		memcpy((kimed->echobufs)+(kimed->echocrps), str, len);

	/* update echo buffer attribute */

	/*	if (isHanjaOn(kimed->imode.hjmode) && 
		     (isHangeulCode(str, len) || isNumericJeonja(str, len)) &&
				kimed->echosvchsp >= 0)   */
	/********   For the missing interim chars in KS code, they are converted to double byte space to be displayed as space, so, though they are not hangeul code they are treated as if hangeul code ***********/
		if (isHanjaOn(kimed->imode.hjmode) && 
		     (kimed->missing_char_flag || isHangeulCode(str, len) || isNumericJeonja(str, len)) &&
				kimed->echosvchsp >= 0)
		{
		/* double byte reverse */
			for (i = kimed->echocrps; i <= lastps; i++)
				kimed->echobufa[i] = KP_HL_REVERSE;
			kimed->echosvchlen += 2;
		}
		else
		{
			for (i = kimed->echocrps; i <= lastps; i++)
				kimed->echobufa[i] = KP_HL_UNDER;
		}

	/* set buffer change flag */
                if (kimed->echochfg.flag == OFF)
                   {
		        kimed->echochfg.flag = ON;
	         	kimed->echochfg.chtoppos = kimed->echocrps;
        		kimed->echochfg.chlenbytes = len;
                    }
                else
                   {
        		kimed->echochfg.chlenbytes += len;
                    }

	/* update cursor position and buf. actual size */
		if (kimed->curadv > 0)
		{
			kimed->eccrpsch = ON ;
			kimed->echocrps += kimed->curadv ;
		}
		if (kimed->echocrps >= kimed->echosize)
			{
				kimed->isbeep = ON;
                                kimed->echocrps -= 1 ;
			        if(*((kimed->echobufs)+(kimed->echocrps)) >= 0x80) 
           			   kimed->echocrps -= 1 ;
			}     
		kimed->echoacsz += len;
	}

/* In case the string being inserted in buffer or
	the buffer being replaced with the string */
	else
	{
		int i, lastps;

	/* insert mode */
		if (kimed->imode.insrepmode == MD_INSERT)
		{
                        int  o_echoacsz ;

                        o_echoacsz = kimed->echoacsz ;
			postcrsz = (kimed->echoacsz)-(kimed->echocrps);
			postbegin = (kimed->echobufs) + (kimed->echocrps) ;

		/* In hangeul Initial and len = 2 */
			if (isHangeulInitial(kimed->hgstate) && len == 2)
				{
				/* Because of support for deletion by eum-so, */
				/*this case may occur during Hangul input */
				   if (isdelkey_fg == ON)
					postcrsz = 0;
				   else
					kimed->echoacsz += 2;
				}
		/* In hangeul Initial and len = 4 */
			else if (isHangeulInitial(kimed->hgstate) && len == 4)
				if (postcrsz == 2)
				{
					postcrsz = 0;
					kimed->echoacsz += 2;
				}
				else
				{
					postcrsz -= 2;
					postbegin += 2;
					kimed->echoacsz += 2;
				}
		/* In hangeul Interim and len = 2 */
			else if (isHangeulInterim(kimed->hgstate) && len == 2)
					postcrsz = 0;
		/* In hangeul Interim and len = 4 */
			else if (isHangeulInterim(kimed->hgstate) && len == 4)
				if (postcrsz == 2)
				{
					postcrsz = 0;
					kimed->echoacsz += 2;
				}
				else
				{
					postcrsz -= 2;
					postbegin += 2;
					kimed->echoacsz += 2;
				}
			else 
				kimed->echoacsz += len;
                        if (kimed->echoacsz > kimed->echosize)
                           {
                              kimed->isbeep = ON ;
                              kimed->echoacsz = o_echoacsz ;
                              return ;
                            }
		}

	/* replace mode */
		else
		{
		/* In buffer, there exists
			only single or double byte characters */

		/* In case double byte in echobufs[echocrps] */
		/* and non-double byte in input string */
			if (len == 0) return ;
			if((*((kimed->echobufs)+(kimed->echocrps)) >= 0x80) &&
				(len != 2))
			{
				/* if str is hangeul and len is 4 */
				if (!isHangeulFinal(kimed->hgstate) && len == 4)
				{
					/* if next character is double byte */
					if (*(kimed->echobufs+kimed->echocrps+2)>=0x80)
					{
						/* replace only, that is, no use of moving */
					}
					/* if next character is single byte and not NULL */
					else if (kimed->echocrps + 2 < kimed->echoacsz)
					{
						/* replace 3 bytes with 4 bytes and move by one byte */
                                                int  o_echoacsz ;

                                                o_echoacsz = kimed->echoacsz ;
						postcrsz=(kimed->echoacsz)-(kimed->echocrps)-3 ;
						postbegin=(kimed->echobufs)+(kimed->echocrps)+3;
						kimed->echoacsz += 1;
                                                   if (kimed->echoacsz > kimed->echosize)
                                                     {
							kimed->isbeep = ON ;
							kimed->echoacsz = o_echoacsz ;
 							return ;
						      }
					}
					else
					{
						kimed->echoacsz += 2;
                                                if (kimed->echoacsz > kimed->echosize)
                                                   {
                                                      kimed->isbeep = ON ;
                                                      kimed->echoacsz -= 2 ;
                                                      return ;
                                                    }
					}
				}
				else
				{
				postcrsz=(kimed->echoacsz)-(kimed->echocrps)-2 ;
				postbegin=(kimed->echobufs)+(kimed->echocrps)+2;
				kimed->echoacsz += (len - 2);
				}
			}

		/* In case single byte in echobufs[echocrps] */
		/* and non-single byte in input string */
			else if ((*((kimed->echobufs)+(kimed->echocrps)) < 0x80) &&
				(len > 1))
			{ 
			postcrsz = (kimed->echoacsz)-(kimed->echocrps) - 1 ;
			postbegin = (kimed->echobufs) + (kimed->echocrps) + 1 ;
			kimed->echoacsz = kimed->echoacsz -1 + len;
			if (kimed->echoacsz > kimed->echosize)
   			   {
				kimed->isbeep = ON ;
				kimed->echoacsz -= (len- 1) ; 
                                return ;
                           }
			}
		}
                
		if (postcrsz > 0)
		{ 
			postfg = ON ;
			poststr = (char *)malloc(postcrsz);
			memcpy(poststr, postbegin, postcrsz);
		}

		memcpy((kimed->echobufs)+(kimed->echocrps), str, len);
	/*	if (kimed->imode.hjmode == ON &&
			(isHangeulCode(str, len)||isNumericJeonja(str, len)) &&
				 kimed->echosvchsp >= 0)	*/
	/********   For the missing interim chars in KS code, they are converted to double byte space to be displayed as space, so, though they are not hangeul code they are treated as if hangeul code ***********/
		if (kimed->imode.hjmode == ON &&
			(kimed->missing_char_flag || isHangeulCode(str, len)||isNumericJeonja(str, len)) &&
				 kimed->echosvchsp >= 0)
		{
			int revps;
			revps = kimed->echocrps;
			lastps = revps + len - 1;

			for (i = revps; i <= lastps; i++)
				kimed->echobufa[i] = KP_HL_REVERSE;

		/* if str is added to echosvch in front ps. */
					
		/* if str is added to echosvch in middle ps. */

		/* if str is added to echosvch in post ps. */
			kimed->echosvchlen = lastps - kimed->echosvchsp + 1;
		}
		else
		{
			lastps = kimed->echocrps + len - 1;
			for (i = kimed->echocrps; i <= lastps; i++)
				kimed->echobufa[i] = KP_HL_UNDER;
      	 
		}
		if(postfg == ON)
		{
		memcpy((kimed->echobufs)+(kimed->echocrps)+len,poststr,postcrsz);
		lastps = kimed->echocrps + len + postcrsz - 1;

		for (i = kimed->echocrps+len; i <= lastps; i++)
			kimed->echobufa[i] = KP_HL_UNDER;
		free((char *)poststr);
		}

	/* update echo buf change flag */

		/* when finialize_hj is called */
		/* underscored string must be redisplayed */

                if (kimed->echochfg.flag == ON)
                    { 
		       if (postfg == ON) 
			      kimed->echochfg.chlenbytes += (kimed->echochfg.chlenbytes + len + postcrsz);
		       else 
			      kimed->echochfg.chlenbytes += (kimed->echochfg.chlenbytes + len);
                    }
                 else
                    {
		       kimed->echochfg.flag = ON;
		       kimed->echochfg.chtoppos = kimed->echocrps;

		       if (postfg == ON) 
			      kimed->echochfg.chlenbytes = kimed->echochfg.chlenbytes + len + postcrsz;
		       else 
			      kimed->echochfg.chlenbytes = kimed->echochfg.chlenbytes + len;
                     }

		/* update cursor position */
		if (kimed->curadv > 0)
		{
			if ((kimed->echocrps + kimed->curadv) >= kimed->echosize)
			{
				kimed->isbeep = ON;
			}
			else
			{
				kimed->eccrpsch = ON ;
				kimed->echocrps += kimed->curadv ;
			}
		}
	}
}



update_auxbuf_to_string(kimed, str, len)
KIMED *kimed;
char *str;
int len;
{
	int currow, curcol, postcrsz;
	char *poststr;

	currow = kimed->auxcrps.rowpos ;
	curcol = kimed->auxcrps.colpos ;
	postcrsz = 0;

	/* code input number to auxbuf  : insert or replace mode */

/* update aux buf. string */

	if (kimed->imode.insrepmode == MD_INSERT) 
		postcrsz = (kimed->auxacsz.itemsize)-curcol;
	if (postcrsz > 0)
	{
		poststr = (char *)malloc(postcrsz) ;
		memcpy(poststr, (kimed->auxbufs[currow])+curcol, postcrsz) ;
	}
	/* common on both insert and replace mode */
        if((kimed->auxacsz.itemsize + len > CODEINPLEN) && (kimed->imode.insrepmode == MD_INSERT))
	   {
		kimed->isbeep = ON ;
		return ;
	   }
	memcpy((kimed->auxbufs[currow]) + curcol, str, len);
	kimed->auxchfg = ON;
	if ((kimed->auxcrps.colpos == kimed->auxacsz.itemsize) || (kimed->imode.insrepmode == MD_INSERT))
		kimed->auxacsz.itemsize += len ;
	if (postcrsz > 0)
	{
		memcpy((kimed->auxbufs[currow])+curcol+len, poststr, postcrsz);
		/* update aux buf. actual size */
		free((char *)poststr);
	}

/* update aux buf. attribute */

	/* no change attribute */

/* update aux buf. cursor position */

	kimed->auxcrps.colpos+=len;
	if (kimed->auxcrps.colpos >= CODEINPLEN)
	   {
		kimed->auxcrps.colpos -= len ;
	   }
	kimed->axcrpsch = ON;
}



/*-----------------------------------------------------------
     Updates echobuf's candidate into the next candidate
     and echobuf's status.
------------------------------------------------------------*/
update_echobuf_to_singcand(kimed)
KIMED	*kimed;
{
	int      len, postsize, i, j ;
	char     *str, *poststr ;

	str = kimed->candbuf[kimed->candcrpos] ;
	len = strlen(kimed->candbuf[kimed->candcrpos]) ; 
	postsize = 0 ;
	if (len != (kimed->echocrps - kimed->echosvchsp + 2))
	{
		postsize = kimed->echoacsz - kimed->echocrps - 2 ;
		if (postsize > 0)
		{
			poststr = (char *)malloc(postsize) ;
			memcpy(poststr, kimed->echobufs + kimed->echocrps + 2, postsize) ;
		} 
		i = len - (kimed->echocrps - kimed->echosvchsp + 2) ;
		if (i>0)
		{
			kimed->echoacsz += i ;
                        if (kimed->echoacsz > kimed->echosize)
                           {
				kimed->isbeep = ON ;
 				kimed->echoacsz -= i ;
				return ;
			   }
			kimed->echosvchlen += i;
			for (j=2 ; j < (i+2) ; j++)
				kimed->echobufa[kimed->echocrps + j] = KP_HL_REVERSE ;
			kimed->echocrps += i ;
			kimed->eccrpsch = ON ;
		}
		else 
		{
			kimed->echoacsz += i ;
                        if (kimed->echoacsz > kimed->echosize)
                           {
				kimed->isbeep = ON ;
 				kimed->echoacsz -= i ;
				return ;
			   }
			kimed->echosvchlen += i;
			for (j=0; j<(-i); j++)
				kimed->echobufa[kimed->echocrps+2+j] = KP_HL_UNDER ;
			kimed->echocrps += i ;
			kimed->eccrpsch = ON ;
			for (j=2; j<(2-i) ; j++)
		   		*(kimed->echobufs + kimed->echocrps+j) = '\x20' ;   
		}
	}
	memcpy(kimed->echobufs+kimed->echosvchsp, str, len) ;
	kimed->echochfg.flag = ON ;
	kimed->echochfg.chtoppos = kimed->echosvchsp ;
	kimed->echochfg.chlenbytes = len ;
	if (postsize>0)
	{
                int lastps ;

		memcpy(kimed->echobufs+kimed->echocrps+2, poststr, postsize) ;
		lastps = kimed->echocrps + postsize - 1;
		for (i = kimed->echocrps; i <= lastps; i++)
			kimed->echobufa[i + 2] = KP_HL_UNDER;
		kimed->echochfg.chlenbytes += postsize ;
		free((char *)poststr) ;
	}
}


/*-----------------------------------------------------------
  Abandon HJ conversion
------------------------------------------------------------*/
update_echobuf_to_savech(kimed)
KIMED		*kimed;
{
	int      postsize, len, i, j, k ;
	char     *poststr ;

	postsize = 0 ;
	for(i = 0 ; i < (kimed->echocrps - kimed->echosvchsp + 2) ; i++)
		kimed->echobufa[kimed->echosvchsp +i] = KP_HL_UNDER ; 

/* check if byte size of selected hangeul is different */
/* from that of hanja candidate */
	len = strlen(kimed->echosvch) ;
	if (len != (kimed->echocrps - kimed->echosvchsp + 2))
	{
		postsize = kimed->echoacsz - kimed->echocrps - 2 ;
		if (postsize > 0)
		{
			poststr = (char *)malloc(postsize) ;
			memcpy(poststr, kimed->echobufs + kimed->echocrps + 2, postsize) ;
		} 
		i = len - (kimed->echocrps - kimed->echosvchsp + 2) ;
/** in the case the length of the key is longer than that of the candidate currently displayed **/
		if (i>0)
		   for (k=0; k<i; k++)
			kimed->echobufa[kimed->echocrps + k + 2] = KP_HL_UNDER ;
		kimed->echoacsz += i ;
                if (kimed->echoacsz > kimed->echosize)
                   {
			kimed->isbeep = ON ;
 			kimed->echoacsz -= i ;
			return ;
		   }
		kimed->echocrps += i ;
		kimed->eccrpsch = ON ;
		if (i < 0)
		{
			for (j=2; j<(2-i) ; j++)
		   		*(kimed->echobufs + kimed->echocrps+j) = '\x20' ;   
		}    	
	}
/* copy saved hangeul character from echosvch to echobufs */
	memcpy(kimed->echobufs+kimed->echosvchsp, kimed->echosvch, len) ;
	kimed->echochfg.flag = ON ;
	kimed->echochfg.chtoppos = kimed->echosvchsp ;
	kimed->echochfg.chlenbytes = len ;

/* advance cursor position */
	kimed->echocrps += 2;
	if (kimed->echocrps >= kimed->echosize)
	{
		kimed->isbeep = ON ;
		kimed->echocrps -= 2 ;
 	}
	kimed->eccrpsch = ON;

	if (postsize>0)
	{
                int lastps ;

		memcpy(kimed->echobufs+kimed->echocrps, poststr, postsize) ;
		lastps = kimed->echocrps + postsize - 1;
		for (i = kimed->echocrps; i <= lastps; i++)
			kimed->echobufa[i] = KP_HL_UNDER;
		kimed->echochfg.chlenbytes += postsize ;
		free((char *)poststr) ;
	}

	kimed->echosvchsp = -1;
	kimed->echosvchlen = 0;
}


/*-----------------------------------------------------------
	Updates auxbufs into the candidates and auxbuf's
	status.
------------------------------------------------------------*/
update_auxbuf_to_cands(kimed)
KIMED		*kimed;
{
	register int	i; 
	int	cpysz, tpos;
	int	auxsize, auxnum;
	unsigned char **aux_str;

	auxsize = kimed->auxsize.itemsize;
	auxnum = kimed->auxsize.itemnum;

	aux_str = kimed->auxbufs;
    	for(i=0;i<auxnum;i++) memset(*(aux_str)++, NULL, auxsize);  
	aux_str = kimed->auxbufa;
    	for(i=0;i<auxnum;i++) memset(*(aux_str)++, NULL, auxsize);   
	kimed->auxacsz.itemsize = 0;
	kimed->auxacsz.itemnum = 0;
	kimed->auxcrps.colpos = -1 ;
	kimed->auxcrps.rowpos = -1 ;
	kimed->auxformat = NULL;

	if (kimed->candgetfg == BACKWARD)
	{
		tpos = kimed->candcrpos - NEXTCANDS_SIZE;
		if (tpos > 0)
		{
			kimed->candcrpos = tpos;
			cpysz = NEXTCANDS_SIZE;
		}
		else
		{
			kimed->candcrpos = FIRST_OF_CANDLIST; 
			cpysz = tpos + NEXTCANDS_SIZE;
		}

	}
	else
	{					
		/* 
		 * Aleady seen candidates, thus goto first candidates.
		 */
		if (kimed->candcrpos >= kimed->candsize)
			kimed->candcrpos = FIRST_OF_CANDLIST;	

		tpos = kimed->candcrpos + NEXTCANDS_SIZE;
		if (kimed->candsize >= tpos)
			cpysz = NEXTCANDS_SIZE;
		else
			cpysz = kimed->candsize - kimed->candcrpos;
	}
	
		/* 
		 * Notes itemnum == NEXTCANDS_SIZE.
		 */
		if (kimed->auxsize.itemnum > cpysz)
		{
			for(i=0; i<cpysz; i++)
			{
			/*
			 * Updates auxbufs.
			 */
			memcpy(kimed->auxbufs[i],
				kimed->candbuf[kimed->candcrpos+i],
				strlen(kimed->candbuf[kimed->candcrpos+i])+1);
			memset(kimed->auxbufa[i], KP_HL_NORMAL, AUXITEMLEN);
		     }
		}
		else
		{
			for (i=0; i < kimed->auxsize.itemnum; i++)
			{
			memcpy(kimed->auxbufs[i], 
				kimed->candbuf[kimed->candcrpos+i], 
				strlen(kimed->candbuf[kimed->candcrpos+i])+1);
			memset(kimed->auxbufa[i], KP_HL_NORMAL, AUXITEMLEN);
		    }
		} 

                kimed->auxacsz.itemnum = i;
                kimed->auxacsz.itemsize = AUXITEMLEN;
		kimed->auxchfg = ON;
}


update_echobuf_to_multicand(kimed, num)
KIMED		*kimed;
int             num ;
{
	int     postsize, i, j, len, tail;
	char    *poststr ;

	postsize = 0 ;

/* change attribute of selected hanja from REVERSE to UNDERSCORE */
	len = strlen(kimed->auxbufs[num]);
	if (len != (kimed->echocrps - kimed->echosvchsp + 2))
	{
		postsize = kimed->echoacsz - kimed->echocrps - 2 ;
		if (postsize > 0)
		{
			poststr = (char *)malloc(postsize) ;
			memcpy(poststr, kimed->echobufs + kimed->echocrps + 2, postsize) ;
		} 
		i = len - (kimed->echocrps - kimed->echosvchsp +2) ;
		kimed->echoacsz += i ;
                if (kimed->echoacsz > kimed->echosize)
                   {
			kimed->isbeep = ON ;
 			kimed->echoacsz -= i ;
			return ;
		   }
		kimed->echosvchlen += i;
		kimed->echocrps += i ;
		kimed->eccrpsch = ON ;
		if (i < 0)
		{
			for (j=2; j<(2-i) ; j++)
		   		*(kimed->echobufs + kimed->echocrps+j) = '\x20' ;   
		}    	
	}

/* update selected hangeul into hanja */
	memcpy(kimed->echobufs+kimed->echosvchsp, kimed->auxbufs[num], len) ;
	for (j=0 ; j<len ; j++)
		kimed->echobufa[kimed->echosvchsp+j] = KP_HL_UNDER ;

/* update echo buffer flag */
	kimed->echochfg.flag = ON ;
	kimed->echochfg.chtoppos = kimed->echosvchsp ;
	kimed->echochfg.chlenbytes = len ;
	kimed->echocrps += 2;
	if (kimed->echocrps >= kimed->echosize)
	{
		kimed->isbeep = ON ;
		kimed->echocrps -= 2 ;
	}
	kimed->eccrpsch = ON;

	if (postsize>0)
	{
		memcpy(kimed->echobufs+kimed->echocrps, poststr, postsize) ;
		for(j = 0 ; j < postsize ; j++) 
			kimed->echobufa[kimed->echocrps +j] = KP_HL_UNDER ; 
		kimed->echochfg.chlenbytes += postsize ;
		free((char *)poststr) ;
	}
	kimed->candcrpos += num;
	if ((kimed->learn == ON) && (kimed->candcrpos != (kimed->candsize-1)))
		put_it_MRU(kimed);
	kimed->echosvchsp = -1;
	kimed->echosvchlen = 0;
}


/*****************************************************************/
/*                cursor specific functions                      */
/*****************************************************************/

/*--------------------------------------------------
*	delete one character on cursor position
*	and unchange cursor position
*--------------------------------------------------*/
delete(kimed)
KIMED *kimed ;
{       
/* delete first row aux buf. string */
	if ((kimed->interstate == ST_CODEINP))
	{
		int len ;
		char *firstp;
		int curpos;
		firstp = kimed->auxbufs[0];
		curpos = kimed->auxcrps.colpos;

	/* when cursor points NULL character */
	/* that is, occurred when cursor position is on the back */
	/* of last byte character or aux buffer actual size is 0 */
		if (( firstp[curpos] == NULL ) || (firstp[curpos] == 0x20 ))
		{
			kimed->isbeep = ON;
			return;
		}

	/* when cursor position is on middle of aux buffer */
	/* code number is only in single byte */

		len = kimed->auxacsz.itemsize-curpos-1;

	/* check if there exists characters which have to be moved left */
	/* if exists, move characters left by length */
		if (len > 0)
			memcpy(firstp+curpos, firstp + curpos + 1, len);

	/* clear meaningless characters on the back */
		/* of last character */
		memcpy(firstp + curpos + len, " ",1);
		memset(firstp + curpos + len+1, NULL,1);

	/* change buffer-change-flag */
		kimed->auxchfg = ON ;

	/* change buffer actual size */
		kimed->auxacsz.itemsize --; 
	}
/* delete echo buf. string */
	else 
	{
		int i, len, curpos, lastpos;
		unsigned char *firstp;

	/* cursor points NULL character */
	/* that is, occurred when cursor position is on the back */
	/* of last byte character or echo buffer actual size is 0 */
		if ( kimed->echoacsz <= kimed->echocrps )
		{
			kimed->isbeep = ON;
			return;
		}

	/* when cursor position is on middle of buffer */

	/* delete double bytes */
		if (*((kimed->echobufs)+(kimed->echocrps)) >= 0x80)
		{
			len = kimed->echoacsz - kimed->echocrps - 2;
			firstp = kimed->echobufs;
			curpos = kimed->echocrps;

		/* change buffer actual size */
			kimed->echoacsz -= 2; 
		/* change echo save char size */
			if (is_there_echosvch(kimed))
				if (is_cursor_in_echosvch(kimed))
				{
					kimed->echosvchlen -= 2;
					if (kimed->echosvchlen == 0)
						kimed->echosvchsp = -1;
				}
		/* check if there exists characters */
			/* which have to be moved left */
			if (len > 0)
		/* move characters left by length */
				memcpy(firstp+curpos, firstp + curpos + 2, len);
		/* clear meaningless characters on the back */
			/* of last character */
			memset(firstp + curpos + len, NULL, 2);

		/* change attributes of deleted char. */
			firstp = kimed->echobufa;
			curpos = kimed->echocrps;
			lastpos = kimed->echocrps + len;

			for (i = curpos; i <= lastpos; i++)
			{
				*(firstp + i) = *(firstp + i + 2);
				*(firstp + i+1) = *(firstp + i + 3);
			}
			*(firstp + lastpos + 2) |= KP_HL_NORMAL;
			*(firstp + lastpos + 3) |= KP_HL_NORMAL;
		/* change buffer-change-flag */
			kimed->echochfg.flag = ON ;
			kimed->echochfg.chtoppos = curpos;
			kimed->echochfg.chlenbytes = len + 2;
		}
	/* delete single byte */
		else
		{
			firstp = kimed->echobufs;
			curpos = kimed->echocrps;
			len = kimed->echoacsz - kimed->echocrps - 1;

		/* Check if there exists characters */
			/* which have to be moved left */
			if (len > 0)
		/* Move characters left by length */
				memcpy(firstp+curpos, firstp + curpos + 1, len);

		/* Clear meaningless characters */
			/* on the back of last character */
			memset(firstp + curpos + len, NULL, 1);

		/* change attributes of deleted char. */
			firstp = kimed->echobufa;
			curpos = kimed->echocrps;
			lastpos = kimed->echocrps + len - 1;

			for (i = curpos; i <= lastpos; i++)
				*(firstp + i) = *(firstp + i + 1);
			*(firstp + lastpos + 1) |= KP_HL_NORMAL;
		/* change buffer-change-flag */
			kimed->echochfg.flag = ON ;
			kimed->echochfg.chtoppos = kimed->echocrps ;
			kimed->echochfg.chlenbytes = len + 1 ;  
		/* change buffer actual size */
			kimed->echoacsz--; 
		}
	}
}


/*-----------------------------------------------------------
 	delete one character cursor pre-position
 	and change cursor position to backward position
 -----------------------------------------------------------*/
backspace(kimed)
KIMED *kimed ;
{       
	int   postlen ;
	char  *poststr ;

/* In case CodeInput state */
/* delete first aux buffer and change cursor position */
	if ((kimed->interstate == ST_CODEINP))
	{
		int num ;
		unsigned char *firstaux;
		AuxCurPos auxcrps;
		firstaux = kimed->auxbufs[0];
		auxcrps = kimed->auxcrps;

		if ( auxcrps.colpos <= 0)
		{
			kimed->isbeep = ON;
			return ;
		}

		num = kimed->auxacsz.itemsize - auxcrps.colpos ;
		if (num > 0)
			memcpy(firstaux+auxcrps.colpos-1, firstaux+auxcrps.colpos, num);
		memcpy(firstaux+kimed->auxacsz.itemsize-1, " ", 1);
		memset(firstaux+kimed->auxacsz.itemsize, NULL, 1);
		kimed->auxacsz.itemsize --; 
		kimed->auxchfg = ON ;
		kimed->auxcrps.colpos -- ;
		kimed->axcrpsch = ON ;
	}

/* Delete echo buffer and change cursor position */
	else
	{
		int i, len, curpos, lastpos;
		unsigned char *firstp;

		if (kimed->echocrps <= 0)
		{
			kimed->isbeep = ON;
			return ;
		}

	/* check if there exists characters which have to be moved left */
		if ((postlen = kimed->echoacsz - kimed->echocrps)>0)
		{
			poststr = malloc(postlen) ;
			memcpy(poststr, kimed->echobufs+kimed->echocrps, postlen) ;
		}  
	/* double byte delete */
		if (*(kimed->echobufs+kimed->echocrps-1) >= 0x80)
		{
			len = kimed->echoacsz - kimed->echocrps;
			kimed->echocrps -= 2 ;
			kimed->echoacsz -= 2 ;
		/* change echo save char size */
			if (is_there_echosvch(kimed))
				if (is_cursor_in_echosvch(kimed))
				{

				/* change attr. of char's beside deleted char. */
					if (kimed->echosvchsp+kimed->echosvchlen > kimed->echocrps+2)
					{
						curpos = kimed->echocrps;
						lastpos = kimed->echosvchsp + kimed->echosvchlen - 1;
						for (i=curpos+2;i<=lastpos;i++)
							kimed->echobufa[i] = KP_HL_NORMAL;
						kimed->echosvchlen=kimed->echocrps-kimed->echosvchsp;
					}
					else
						kimed->echosvchlen -= 2;

					if (kimed->echosvchlen == 0)
					kimed->echosvchsp = -1;
				}
				else
				{
					int start, last;
					start = kimed->echosvchsp;
					last = kimed->echosvchsp+kimed->echosvchlen;

				/* change attr. of char's beside deleted char. */
					for (i=start;i<=last;i++)
						kimed->echobufa[i] = KP_HL_NORMAL;
					kimed->echosvchsp = -1;
					kimed->echosvchlen = 0;
				}

			memset(kimed->echobufs + kimed->echoacsz, NULL, 2);
			kimed->echochfg.chtoppos = kimed->echocrps ;
			kimed->echochfg.chlenbytes = postlen+2;

		/* change attributes of deleted char. */
			firstp = kimed->echobufa;
			curpos = kimed->echocrps;
			lastpos = kimed->echocrps + len;

			for (i = curpos; i <= lastpos; i++)
			{
				*(firstp + i) = *(firstp + i + 2);
				*(firstp + i+1) = *(firstp + i + 3);
			}
			*(firstp + lastpos + 2) |= KP_HL_NORMAL;
			*(firstp + lastpos + 3) |= KP_HL_NORMAL;
		}
	/* single byte delete */
		else
		{
			len = kimed->echoacsz - kimed->echocrps;
			kimed->echocrps -- ;
			kimed->echoacsz -- ;
			memset(kimed->echobufs+kimed->echoacsz, NULL, 1);
			kimed->echochfg.chtoppos = kimed->echocrps ;
			kimed->echochfg.chlenbytes = postlen+1;

		/* change attributes of buffer */
			firstp = kimed->echobufa;
			curpos = kimed->echocrps;
			lastpos = kimed->echocrps + len;

			for (i = curpos; i <= lastpos; i++)
				*(firstp + i) = *(firstp + i + 1);
			*(firstp + lastpos + 1) |= KP_HL_NORMAL;
		}
		if (postlen > 0)
		{
		memcpy(kimed->echobufs+kimed->echocrps, poststr, postlen);
		free(poststr) ;
		}
		kimed->eccrpsch = ON ;
		kimed->echochfg.flag = ON ;
	}
}


space(kimed)
KIMED *kimed;
{
	unsigned char  str[2] ;

/* if exists reversed character, change to underscore */
/* and free echo save character and initialize echo save position */
	if (kimed->echosvchlen > 0)
	{
		int i, lastrevps;
		unsigned char *echobufa;
		lastrevps = kimed->echosvchsp + kimed->echosvchlen;
		echobufa = kimed->echobufa;

		for (i=kimed->echosvchsp;i<=lastrevps;i++)
			echobufa[i] = KP_HL_UNDER;
		
		kimed->echosvchsp = -1;
		kimed->echosvchlen = 0;
	}
        
/* double byte space */
	if ( kimed->imode.sizemode == MD_JEONJA)
	{
                str[0] = 0xa1 ;
		str[1] = 0xa1 ;
		kimed->curadv = 2 ;
		update_echobuf_to_string(kimed, str, 2) ; 
	}
/* single byte space */
	else
	{
		str[0] = 0x20 ;
		kimed->curadv = 1 ;
		update_echobuf_to_string(kimed, str, 1) ;
	}
}


move_cursor_left(kimed)
KIMED *kimed;
{
/* In case of editing first row buff. of aux buff. then go backward */
/* only single byte left */
	if (kimed->interstate == ST_CODEINP) 
	{
	/* check if cursor is on the first character of buffer */
		if (kimed->auxcrps.colpos <=0)
		{
			kimed->isbeep = ON;
		}
	/* otherwise */
		else
		{
			kimed->auxcrps.colpos--;
			kimed->axcrpsch = ON;
		}
	} 
/* In case of editing echo buff. then go backward */
/* First, check whether cursor is moving over buffer actual size or not */
/* Second, check whether current character is double or single byte */
	else
	{ 
		int precrps;
		precrps = kimed->echocrps - 1;
	/* cursor can be moved only within current data */
		if (precrps < 0)
		{
			kimed->isbeep = ON;
			return KP_USED;
		}

	/* double byte left */
		if (kimed->echobufs[precrps] >= 0x80)
		{
		/* cursor can be moved only within current data */
			if (precrps-1 < 0 || kimed->echobufs[precrps-1] < 0x80)
			{
				kimed->isbeep = ON;
			}
			else
			{
				kimed->echocrps-=2;
				kimed->eccrpsch = ON;
			}
		}
	/* single byte left */
		else
		{
			kimed->echocrps--;
			kimed->eccrpsch = ON;
		}
	}
}


move_cursor_right(kimed)
KIMED *kimed;
{
/* In case of editing first row buff. of aux buff. then go backward */
	if (kimed->interstate == ST_CODEINP)
	{
	/* aux buffer bound test */
		if (kimed->auxcrps.colpos + 1 >= kimed->auxsize.itemsize)
		{
			kimed->isbeep = ON;
		}
	/* cursor can be moved only within current data */
		else if (kimed->auxcrps.colpos >= kimed->auxacsz.itemsize)
		{
			kimed->isbeep = ON;
		}
		else
		{
			kimed->auxcrps.colpos++;
			kimed->axcrpsch = ON;
		}
	}
/* In case of editing echo buff. then go forward */
/* First, check whether current character is double or single byte */
/* Second, check whether cursor is moving over buffer actual size or not */
	else
	{
		int crps;
		crps = kimed->echocrps;
	/* double byte right */
		if ( kimed->echobufs[crps] >= 0x80 )
		{
		/* echo buffer bound test */
			if (kimed->echocrps + 2 >= kimed->echosize)
			{
				kimed->isbeep = ON;
			}
		/* cursor can be moved only within current data */
			else if (kimed->echobufs[crps+1] < 0x80 || kimed->echocrps + 2 > kimed->echoacsz)
			{
				kimed->isbeep = ON;
			}
			else
			{
				kimed->echocrps+=2;
				kimed->eccrpsch = ON;
			}
		}
	/* single byte right */
		else
		{
		/* echo buffer bound test */
			if (kimed->echocrps + 1 >= kimed->echosize)
			{
				kimed->isbeep = ON;
			}
		/* cursor can be moved only within current data */
			else if (kimed->echocrps >= kimed->echoacsz)
			{
				kimed->isbeep = ON;
			}
			else
			{
				kimed->echocrps++;
				kimed->eccrpsch = ON;
			}
		}
	}
}


/***********************************************************/
/*                 other functions                         */
/***********************************************************/

int curr_basemode(kimed)
KIMED *kimed;
{
	switch (kimed->imode.basemode) 
	{
		case MD_HAN: 	return ST_HAN;
		case MD_ENG:	return ST_ENG;
		case MD_JAMO:	return ST_JAMO;
	}
}


isHangeulJamo(str, len)
unsigned short int *str;
int len;
{
	return ((len == 2) && (*str >= 0xa4a1) && (*str <= 0xa4d3));
}

isHangeulChar(str, len)
unsigned char *str;
int len;
{
	return (len == 2 & *str >= 0xb0 && *str <= 0xc8 && 
		*(str+1) >= 0xa1 && *(str+1) <= 0xfe);
}


isHangeulCode(str, len)
unsigned short int *str;
int len;
{
	if (len == 2)
		return (isHangeulJamo(str, 2) || isHangeulChar(str, 2));
	if (len == 4)
		return ((isHangeulJamo(str, 2) || isHangeulChar(str, 2)) &&
			(isHangeulJamo(str+1, 2) || isHangeulChar(str+1, 2)));

	return FALSE;
}

int isNumericJeonja(str, len)
unsigned short int *str ;
int  len ;
{
	return ((len == 2) && (*str >= 0xa3b0) && (*str <= 0xa3b9));
} 



int isvalidnum(kimed, str, len)
KIMED *kimed;
char *str;
int len;
{
	if (*str >= '0' && *str <= '9' &&
		(int) (*str - '0') < kimed->auxacsz.itemnum)
			return (int) (*str - '0');
	else if ((*str == 0xa3) && (*(str+1) >= 0xb0) && (*(str+1) <= 0xb9) &&
		(int) (*(str+1) - 0xb0) < kimed->auxacsz.itemnum)
			return (int) (*(str+1) - 0xb0);
	else return -1;
}


int ishexnum(str, len)
unsigned char *str;
int len;
{
	/* if str is hexa number, then return TRUE. o.w. return FALSE */
	return (len == 1 &&((*str >= '0' && *str <= '9') ||
		(*str >= 'a' && *str <= 'f') ||
			(*str >= 'A' && *str <= 'F') ||
				(*str == 'x' || *str == 'X')));

}


isvalidcode(str, len)
unsigned char *str;
int len;
{
	/* if str is ascii code or KS code */

	if (len == 1)
		if (*str & 0x80) return FALSE;
		else return TRUE;

	if (len == 2)
	{
		if (*str >= 0xb0 && *str <= 0xc8)
		{
			if (*(str+1) >= 0xa1 && *(str+1) <= 0xfe)
				return TRUE;
					/* str is hangeul character */
			else return FALSE;
		}
		else if (*str >= 0xca && *str <= 0xfd)
		{
			if (*(str+1) >= 0xa1 && *(str+1) <= 0xfe)
					return TRUE;
						/* str is hanja */
			else return FALSE;
		}
		else
		{
			unsigned short int str2;
			memcpy(&str2, str, 2);

			return ((str2 >= 0xa1a1 && str2 <= 0xa1fe) ||

				(str2 >= 0xa2a1 && str2 <= 0xa2e5) ||

				(str2 >= 0xa3a1 && str2 <= 0xa3fe) ||

				(str2 >= 0xa4a1 && str2 <= 0xa4fe) ||

				(str2 >= 0xa5a1 && str2 <= 0xa5aa) ||
				(str2 >= 0xa5b0 && str2 <= 0xa5b9) ||
				(str2 >= 0xa5c1 && str2 <= 0xa5d8) ||
				(str2 >= 0xa5e1 && str2 <= 0xa5f8) ||

				(str2 >= 0xa6a1 && str2 <= 0xa6e4) ||

				(str2 >= 0xa7a1 && str2 <= 0xa7ef) ||

				(str2 >= 0xa8a1 && str2 <= 0xa8a4) ||
					(str2 == 0xa8a6)	||
				(str2 >= 0xa8a8 && str2 <= 0xa8af) ||
				(str2 >= 0xa8b1 && str2 <= 0xa8fe) ||

				(str2 >= 0xa9a1 && str2 <= 0xa9fe) ||

				(str2 >= 0xaaa1 && str2 <= 0xaaf3) ||

				(str2 >= 0xaba1 && str2 <= 0xabf6) ||

				(str2 >= 0xaca1 && str2 <= 0xacc1) ||
				(str2 >= 0xacd1 && str2 <= 0xacf1)) ; 

		}
	}

	return FALSE;
}


int is_there_echosvch(kimed)
KIMED *kimed;
{
	int crps;
	crps = kimed->echocrps;

	return (kimed->echosvchsp >=0 && kimed->echosvchlen > 0);
}


int is_cursor_in_echosvch(kimed)
KIMED *kimed;
{
	return (kimed->echocrps >= kimed->echosvchsp &&
		kimed->echocrps < kimed->echosvchsp+kimed->echosvchlen);
}


int is_cursor_on_echosv_lstch(kimed)
KIMED *kimed;
{
	return (kimed->echocrps == kimed->echosvchsp+kimed->echosvchlen-2);
}


/* can be called when hjmode is on */
finalize_hg(kimed)
KIMED *kimed ;
{
	int i ;

	kimed->hgstate = HG_ST_FINAL ;
	if (kimed->imode.hjmode == MD_HJON && is_there_echosvch(kimed))
	{
	/* change attributes of reversed characters with UNDERSCORE */
		int lastcrps;
		lastcrps = kimed->echocrps + 1;
		for (i = kimed->echosvchsp; i <= lastcrps; i++)
			*(kimed->echobufa + i) = KP_HL_UNDER ;

		kimed->echochfg.flag = ON ;
		kimed->echochfg.chtoppos = kimed->echosvchsp ;
		kimed->echochfg.chlenbytes = kimed->echocrps - kimed->echosvchsp + 2 ;
		kimed->echosvchsp = -1 ;
		kimed->echosvchlen = 0 ;
	}
	for (i=0; i<=4; i++)
        {
                kimed->hg_status_buf[i].state = HG_ST_FINAL;
                kimed->hg_status_buf[i].cmpshg = NULL;
                kimed->hg_status_buf[i].cmplhg = NULL;
        }
        kimed->hg_status_ps = -1 ;
}


finalize_hj(kimed)
KIMED *kimed ;
{
	int i ;

	kimed->echocrps += 2 ;
        kimed->eccrpsch = ON ;

	for (i = kimed->echosvchsp; i < kimed->echocrps; i++)
        	    kimed->echobufa[i] = KP_HL_UNDER ;

	kimed->echochfg.flag = ON ;
	kimed->echochfg.chtoppos = kimed->echosvchsp ;
  	kimed->echochfg.chlenbytes = kimed->echocrps - kimed->echosvchsp ;
        kimed->echosvchsp = -1 ;
	kimed->echosvchlen = 0;
}

/*----------------------------------------------------- 
	clear echobuf, auxbuf, candbuf. echosvch 
	and their flags for pre-editing agin.
-----------------------------------------------------*/
initialize_buf_n_flag(kimed)
KIMED *kimed;
{
	int i, auxsize, auxnum;
	char **aux_str;

	memset(kimed->echobufs, NULL, kimed->echoacsz);
	memset(kimed->echobufa, NULL, kimed->echoacsz);
	kimed->echoacsz = 0;
	kimed->echocrps = 0;
	kimed->echochfg.flag = ON;
	kimed->echochfg.chtoppos = 0;
	kimed->echochfg.chlenbytes = kimed->echoacsz;
	kimed->eccrpsch = ON;

	kimed->echosvchlen = 0;
	kimed->echosvchsp = -1;

        if (kimed->auxuse != AUXBUF_NOTUSED)
	  {
	auxsize = kimed->auxacsz.itemsize;
	auxnum = kimed->auxacsz.itemnum;

	aux_str = kimed->auxbufs;
   	for(i=0;i<auxnum;i++) memset(*(aux_str)++, NULL, auxsize); 
	aux_str = kimed->auxbufa;
   	for(i=0;i<auxnum;i++) memset(*(aux_str)++, NULL, auxsize);  
	kimed->auxacsz.itemsize = 0;
	kimed->auxacsz.itemnum = 0;
	kimed->auxcrps.colpos = -1 ;
	kimed->auxcrps.rowpos = -1 ;
	kimed->auxformat = NULL;
	kimed->auxchfg = ON;
	kimed->axcrpsch = ON;
           }
	kimed->candgetfg = FORWARD;
	kimed->candsize = 0;
	kimed->candcrpos = 0;
}


/*-----------------------------------------------------------------
	Convert Hexa code string to corresponding integer value
------------------------------------------------------------------*/

int hexcodetoint(intstr, str, len)
unsigned char *intstr;
unsigned char *str;
int *len;
{
	int	hexdigit, i, errfg, orglen;
	unsigned int cval;
	unsigned char rval;

	i=0;
	orglen = *len;
	if (str[i] == '0' && (str[i+1] == 'x' || str[i+1] == 'X'))
	{
		i += 2;
		(*len) -= 2;
	}

	if (*len != 2 && *len != 4)
	{
		*len = 0;
		intstr[0] = NULL;
		return ;
	}

	cval = 0;
	errfg = OFF;
	for(;errfg == OFF && i < orglen; ++i)
	{
		if (str[i] >= '0' && str[i] <= '9')
			hexdigit = str[i] - '0';
		else if (str[i] >= 'a' && str[i] <= 'f')
			hexdigit = str[i] - 'a' + 10;
		else if (str[i] >= 'A' && str[i] <= 'F')
			hexdigit = str[i] - 'A' + 10;
		else
			errfg = ON;
		if (errfg == OFF)
			cval = 16*cval + hexdigit;
	}

	*len = *len / 2;
	for (i=*len-1;i>=0;i--)
	{
		rval = (unsigned char)cval;
		intstr[i]=rval;
		cval = cval >> 8;
	}
	return ;
}


prevhestate(kimed)
KIMED *kimed;
{
	if (kimed->prevhemode == MD_ENG)
		return MD_ENG;
	else if (kimed->prevhemode == MD_HAN)
		return MD_HAN;
}


is_over_bound(kimed, str, len)
KIMED *kimed;
unsigned char *str;
int len;
{
	switch (kimed->imode.insrepmode)
	{
	case MD_INSERT :
		 if (kimed->echosize - kimed->echoacsz < len)
                      {   
			if (isHangeulInitial(kimed->hgstate))
                             {
				if (len == 2)
					return TRUE;
				else
					return (kimed->echosize - kimed->echoacsz < len-2);
                             }
			else if (isHangeulInterim(kimed->hgstate))
                               {
				if (len == 2)
					return FALSE;
				else
					return (kimed->echosize - kimed->echoacsz < len-2);
                               }
			else
				return TRUE;
                     }
		else
			return FALSE;
		break;
	case MD_REPLACE :
		      {
			int curchsize, rembufsize;

			rembufsize = kimed->echosize - kimed->echoacsz;

			if (kimed->echocrps == kimed->echoacsz)
				return (rembufsize < len);

			if (kimed->echobufs[kimed->echocrps] < 0x80)
				curchsize = 1;
			else
				curchsize = 2;

			if (!isHangeulFinal(kimed->hgstate) && len == 4)
                             {
				if (kimed->echocrps == kimed->echoacsz - 2)
				{
					return ( (curchsize + rembufsize) < len );
				}
				else
				{
					int nextchsize;

					if (kimed->echobufs[kimed->echocrps+2] < 0x80)
						nextchsize = 1;
					else
						nextchsize = 2;
					return ( (curchsize + nextchsize + rembufsize) < len );
				}
                             }
			else
				return ( (curchsize + rembufsize) < len );
		      }
	}
}

change_attr_to_under(kimed)
KIMED *kimed;
{

	if (kimed->echosvchlen > 0)
	{
		int i, echosvchep;

		echosvchep = kimed->echosvchsp + kimed->echosvchlen - 1;
		for (i = kimed->echosvchsp; i <= echosvchep; i++)
			kimed->echobufa[i] = KP_HL_UNDER;
		kimed->echochfg.flag = ON;
		kimed->echochfg.chtoppos = kimed->echosvchsp;
		kimed->echochfg.chlenbytes = kimed->echosvchlen;
	}
		kimed->echosvchsp = -1;
		kimed->echosvchlen = 0;
}  


/*
 *	kedLookup
 */
void	kedLookup(KIMED *kimed, IMKeymap *immap,
		unsigned int keysym, unsigned int state, IMBuffer *imb)
{
	_IMMapKeysym(immap, &keysym, &state);
	_IMSimpleMapping(immap, keysym, state, imb);
	return;
}
