static char sccsid[] = "@(#)54	1.12  src/bos/usr/bin/bdiff/bdiff.c, cmdfiles, bos411, 9428A410j 11/16/93 08:48:46";
/*
 * COMPONENT_NAME: (CMDFILES) commands that manipulate files
 *
 * FUNCTIONS: bdiff
 *
 * ORIGINS: 3, 18, 27
 *
 * This module contains IBM CONFIDENTIAL code. -- (IBM
 * Confidential Restricted when combined with the aggregated
 * modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp. 1985, 1993
 * All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 */
/*
 * @OSF_COPYRIGHT@
 *
static char rcsid[] = "RCSfile: bdiff.c,v  Revision: 1.4  (OSF) Date: 90/10/07 16:14:35 ";
 */

#include	<stdio.h>
#include	<fatal.h>
#include	<errno.h>
#include	<stdarg.h>
#include	<locale.h>
#include	<macros.h>
#include	<sys/types.h>
#include	<sys/limits.h>
#include	<stdlib.h>
#include	"bdiff_msg.h"

#define TMP_FILE_MODE 0644

#define MSGSTR(num, str) catgets(catd, MS_BDIFF, num, str)
nl_catd catd;


char *satoi();
int mb_cur_max; /* max number of bytes per character in current locale */
int mbcodeset;  /* 0=current locale SBCS, 1=current locale MBCS */

FILE *fdfopen();

struct stat Statbuf;
char Error[128];      /* error msg string */
int	Fflags;

int seglim = 3500;	/* Default set to upper limit on size of files */
                        /* bdiff can handle. */

char diff[]  =  "diff";
char tempskel[] = "/tmp/bdXXXXXX";  /* used to generate temp file names */
char tempfile[PATH_MAX];
char otmp[PATH_MAX], ntmp[PATH_MAX];
int linenum;

/*
 * NAME: bdiff file1 file2 [n] [-s]
 *                                                                    
 * FUNCTION: Uses diff to find differences in very large files
 *           n   number of lines per segment
 *           -s  suppresses error messages
 *       This program segments two files into pieces of <= seglim lines
 *	 (which is passed as a third argument or defaulted to some number)
 *	 and then executes diff upon the pieces. The output of
 *	 'diff' is then processed to make it look as if 'diff' had
 *	 processed the files whole. The reason for all this is that seglim
 *	 is a reasonable upper limit on the size of files that diff can
 *	 process.
 *	 NOTE -- by segmenting the files in this manner, it cannot be
 *	 guaranteed that the 'diffing' of the segments will generate
 *	 a minimal set of differences.
 *	 This process is most definitely not equivalent to 'diffing'
 *	 the files whole, assuming 'diff' could handle such large files.
 *
 *	 'diff' is executed by a child process, generated by forking,
 *	 and communicates with this program through pipes.
 */
main(argc,argv)
int argc;
char *argv[];
{
	int i, otcnt, ntcnt;
	int pfd[2];
	int status;
	char *olp, *nlp, *dp;
	char oline[BUFSIZ], nline[BUFSIZ], diffline[BUFSIZ];
	FILE *poldfile, *pnewfile, *maket();
	FILE *poldtemp, *pnewtemp, *pipeinp;

	(void ) setlocale(LC_ALL,"");
	catd = catopen(MF_BDIFF, NL_CAT_LOCALE);
	mb_cur_max = MB_CUR_MAX;
	mbcodeset = (mb_cur_max > 1);

	/*
	Set flags for 'fatal' so that it will clean up,
	produce a message, and terminate.
	*/
	Fflags = FTLMSG | FTLCLN | FTLEXIT;

	if (argc < 3 || argc > 5)
		fatal(MSGSTR(ARGCNT2,
			     "Usage: bdiff File1 File2 [Number] [-s]\n"));

	if (equal(argv[1],"-") && equal(argv[2],"-"))
		fatal(MSGSTR(BOTHSTDIN2, 
			    "bdiff: Specify only one file as standard input.\n"));

	if (argc > 3) {
		if (argv[3][0] == '-' && argv[3][1] == 's')
			Fflags &= ~FTLMSG;
		else {
		   if ( (*argv[3] <= '0') ||((seglim = patoi(argv[3])) == -1) )
				fatal(MSGSTR(NONNUMLMT2,
			"bdiff: Specify file segment size as a line number.\n"));
			if (argc == 5 && argv[4][0] == '-' &&
					argv[4][1] == 's')
				Fflags &= ~FTLMSG;
		}
	}
	if (equal(argv[1],"-"))
		poldfile = stdin;
	else
		poldfile = xfopen(argv[1],0);
	if (equal(argv[2],"-"))
		pnewfile = stdin;
	else
		pnewfile = xfopen(argv[2],0);

	linenum = 0;

	/*
	The following while-loop will prevent any lines
	common to the beginning of both files from being
	sent to 'diff'. Since the running time of 'diff' is
	non-linear, this will help improve performance.
	If, during this process, both files reach EOF, then
	the files are equal and the program will terminate.
	If either file reaches EOF before the other, the
	program will generate the appropriate 'diff' output
	itself, since this can be easily determined and will
	avoid executing 'diff' completely.
	*/
	while (1) {
		olp = fgets(oline,BUFSIZ,poldfile);
		nlp = fgets(nline,BUFSIZ,pnewfile);

		if (!olp && !nlp)	/* files are equal */
			exit(0);

		if (!olp) {
			/*
			The entire old file is a prefix of the
			new file. Generate the appropriate "append"
			'diff'-like output, which is of the form:
					nan,n
			where 'n' represents a line-number.
			*/
			addgen(nline,pnewfile);
		}

		if (!nlp) {
			/*
			The entire new file is a prefix of the
			old file. Generate the appropriate "delete"
			'diff'-like output, which is of the form:
					n,ndn
			where 'n' represents a line-number.
			*/
			delgen(oline,poldfile);
		}

		if (equal(olp,nlp))
			linenum++;
		else
			break;
	}

	/*
	Here, first 'linenum' lines are equal.
	The following while-loop segments both files into
	seglim segments, forks and executes 'diff' on the
	segments, and processes the resulting output of
	'diff', which is read from a pipe.
	*/
	while (1) {
		/*
		If both files are at EOF, everything is done.
		*/
		if (!olp && !nlp)	/* finished */
			exit(0);

		if (!olp) {
			/*
			Generate appropriate "append"
			output without executing 'diff'.
			*/
			addgen(nline,pnewfile);
		}

		if (!nlp) {
			/*
			Generate appropriate "delete"
			output without executing 'diff'.
			*/
			delgen(oline,poldfile);
		}

		/* Create temporary files to hold segments from old and new files.
		 * (Both must be open simultaneously to get different file descriptors.)
		 */
		poldtemp = maket(otmp);
		pnewtemp = maket(ntmp);

		/* Write a segment from the old file to its temporary. */
		otcnt = 0;
		while(olp && otcnt < seglim) {
			fputs(oline,poldtemp);
			if (ferror(poldtemp) != 0) {
				Fflags |= FTLMSG;
				fatal(MSGSTR(TMPWRTERR,
						"bdiff: error writing temporary file.\n"));
			}
			olp = fgets(oline,BUFSIZ,poldfile);
			otcnt++;
		}
		fclose(poldtemp);

		/* Write a segment from the new file to its temporary. */
		ntcnt = 0;
		while(nlp && ntcnt < seglim) {
			fputs(nline,pnewtemp);
			if (ferror(pnewtemp) != 0) {
				Fflags |= FTLMSG;
				fatal(MSGSTR(TMPWRTERR,
						"bdiff: error writing temporary file.\n"));
			}
			nlp = fgets(nline,BUFSIZ,pnewfile);
			ntcnt++;
		}
		fclose(pnewtemp);

		/*
		Create pipes and fork.
		*/
		xpipe(pfd);
		if ((i = fork()) < 0) {
			close(pfd[0]);
			close(pfd[1]);
			fatal(MSGSTR(CANTFORK2,
			       "bdiff: Cannot create another process now.\n"));
		}
		else if (i == 0) {	/* child process */
			close(pfd[0]);
			close(1);
			dup(pfd[1]);
			close(pfd[1]);

			/*
			Execute 'diff' on the segment files.
			*/
			execlp(diff,diff,otmp,ntmp,0);
			close(1);
			fatal(MSGSTR(CANTEXEC2,
                               "bdiff: Cannot run diff.\n"));
		}
		else {			/* parent process */
			close(pfd[1]);
			pipeinp = fdfopen(pfd[0],0);

			/*
			Process 'diff' output.
			*/
			while ((dp = fgets(diffline,BUFSIZ,pipeinp))) 
			{
				if (numeric(*dp))
					fixnum(diffline);
				else
					printf("%s",diffline);
			}

			fclose(pipeinp);

			/*
			EOF on pipe.
			*/
			wait(&status);
 			if (status&~0x100) {
				fatal(MSGSTR(DIFFFAIL2,
                                            "bdiff: The diff command failed.\n"));
			}
		}
		linenum += seglim;

		/*
		Remove temporary files.
		*/
		unlink(otmp);
		unlink(ntmp);
	}
}


/*
 * NAME: saverest
 *                                                                    
 * FUNCTION: 	Routine to save remainder of a file.
 */  
saverest(line,iptr)
char *line;
FILE *iptr;
{
	char *lp;
	FILE *temptr, *maket();

	temptr = maket(tempfile);

	lp = line;

	while (lp) {
		fputs(line,temptr);
		linenum++;
		lp = fgets(line,BUFSIZ,iptr);
	}
	fclose(temptr);
}


/*
 * NAME: putsave
 *                                                                    
 * FUNCTION: Routine to write out data saved by 
 *           'saverest' routine and to remove the file.
 */  
putsave(line,type)
char *line;
char type;
{
	FILE *temptr;

	temptr = xfopen(tempfile,0);

	while (fgets(line,BUFSIZ,temptr))
		printf("%c %s",type,line);

	fclose(temptr);

	xunlink(tempfile);
}


/*
 * NAME: fixnum
 *                                                                    
 * FUNCTION:  prints the commands from diff
 */  
fixnum(lp)
char *lp;
{
	int num;

	while (*lp) {
		switch (*lp) {

		case 'a':
		case 'c':
		case 'd':
		case ',':
		case '\n':
			printf("%c",*lp);
			lp++;
			break;

		default:
			lp = satoi(lp,&num);
			num += linenum;
			printf("%d",num);
		}
	}
}


/*
 * NAME: addgen
 *                                                                    
 * FUNCTION: generate the append diff like output 
 */  
addgen(lp,fp)
char *lp;
FILE *fp;
{
	printf("%da%d,",linenum,linenum+1);

	/*
	Save lines of new file.
	*/
	saverest(lp,fp);

	printf("%d\n",linenum);

	/*
	Output saved lines, as 'diff' would.
	*/
	putsave(lp,'>');

	exit(0);
}


/*
 * NAME: delgen
 *                                                                    
 * FUNCTION: generate delete diff like ouput
 */  
delgen(lp,fp)
char *lp;
FILE *fp;
{
	int savenum;

	printf("%d,",linenum+1);
	savenum = linenum;

	/*
	Save lines of old file.
	*/
	saverest(lp,fp);

	printf("%dd%d\n",linenum,savenum);

	/*
	Output saved lines, as 'diff' would.
	*/
	putsave(lp,'<');

	exit(0);
}


/*
 * NAME: clean_up
 *                                                                    
 * FUNCTION: unlink tmp files
 */  
clean_up()
{
	unlink(tempfile);
	unlink(otmp);
	unlink(ntmp);
}


/*
 * NAME: maket
 *                                                                    
 * FUNCTION: create temp file
 */  
FILE *
maket(file)
char *file;
{
	FILE *iop;
	char *mktemp();
	strcpy(file,tempskel);
	iop = xfcreat(mktemp(file),TMP_FILE_MODE);

	return(iop);
}


	/*
	* NAME: fatal
	*                                                                    
	* FUNCTION: General purpose error handler.
	*		If all fatal globals have their default values, fatal simply
	*		returns -1.
	* EXIT:	1. If FTLMSG was set then   msg  has been written to standard error.
	*	2. If FTLCLN was set then  clean_up(0)  has been called.
	*	3. If FTLEXIT was set then  exit(1)  has been called
	*			      else  return value = (int)-1 .
	*/
int	Fvalue = -1;

fatal(msg)
char *msg;
{
	if (Fflags & FTLMSG) {
		fprintf(stderr,msg);
	}
	if (Fflags & FTLCLN)
		clean_up(0);
	if (Fflags & FTLEXIT)
		exit(1);
	return(Fvalue);
}


	/*
	* NAME: patoi
	*                                                                    
 	* FUNCTION: 	Function to convert ascii string to integer.  Converts
	*		positive numbers only.  Returns -1 if non-numeric
	*		character encountered.
	* ENTRY:	1. s points to a string of file code characters.
	*		    In bdiff this is must be a [Number] command line
	*		    option specifiying file segment length in lines.
	*		    Only ascii digit characters are supported on the
	*		    command line.
	* EXIT:		1. Return value = IF (string s contains only decimal digit
	*		    characters) THEN (integer value of string s interpreted
	*		    as an unsigned integer) ELSE ( -1 ).
	*/
patoi(s)
register char *s;
{
	register int i;
	
	i = 0;
	while(s != NULL && (unsigned char)*s >= '0' && (unsigned char)*s <= '9') 
		i = 10 * i + (int)((unsigned char)*s++ - '0');

	if(*s != '\0') return(-1);
	return(i);
}


	/*
	* NAME: xpipe
	*                                                                    
	* FUNCTION: 	Interface to pipe(II) which handles all error 
	*		conditions. Returns 0 on success, fatal() on failure.
	*/
xpipe(t)
int *t;
{
	static char p[]="pipe";

	if (pipe(t) == 0)
		return(0);
	return(fatal(MSGSTR(PIPEFAIL,"bdiff: pipe() failed\n")));
}


	/*
	* NAME: xunlink
	*                                                                    
	* FUNCTION: 	Interface to unlink(II) which handles all error 
	*		conditions. Returns 0 on success, fatal() on failure.
	*/
xunlink(f)
char *f;
{
	if (unlink(f))
		return(fatal(MSGSTR(UNLNKERR,"bdiff: cannot unlink temporary file\n")));
	return(0);
}


	/*
	* NAME: satoi
	*                                                                    
	* FUNCTION: 	Routine to convert string to integer. 
	* ENTRY:	1. p points to a string of file code characters.
	*		    In bdiff this is a line number written by  diff  in
	*		    a change command.
	* EXIT:		1. *ip = integer value of the longest consecutive
	*		    sequence of decimal digit characters starting at p'
	*		    (possibly none) interpreted as an unsigned integer.
	*		2. Return value = pointer to the first character in the
	*		    string that is not a decimal digit character.
	*/
char *satoi(p,ip)
register char *p;
int *ip;
{
	register int sum;
	wchar_t wc;
	wchar_t *pwc = &wc;
	int chrlen;

	sum = 0;
	if (mbcodeset == 0) {	/* Convert single-byte characters */
		while(p != NULL && (unsigned char)*p >= '0' && (unsigned char)*p <= '9') 
			sum = 10 * sum + (int)((unsigned char)*p++ - '0');

	} else {		/* Convert possibly multibyte characters */
		while (p!=NULL && (chrlen=mbtowc(pwc,p,mb_cur_max))>0
			&& wc>=(wchar_t)L'0' && wc <= (wchar_t)L'9' ) {
			sum = 10 * sum + (int)(wc-(wchar_t)L'0');
			p += chrlen;
		}
	}
	*ip = sum;
	return(p);
}

	/*
	* NAME: fdfopen
	*                                                                    
	* FUNCTION: Return FILE * for file descriptor argument
	*		Returns file pointer on success or
	*		NULL on failure (fd not open or no file structures available).
	*		First arg is file descriptor, second is read/write mode (0/1).
	*/
FILE *
fdfopen(fd, mode)
register int fd, mode;
{
	register FILE *iop;

	if (fstat(fd, &Statbuf) < 0)
		return(NULL);
	for (iop = _iob; iop->_flag&(_IOREAD|_IOWRT); iop++)
		if (iop >= &_iob[_NFILE-1])
			return(NULL);
	iop->_flag &= ~(_IOREAD|_IOWRT);
	iop->_file = fd;
	if (mode)
		iop->_flag |= _IOWRT;
	else
		iop->_flag |= _IOREAD;
	return(iop);
}


	/*
	* NAME: xcreat
	*                                                                    
 	* FUNCTION: 	"Sensible" creat: write permission in directory is 
	*		required in all cases, and created file is guaranteed to have 
	*		specified mode and be owned by effective user.
	*		(It does this by first unlinking the file to be created.)
	*		Returns file descriptor on success, fatal() on failure.
	* NOTE: xcreat() is invoked by macro xfcreat() . This version of xcreat()
	*       is specialized for  bdiff  messages.
	*/
xcreat(name,mode)
char *name;
int mode;
{
	register int fd;
	unlink(name);
	if ((fd = creat(name,mode)) >= 0)
		return(fd);
	return(fatal(MSGSTR(TMPCREERR,"bdiff: cannot create temporary file\n")));
}


	/*
	* FUNCTION:	xopen
	*
	* FUNCTION: 	Interface to open which differentiates among the 
	*		various open errors.
	*		Returns file descriptor on success, fatal() on failure.
	* NOTE: xopen() is invoked by macro xfopen() . This version of xopen()
	*       is specialized for  bdiff  messages.
	*/
xopen(name,mode)
char name[];
int mode;
{
	register int fd;

	if ((fd = open(name,mode)) < 0) {
		sprintf(Error,MSGSTR(CANTOPEN,"bdiff: cannot open file %s\n"),name);
		fd = fatal(Error);
	}
	return(fd);
}
