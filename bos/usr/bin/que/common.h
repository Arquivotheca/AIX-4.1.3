/* @(#)22	1.39  src/bos/usr/bin/que/common.h, cmdque, bos41B, 9504A 12/19/94 15:14:38 */
/*
 * COMPONENT_NAME: (CMDQUE) spooling commands
 *
 * FUNCTIONS: 
 *
 * ORIGINS: 9, 27
 *
 * This module contains IBM CONFIDENTIAL code. -- (IBM
 * Confidential Restricted when combined with the aggregated
 * modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp. 1985, 1994
 * All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 */

#include <sys/param.h>
#include <stdlib.h>
#include <sys/limits.h>
#include <IN/stfile.h>
#include <IN/q.h>
#include "jobnum.h"
#include "all.h"

#define TRUNC_NAME( N, S ) \
		{ if ( N && strlen( (char *)N ) > S ) *((char *)N + (int)S) = '\0' ; }
#define MAKENEW (-1)
#define SHORTTIME 1*60          /* don't wait longer than this */
				/* need limit in case have race condition */
#define BSD_DEFAULT_QUEUE       "lp"                    /* default queue sent by BSD 4.3 print request */
#define BOPTMARK	"$#@!"  /* string which backend arguments are prefaced
				   with in the jdf to distinguish them from 
				   files.
				*/
#define BOPTLEN		(strlen(BOPTMARK))	/* length of the above */
extern int errno;
#define OWAIT   45      /* wait this many seconds if device open fails */
			/* before trying again */
/* AIX security enhancement				*/
/* changed status file protection form 644 to 660	*/
#define SF_PROT 0660    /* protection of status file */

/* AIX security enhancement 				  */
/* removed struct con_groups. penv list includes groups */

/*
 * warning: code assumes STATDIR and QUEDIR have the same parent
 * and that last component of STATDIR is "stat".  to avoid
 * clashes with device pidfile names, don't put a '.' in QDPID
 */
#define S_DEFAULT_STATFILTER	"/usr/lib/lpd/aixshort"
#define L_DEFAULT_STATFILTER	"/usr/lib/lpd/aixlong"
#define ENQ			"/usr/bin/enq"
#define PR			"/usr/bin/pr"
#define MAIL			"/usr/sbin/sendmail"
#define LPD_LOCKNAME		"/etc/locks/lpd"        /* lock file for lpd    */
#define LPD_DIRECTORY		"/var/spool/lpd"        /* spool dir for lpd    */
#define LPD_HOSTS		"/etc/hosts.lpd"        /* permissions file for lpd  */
#define EQUIV_HOSTS		"/etc/hosts.equiv"      /* rcmd.c permissions file */
#define STATDIR			"/var/spool/lpd/stat"
#define QUEDIR			"/var/spool/lpd/qdir"
#define QDPID			"/var/spool/lpd/stat/pid"
#define CONFIG			"/etc/qconfig"
#define BCONFIG			"/etc/qconfig.bin"
#define DIGEST			"/usr/lib/lpd/digest"
#define QSTATUS			"/usr/lib/lpd/qstatus"
#define TMPCOPY			"/var/spool/qdaemon"    /* where to copy user files */
#define TMP			"/tmp"			/* where to copy user files */
#define TMPDIR			"/etc"		/* where to put temporary qconfig & qconfig.bin */
#ifdef DEBUG
#define CONSOLE			"/dev/tty"
#else
#define CONSOLE			"/dev/console"
#endif
#define QDPROG			"/usr/sbin/qdaemon"

/*
 * some length restrictions
 */
#define QUE_PATH_MAX 128	/* buffer size for storing our paths */
#define LOGNAME 9		/* user's login name */
#define LOGDIR PATH_MAX		/* user's login directory */
#define DEVFILE QUE_PATH_MAX	/* name of device */
#define ACCTF QUE_PATH_MAX	/* name of accounting file */
#define BENAME 200		/* name of backend, with args */
#define HOSTNAME HOST_SZ	/* secondary host name        */
#define OSSIZE QUE_PATH_MAX	/* buffer size for status filters */
#define MAXMSG   30     /* maximum lines of messages  */
#define USERNAMELEN 41	/* 32 for hostname + 1 for @ + 8 for username*/
			/* used by firstx and first17cmp*/
#define SYSBLKSIZ 1024  /* system block size */
/* job desc. filename length, for e.g, 01root@hostname.queue1 */
#define RMLOGNAME	32	/* RFC1179 documents C and H can be 31
				characters each.  So we use 31 for username+
				null byte */
#define JDF_NAM_LEN 2+RMLOGNAME+1+MAXHOSTNAMELEN+QNAME+1    

/*
 * HICOUNT and LOCOUNT are the high and low water marks that will be used
 * for jobs that qdaemon will keep in memory, per queue, at any one point.
 */
#define HICOUNT 500
#define LOCOUNT 300

/* miscellaneous constants */
#define QELINE  PATH_MAX     /* max length of line in q entry file */
#define ANYDEV "#@%!:"		/* use next available device */
#define PID_FMT "%d"
#define MSGSIZE MAXMSG * QELINE
#define ANYPID	(-1)

/* signal sent from qu to qdaemon (must not reset) */
#define SIGQUEUE SIGTRAP

/* MAXFEED is biggest number that can fit into d_feed, minus 1 */
#define MAXFEED 14
#define NOFEED  0			/* no feed means no pages! */	
/* #define NOFEED (MAXFEED + 1) */   /* d_feed.  max value that fits! */

/* max (simple) file name length, + 1 */
#define E_NAME PATH_MAX
#define NEW (-1)
#define NOTNEW (-2)
#define PRINTED (-3) 

/* D45466 */
#define ENQ_QUE 1090977820L /* unique key generated by ftok("/bin/enq",'A') */
#define PERMS   0660
#define NORMAL  1L      /* normal jdf */
#define SPECIAL 2L      /* special request */
#define MESS_COUNT 5    /* Read at the most so many messages in one shot */

/* values for various fields */
/* NEVER, ALWAYS, GROUP, and USEDEF (header, trailer) in <backend.h> */
#define FCFS 0          /* q_disc */
#define DEFAULT (ALWAYS + NEVER + 1) /* guarenty mutual exclusion dcr1653*/
#define SJN 1
#define WRITE 0         /* d_access */
#define BOTH 1

/* JDF delete flag values */
#define NO_FLAG		0
#define RM_FLAG		1
#define CP_FLAG		2

/*
 * Linked list of user defined arguments. These are the values sent
 * with the -o option of enq.
 */
struct uflags
{
	char		*flag;		/* flag for backend */
	struct uflags	*next;		/* pointer to next flag */
};

struct str_list
{
	char *s_name;
	struct str_list *s_next;
	int s_del;	/*  delete after backend dies */
};

/*
 * there are three types of objects here:
 *      1) queue
 *              A list of jobs (q_entlist) and a list of devices (q_devlist)
 *              to run them on.  Hooked together themselves into a list.
 */

struct q 
{
	struct q *q_next;	/* rest of queues */
	struct d *q_devlist;	/* devices on this queue */
	struct e *q_entlist;	/* jobs on this queue */
	char q_name[QNAME +1];	/* name of the queue*/
	char q_rname[QNAME +1];	/* name of queue remotely*/
	char q_hostname[HOST_SZ];	/* remote queue's hostname*/
	char q_lros[OSSIZE];	/* long status filter */
	char q_sros[OSSIZE];	/* name of program in /usr/lpd to exec to filter
				   qstatus output from remote machine*/
	char q_acctf[ACCTF];	/* account file, if not 
				   "".  "" means no accounting.*/
	int q_disc ;	/* FCFS or SJN*/
	boolean q_up ;		/* TRUE or FALSE*/
	int q_devcount ;	/* count of devices on this queue.*/
	int q_entcount ;	/* count of entries on this queue */
	boolean q_top ;		/* flag used when HICOUNT is reached */
};


/*
 *      2) device
 *              an element of the device list (d_next).  kept in order
 *              that they appear in qconfig.  devices running a job have
 *              non-zero d_pid; otherwise the device is idle.  if
 *              the device is running a request (as opposed to trailers
 *              and feed), that request is d_e.  d_user is name of last
 *              person to run a job on this device; it is used to set
 *              "endgroup" correctly.  once trailers are printed for a
 *              user, d_user is set to "" to prevent them from being printed
 *              again later.
 */
struct d 
{
	struct d *d_next;	/* Rest of devices on this queue */
	struct q *d_q;		/* queue this device is attached to  */
	struct e *d_e;		/* currently running job. only used by qdaemon*/
	char d_name[DNAME+1];	/* device stanza name in /etc/qconfig */
	char *d_backend;	/* program to run, with flags */
	int d_pid;		/* backend pid */
	char d_user[LOGNAME];	/* user using this device */
	char d_file[DEVFILE];	/* special file associated with this device */
	int d_access ;		/* WRITE or BOTH */
	unsigned d_align ;	/* align pages (see tech ref) */
	boolean d_up ;		/* TRUE or FALSE */
	unsigned d_head ;	/* ALWAYS, NEVER, or GROUP */
	unsigned d_trail ;	/* ALWAYS, NEVER, or GROUP */
	unsigned d_feed ;	/* number, or NOFEED */
};


/*
 *      3) entry
 *              record of a job request.  kept on a list (e_next),
 *              in order of priority, so next job is at top of list.
 *              entry being run has e_device pointing to the device
 *              running it; otherwise NULL.  e_name is the request
 *              file itself (in QUEDIR).  there are two numbers that
 *              determine priority.  e_pri1 is the "-pr=" or "-ap="
 *              argument, it is most important.  e_pri2 is the time
 *              submitted (same as e_time) if q_disc is FCFS, and the
 *              size in bytes if q_disc is SJN.  since the vax has no
 *              decent facility for notifying users of an event (like
 *              "remind"), there we keep the user's tty name (e_tty)
 *              so can tell him good or bad news.
 */
struct e 
{
	struct e *e_next;		/* next job on this queue 	*/
	char e_name[E_NAME];		/* jdf name 			*/
	int  e_jobnum;			/* jobnum. NEW means unassigned	*/
	int e_pri1;			/* priority 			*/
	long e_pri2;			/* size if SJN or time if FCFS 	*/
	int e_size;			/* cumulative size in blocks of all 
					   the files in the request	*/
	time_t e_time;			/* time submitted 		*/
	char *e_from;			/* user submitting the request 	*/
	char *e_to;			/* job is for this user 	*/
	struct str_list *e_fnames;	/* names of files to be printed */
/* AIX security enhancement 						*/
/* removed e_directory. e_penv will include the directory		*/
	char *e_request;		/* title of job 		*/
	char *e_hostname;		/* enqueued at this host 	*/
	struct d *e_device;		/* device when we're running 	*/
	char e_retries;			/* retries so far on EXITERROR 	*/
	char e_acct;			/* account char 		*/
	char e_dnam[DNAME+1];		/* ANYDEV or device number 	*/
/* AIX security enhancement 						*/
/* removed e_uid and e_gid. e_pcred will include uid and gid		*/
/* added char **e_pcred. pcred list contains process credetials.	*/
/* added char **e_penv.  penv list contains process environment	*/
	char	**e_pcred;		/* submitter's process credentials	*/
	char	**e_penv;		/* submitter's process environment	*/
	boolean e_cp;			/* did the request have copy option */
	boolean e_no;			/* did the request have notify option */
	boolean e_mail;			/* did the request have mail_only option */
	int	e_nc;			/* number of copies per file 	*/
/* AIX security enhancement 						*/
/* removed struct con_groups. e_pcred contains concurrent group list	*/
	struct stfile *e_s;		/* status file struct for this job */
	char * 	e_msg;			/* operator messages for this request*/
	int	e_jdfnum;		/* number of arguments gotten from JDF file */
	char *	e_jdfvec[MAXARGS];	/* args from command line (JDF) */
	int	e_argnum;		/* number of args to the backend */
	char *	e_argvec[MAXARGS];	/* args generated at run time JDF + (/etc/qconfig) */
					/* probably a better way to dynamically allocate this
					   stuff...the deadline is near...LGM */
        char * e_cmdline;               /* original enq command line */
	boolean e_hold;			/* is this job to be held */
	int e_qorder;			/* queue order number */
};

/* D45466, common message queue structure, shared between enq & qdaemon */
typedef struct enq_msgbuf
        {
                long mtype;        /* message type */
                char jdfname[JDF_NAM_LEN];  /* job desc. filename */
        }
Message;


/* Declarations for procedures returning non-integer values */
char    *last20(), *getqn(), *getln(), *stname(),*LGdir;
void *Qalloc();
char    *localhost(), *sconcat(), *getlgnam();
long    reqsize();
time_t  modtime();
struct q        *readconfig();
struct e        *emake();
struct dir_ent  *dir_get();


/* Macro for getmesg in libque */
char * getmesg();
#define GETMESG(num,str) getmesg(num,str)

/* Macro for converting order number to job number */
#define JOBNUM(sortval) (sortval % 1000) 

/* palladium gateway path */
#define PDENQ_PATH "/usr/lpp/pd/bin/pdenq"

/* palladium argv and argc */
char *palarg[MAXARGS];
int palcnt;

/* palladium request types */
#define PAL_PRINT "0"
#define PAL_STATUS "1"
#define PAL_CANCEL "2"
