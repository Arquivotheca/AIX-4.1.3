a
# @(#)16    1.7  src/bos/usr/ccs/lib/libcurses/termcap.ed, libcurses, bos411, 9428A410j 9/3/93 14:48:21
#
#   COMPONENT_NAME: LIBCURSES
#
#   FUNCTIONS: termcap.ed
#
#   ORIGINS: 27, 4
#
#   This module contains IBM CONFIDENTIAL code. -- (IBM
#   Confidential Restricted when combined with the aggregated
#   modules for this product)
#                    SOURCE MATERIALS
#   (C) COPYRIGHT International Business Machines Corp. 1993
#   All Rights Reserved
#   US Government Users Restricted Rights - Use, duplication or
#   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
#
#
#	Copyright (c) 1984 AT&T
#	  All Rights Reserved
#
#	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T
#	The copyright notice above does not evidence any
#	actual or intended publication of such source code.
#
.
1,$d
!#ident	"@(#)curses:screen/termcap.ed	1.16"
H
!${ODE_TOOLS}/usr/bin/rm -f termcap.c
0a
/* #ident	"@(#)curses:screen/termcap.ed	1.16" */
/*
 * Simulation of termcap using terminfo.
 * This file is created from termcap.ed. DO NOT EDIT ME!
 */

/*
 * These are declared so people won't get undefineds if they use
 * old documentation.  We don't do anything with them.
 */

#include	"curses_inc.h"

char	*UP;
char	*BC;
char	PC;
short	ospeed;

/* ARGSUSED */
int
tgetent(bp, name)
char	*bp, *name;
{
    int	rv;

    if (setupterm(name, 1, &rv) >= 0)
	/* Leave things as they were (for compatibility) */
	reset_shell_mode();
    return (rv);
}

/* Make a 2 letter code into an integer we can switch on easily */
#define	_TWO(s1, s2)	(s1 + 256*s2)
#define	_TWOSTR(str)	_TWO(*str, str[1])

static	char	*
_stripdelays(inbuf, outbuf, size)
register	char	*inbuf, *outbuf;
register	int	size;
{
    char	*saveoutbuf = outbuf;

    if (inbuf == NULL)
	return (0);
    else
	while (size && *inbuf)
	    if (*inbuf == '$' && *(inbuf+1) == '<')
		while (*inbuf && *inbuf++ != '>')
		    ;
	    else
	    {
		size--;
		*outbuf++ = *inbuf++;
	    }
    return (saveoutbuf);
}

/* generated by sort on caps */
static	short	booloffsets[] =
		{		/* generated by sort on caps */
.
!${ODE_TOOLS}/usr/bin/sed -e '1,/^--- begin bool/d' -e '/^--- end bool/,$d' -e '/^#/d' < caps | ${ODE_TOOLS}/usr/bin/awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | ${ODE_TOOLS}/usr/bin/sort > ./tmp/termcap.tmp
.r !${ODE_TOOLS}/usr/bin/cat ./tmp/termcap.tmp
.a
		};

/* generated by sort on caps */
static	short	numoffsets[] =
		{
.
!${ODE_TOOLS}/usr/bin/sed -e '1,/^--- begin num/d' -e '/^--- end num/,$d' -e '/^#/d' < caps | ${ODE_TOOLS}/usr/bin/awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | ${ODE_TOOLS}/usr/bin/sort > ./tmp/termcap.tmp
.r !${ODE_TOOLS}/usr/bin/cat ./tmp/termcap.tmp
.a
		};

/* generated by sort on caps */
static	short	stroffsets[] =
		{
.
!${ODE_TOOLS}/usr/bin/sed -e '1,/^--- begin str/d' -e '/^--- end str/,$d' -e '/^#/d' < caps | ${ODE_TOOLS}/usr/bin/awk '{printf "\t/* \%s */\t\%d,\n", $3, i++}' | ${ODE_TOOLS}/usr/bin/sort > ./tmp/termcap.tmp
.r !${ODE_TOOLS}/usr/bin/cat ./tmp/termcap.tmp
!${ODE_TOOLS}/usr/bin/rm ./tmp/termcap.tmp
.a
		};

/*
 * Return the value of the boolean capability tcstr.
 * Return 0 if the capability is not found.
 */

tgetflag(tcstr)
register	char	*tcstr;
{
    register	char	*p;
    char	stripped[16];

    switch (_TWOSTR(tcstr))
    {
	/* Special cases that do not have exact terminfo equivalents */
	case _TWO('b','s'):
	    /* bs: true if ^H moves the cursor left */
	    p = _stripdelays(cursor_left, stripped, 16);
	    return (p && *p==8 && p[1] == 0);
	case _TWO('p','t'):
	    /* pt: true if terminal has ^I tabs every 8 spaces */
	    p = _stripdelays(tab, stripped, 16);
	    return (p && *p==9 && p[1] == 0);
	case _TWO('n','c'):
	    /* cr: true if ^M does not return the cursor */
	    p = _stripdelays(carriage_return, stripped, 16);
	    return (! (p && *p==13 && p[1] == 0));
	case _TWO('n','s'):
	    /* ns: true if no way to scroll the terminal */
	    return (scroll_forward == NULL);
    }
    {
	int	n = _NUMELEMENTS(booloffsets);
	int	offset = _tcsearch(tcstr, booloffsets, boolcodes, n, 2);
	char	*bool_array = (char *) cur_bools;

	if (offset == -1)
	    return (0);
	else
	    return (bool_array[offset]);
    }
}

/*
 * Return the value of the numeric capability tcstr.
 * Return -1 if the capability is not found.
 */

tgetnum(tcstr)
register	char	*tcstr;
{
    int		n = _NUMELEMENTS(numoffsets);
    int		offset = _tcsearch(tcstr, numoffsets, numcodes, n, 2);
    short	*num_array = (short *) cur_nums;

    if (offset == -1)
	return (-1);
    else
	return (num_array[offset]);
}

/*
 * Return the string capability for capability "id".  We also copy
 * it into *area for upward compatibility with a few programs that
 * actually expect it to be copied, at a slight cost in speed.
 */

char	*
tgetstr(tcstr, area)
register	char	*tcstr, **area;
{
    int		n = _NUMELEMENTS(stroffsets);
    int		offset = _tcsearch(tcstr, stroffsets, strcodes, n, 2);
    char	**str_array = (char **) cur_strs;
    char	*rv;

    if (offset == -1)
	return (0);
    rv = str_array[offset];
    if (area && *area)
    {
	(void) strcpy(*area, rv);
	*area += strlen(rv) + 1;
    }
    return (rv);
}
.
0r copyright.h
/screen\/copyright\.h/d
w termcap.c
q
