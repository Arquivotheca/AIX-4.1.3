#! /usr/bin/perl
# @(#)64	1.19  src/bldenv/bldtools/sym_lookup.pl, bldprocess, bos412, GOLDA411a 3/3/94 16:57:57
#
#
# COMPONENT_NAME: (BLDPROCESS) BAI Build Process
#
# FUNCTIONS: sym_lookup
#
# ORIGINS: 27
#
# (C) COPYRIGHT International Business Machines Corp. 1991
# All Rights Reserved
# Licensed Materials - Property of IBM
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
#
# NAME: sym_lookup
#
# FUNCTION: Creates the 'symptoms' file which contain defects in a build with
#	    corresponding notes with the SYMPTOM strings in them
#
# INPUT: noteview, formatted_noteview and error. These are filenames and last
#	 two of them created by sym_lookup containing the defects with notes 
#	 and defects (i.e notes without SYMPTOM strings) respectively
#
# EXECUTION ENVIRONMENT: The build environment


$noteview = shift(ARGV);  # The file generated by Report -view noteview

$formatted_noteview = shift(ARGV);  # The file with only notes of defects
				    # containing START and STOP SYMPTOMS

$usermemos = shift(ARGV);  	    # The file with only notes of defects
				    # containing START and STOP user MEMOS

$error = shift(ARGV);	# The file with defect numbers having no SYMPTOM notes

$dummy_symp = "START_SYMPTOM\nDUMMY SYMPTOM\nSTOP_SYMPTOM\n";
$dummy_symp =~ s/(\n)/"\376".ord($1)."\377"/eg;

&create_note_array;
&create_assoc_arrays;
&print_arrays($formatted_noteview,*symp_ary,$dummy_symp);
&print_arrays($usermemos,*memo_ary,"");

##############################################################################

# This function writes a file containing notes of a defect into seperate
# elements of an array

sub create_note_array{

	local(@buffer);

	open noteview || die "Could not open $noteview\n";
	@buffer = <noteview>;  # The notes file is read into an array with each 
			       # element containing one line of the file
	$i = -1;
	for (0..$#buffer){
		# if the element of the array(buffer) contains the pattern
		# similar to:
		# defect||action|Add date|login|name|dept|p|note

		# Then it is a new note and gets a new element 
		# created in the note array(note_ary)
	
		if ($buffer[$_] =~ /^.*\|.*\|.*\|\d{2}\/\d{2}\/\d{2} \d{2}\:\d{2}\:\d{2}\|.*\|.*\|.*\|.*\|.*$/){
			$i++;
			$note_ary[$i] = $buffer[$_];
		}
		# The pattern did not match and therefore the line is an 
		# extension of the previous element (note)

		else{
			$note_ary[$i] .= $buffer[$_];
		}
	}
	undef @buffer;		# Freeing memory held by buffer

}

##############################################################################

# The following function creates two associative arrays of symptoms and user
# memos from the notes of the defect (from note array)

sub create_assoc_arrays{

	local($defect,$note,$symptom,$memo);
	local($saint,$blessed_symp,$blessed_note);
	local($infidel_override_symp,$infidel_override_memo);
	open (ERROR,">$error") ||  die "Could not open $error\n";
	
	
	# The following loop creates an associative array with defects as keys 
	# and corresponding notes with SYMPTOM strings as values
	foreach (@note_ary){
	
		$/ = "";	# Enable paragraph mode
		$* = 1;		# Enable multi-line patterns

		# split each element into 9 fields getting the note for the 
		# defect in the last field, The first field contains the defect
		# number
	
		local(@ary) = split(/\|/,$_,9);
		# If the previous defect is different from the current one and 
		# the value for the defect in the associative array is null, 
		# The defect does not contain a note with SYMPTOM strings
	
		print ERROR "$defect\n"
			if (($defect ne "") && ($defect ne $ary[0]) && 
				($symp_ary{$defect} =~ /^$/));

		if ($defect ne $ary[0]) { 
			$blessed_symp = 0; 
			$blessed_note = 0; 
			# If this is not the first time through the loop
		        # then print out an appropriate warning if there
		        # was an attempt to override the last mustfix entry.
			if ($defect ne "" && $infidel_override_symp == 1) {
			    print STDERR "$defect: attempt to override ";
			    print STDERR "mustfix attached symptom ignored\n";
			}
			if ($defect ne "" && $infidel_override_note == 1) {
			    print STDERR "$defect: attempt to override ";
			    print STDERR "mustfix attached memo ignored\n";
			}
			$infidel_override_symp = 0;
			$infidel_override_note = 0;
		}

		$defect = $ary[0];
		$note = $ary[8];
		$login = $ary[4];

		# See if this note is from a 'mustfix' login

		if ($login =~ m/^mustfix.*/) {
			$saint = 1;
		}
		else {
			$saint = 0;
		}

		# Any newlines in the note is changed to unprintable characters

		$note =~ s/(\n)/"\376".ord($1)."\377"/eg;

		# if the note contains SYMPTOM strings , The defect and the 
		# note becomes the key and value pair in an associative array
		# Once a 'mustfix' symptom is found for the defect, 
		# only another 'mustfix' symptom will be used to update.
	
		if ($note =~ /^.*[(\376\d+\377)][(\376\d+\377)\s]*[Ss][tT][aA][rR][tT]_[sS][yY][mM][pP][tT][oO][mM].*[sS][tT][oO][pP]_[sS][yY][mM][pP][tT][oO][mM].*$|^[(\376\d+\377)\s]*[Ss][tT][aA][rR][tT]_[sS][yY][mM][pP][tT][oO][mM].*[sS][tT][oO][pP]_[sS][yY][mM][pP][tT][oO][mM].*$/){
			if (($blessed_symp != 1) || ($saint == 1)) {
				if ($saint == 1) { 
					$blessed_symp = 1;
					$infidel_override_symp = 0;
				}
				$symptom = $note;
				$symptom =~ s/^.*([Ss][tT][aA][rR][tT]_[sS][yY][mM][pP][tT][oO][mM].*[sS][tT][oO][pP]_[sS][yY][mM][pP][tT][oO][mM]).*$/$1/;
				$symp_ary{$defect} = $symptom;
			}
		        elsif (($blessed_symp == 1) && (saint != 1)) {
		                $infidel_override_symp = 1;
			}
		}
		else{
			
			$symp_ary{$defect} = ''
				unless defined $symp_ary{$defect};
		}

		# if the note contains MEMO strings , The defect and the 
		# note becomes the key and value pair in an associative array
		# Once a 'mustfix' memo is found for the defect, 
		# only another 'mustfix' memo will be used to update.

		if ($note =~ /^.*[(\376\d+\377)][(\376\d+\377)\s]*[Ss][tT][aA][rR][tT]_[mM][eE][mM][oO].*[(\376\d+\377)\s]*[sS][tT][oO][pP]_[mM][eE][mM][oO].*$|^[(\376\d+\377)\s]*[Ss][tT][aA][rR][tT]_[mM][eE][mM][oO].*[(\376\d+\377)\s]*[sS][tT][oO][pP]_[mM][eE][mM][oO].*$/){
			if (($blessed_note != 1) || ($saint == 1)) {
				if ($saint == 1) { 
					$blessed_note = 1;
					$infidel_override_note = 0;
				}
				$memo = $note;
				$memo =~ s/^.*([Ss][tT][aA][rR][tT]_[mM][eE][mM][oO].*[sS][tT][oO][pP]_[mM][eE][mM][oO]).*$/$1/;
				$memo_ary{$defect} = $memo;
			}
		        elsif (($blessed_note == 1) && (saint != 1)) {
		                $infidel_override_note = 1;
			}
		}
		else{
			
			$memo_ary{$defect} = ''
				unless defined $memo_ary{$defect};
		}
	}
	print ERROR "$defect\n"
		if ($symp_ary{$defect} =~ /^$/);
	# print out an appropriate warning if there
	# was an attempt to override the last mustfix entry.
	if ($defect ne "" && $infidel_override_symp == 1) {
	    print STDERR "$defect: attempt to override ";
	    print STDERR "mustfix attached symptom ignored\n";
	}
	if ($defect ne "" && $infidel_override_note == 1) {
	    print STDERR "$defect: attempt to override ";
	    print STDERR "mustfix attached memo ignored\n";
	}
}

##############################################################################
sub getfile_array{
	local($file,*file_ary) = @_;
	local($defect,$note);
	if (-s $file){
		open(INPUT,"<$file") || die "Could not open $file\n";
		while (<INPUT>){
			chop;
			($defect,$note) = split(/\|/,$_,2);
			if ( ! ($defect =~ /.*:.*/) )
                	{
                        	$defect .= ":" . $ENV{'DEFAULT_CMVCFAMILY'};
                	}
			$file_ary{$defect} = $note;
		}
	}
}
##############################################################################

# This function writes the associative arrays to the respective files

sub print_arrays{

	local($file,*assc_ary,$dummy_symp) = @_;
	local(%file_ary);
	$/ = "\n";
	$* = 0;
	&getfile_array($file,*file_ary);


	# The following loop writes the values of the associative array 
	# into the respective file in the release path

	open (OUTPUT,">$file") || 
		die "Could not open $file\n";
		
	foreach (keys %assc_ary){
		if ($assc_ary{$_} =~ /^$/){
                        if ((defined $ENV{'AREABLD'}) && ($dummy_symp ne "")) {
                                $file_ary{$_} = $dummy_symp;
                        } else {
                                next;
                        }
		}
		else{
			$file_ary{$_} = $assc_ary{$_};
		}
	}
	while (($defect,$note) = each %file_ary){
		print OUTPUT "$defect|$note\n";
	}
}
